# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type Account {
  accessToken: String
  accessTokenExpires: DateTime
  createdAt: DateTime!
  id: String!
  providerAccountId: String!
  providerId: String!
  providerType: String!
  refreshToken: String
  updatedAt: DateTime!
  user: User!
  userId: String!
}

type AccountCountAggregate {
  _all: Int!
  accessToken: Int!
  accessTokenExpires: Int!
  createdAt: Int!
  id: Int!
  providerAccountId: Int!
  providerId: Int!
  providerType: Int!
  refreshToken: Int!
  updatedAt: Int!
  userId: Int!
}

input AccountCountOrderByAggregateInput {
  accessToken: SortOrder
  accessTokenExpires: SortOrder
  createdAt: SortOrder
  id: SortOrder
  providerAccountId: SortOrder
  providerId: SortOrder
  providerType: SortOrder
  refreshToken: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input AccountCreateInput {
  accessToken: String
  accessTokenExpires: DateTime
  createdAt: DateTime
  id: String
  providerAccountId: String!
  providerId: String!
  providerType: String!
  refreshToken: String
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutAccountsInput!
}

input AccountCreateManyInput {
  accessToken: String
  accessTokenExpires: DateTime
  createdAt: DateTime
  id: String
  providerAccountId: String!
  providerId: String!
  providerType: String!
  refreshToken: String
  updatedAt: DateTime
  userId: String!
}

input AccountCreateManyUserInput {
  accessToken: String
  accessTokenExpires: DateTime
  createdAt: DateTime
  id: String
  providerAccountId: String!
  providerId: String!
  providerType: String!
  refreshToken: String
  updatedAt: DateTime
}

input AccountCreateManyUserInputEnvelope {
  data: [AccountCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input AccountCreateNestedManyWithoutUserInput {
  connect: [AccountWhereUniqueInput!]
  connectOrCreate: [AccountCreateOrConnectWithoutUserInput!]
  create: [AccountCreateWithoutUserInput!]
  createMany: AccountCreateManyUserInputEnvelope
}

input AccountCreateOrConnectWithoutUserInput {
  create: AccountCreateWithoutUserInput!
  where: AccountWhereUniqueInput!
}

input AccountCreateWithoutUserInput {
  accessToken: String
  accessTokenExpires: DateTime
  createdAt: DateTime
  id: String
  providerAccountId: String!
  providerId: String!
  providerType: String!
  refreshToken: String
  updatedAt: DateTime
}

type AccountGroupBy {
  _count: AccountCountAggregate
  _max: AccountMaxAggregate
  _min: AccountMinAggregate
  accessToken: String
  accessTokenExpires: DateTime
  createdAt: DateTime!
  id: String!
  providerAccountId: String!
  providerId: String!
  providerType: String!
  refreshToken: String
  updatedAt: DateTime!
  userId: String!
}

input AccountListRelationFilter {
  every: AccountWhereInput
  none: AccountWhereInput
  some: AccountWhereInput
}

type AccountMaxAggregate {
  accessToken: String
  accessTokenExpires: DateTime
  createdAt: DateTime
  id: String
  providerAccountId: String
  providerId: String
  providerType: String
  refreshToken: String
  updatedAt: DateTime
  userId: String
}

input AccountMaxOrderByAggregateInput {
  accessToken: SortOrder
  accessTokenExpires: SortOrder
  createdAt: SortOrder
  id: SortOrder
  providerAccountId: SortOrder
  providerId: SortOrder
  providerType: SortOrder
  refreshToken: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

type AccountMinAggregate {
  accessToken: String
  accessTokenExpires: DateTime
  createdAt: DateTime
  id: String
  providerAccountId: String
  providerId: String
  providerType: String
  refreshToken: String
  updatedAt: DateTime
  userId: String
}

input AccountMinOrderByAggregateInput {
  accessToken: SortOrder
  accessTokenExpires: SortOrder
  createdAt: SortOrder
  id: SortOrder
  providerAccountId: SortOrder
  providerId: SortOrder
  providerType: SortOrder
  refreshToken: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input AccountOrderByRelationAggregateInput {
  _count: SortOrder
}

enum AccountOrderByRelevanceFieldEnum {
  accessToken
  id
  providerAccountId
  providerId
  providerType
  refreshToken
  userId
}

input AccountOrderByRelevanceInput {
  fields: [AccountOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input AccountOrderByWithAggregationInput {
  _count: AccountCountOrderByAggregateInput
  _max: AccountMaxOrderByAggregateInput
  _min: AccountMinOrderByAggregateInput
  accessToken: SortOrder
  accessTokenExpires: SortOrder
  createdAt: SortOrder
  id: SortOrder
  providerAccountId: SortOrder
  providerId: SortOrder
  providerType: SortOrder
  refreshToken: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input AccountOrderByWithRelationAndSearchRelevanceInput {
  _relevance: AccountOrderByRelevanceInput
  accessToken: SortOrder
  accessTokenExpires: SortOrder
  createdAt: SortOrder
  id: SortOrder
  providerAccountId: SortOrder
  providerId: SortOrder
  providerType: SortOrder
  refreshToken: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationAndSearchRelevanceInput
  userId: SortOrder
}

input AccountProviderIdProviderAccountIdCompoundUniqueInput {
  providerAccountId: String!
  providerId: String!
}

enum AccountScalarFieldEnum {
  accessToken
  accessTokenExpires
  createdAt
  id
  providerAccountId
  providerId
  providerType
  refreshToken
  updatedAt
  userId
}

input AccountScalarWhereInput {
  AND: [AccountScalarWhereInput!]
  NOT: [AccountScalarWhereInput!]
  OR: [AccountScalarWhereInput!]
  accessToken: StringNullableFilter
  accessTokenExpires: DateTimeNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  providerAccountId: StringFilter
  providerId: StringFilter
  providerType: StringFilter
  refreshToken: StringNullableFilter
  updatedAt: DateTimeFilter
  userId: StringFilter
}

input AccountScalarWhereWithAggregatesInput {
  AND: [AccountScalarWhereWithAggregatesInput!]
  NOT: [AccountScalarWhereWithAggregatesInput!]
  OR: [AccountScalarWhereWithAggregatesInput!]
  accessToken: StringNullableWithAggregatesFilter
  accessTokenExpires: DateTimeNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  providerAccountId: StringWithAggregatesFilter
  providerId: StringWithAggregatesFilter
  providerType: StringWithAggregatesFilter
  refreshToken: StringNullableWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: StringWithAggregatesFilter
}

input AccountUpdateInput {
  accessToken: NullableStringFieldUpdateOperationsInput
  accessTokenExpires: NullableDateTimeFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  providerAccountId: StringFieldUpdateOperationsInput
  providerId: StringFieldUpdateOperationsInput
  providerType: StringFieldUpdateOperationsInput
  refreshToken: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutAccountsInput
}

input AccountUpdateManyMutationInput {
  accessToken: NullableStringFieldUpdateOperationsInput
  accessTokenExpires: NullableDateTimeFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  providerAccountId: StringFieldUpdateOperationsInput
  providerId: StringFieldUpdateOperationsInput
  providerType: StringFieldUpdateOperationsInput
  refreshToken: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AccountUpdateManyWithWhereWithoutUserInput {
  data: AccountUpdateManyMutationInput!
  where: AccountScalarWhereInput!
}

input AccountUpdateManyWithoutUserInput {
  connect: [AccountWhereUniqueInput!]
  connectOrCreate: [AccountCreateOrConnectWithoutUserInput!]
  create: [AccountCreateWithoutUserInput!]
  createMany: AccountCreateManyUserInputEnvelope
  delete: [AccountWhereUniqueInput!]
  deleteMany: [AccountScalarWhereInput!]
  disconnect: [AccountWhereUniqueInput!]
  set: [AccountWhereUniqueInput!]
  update: [AccountUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [AccountUpdateManyWithWhereWithoutUserInput!]
  upsert: [AccountUpsertWithWhereUniqueWithoutUserInput!]
}

input AccountUpdateWithWhereUniqueWithoutUserInput {
  data: AccountUpdateWithoutUserInput!
  where: AccountWhereUniqueInput!
}

input AccountUpdateWithoutUserInput {
  accessToken: NullableStringFieldUpdateOperationsInput
  accessTokenExpires: NullableDateTimeFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  providerAccountId: StringFieldUpdateOperationsInput
  providerId: StringFieldUpdateOperationsInput
  providerType: StringFieldUpdateOperationsInput
  refreshToken: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AccountUpsertWithWhereUniqueWithoutUserInput {
  create: AccountCreateWithoutUserInput!
  update: AccountUpdateWithoutUserInput!
  where: AccountWhereUniqueInput!
}

input AccountWhereInput {
  AND: [AccountWhereInput!]
  NOT: [AccountWhereInput!]
  OR: [AccountWhereInput!]
  accessToken: StringNullableFilter
  accessTokenExpires: DateTimeNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  providerAccountId: StringFilter
  providerId: StringFilter
  providerType: StringFilter
  refreshToken: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: StringFilter
}

input AccountWhereUniqueInput {
  id: String
  providerId_providerAccountId: AccountProviderIdProviderAccountIdCompoundUniqueInput
}

type Actor {
  _count: ActorCount
  createdAt: DateTime!
  id: Int!
  movies(cursor: MovieWhereUniqueInput, distinct: [MovieScalarFieldEnum!], orderBy: [MovieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: MovieWhereInput): [Movie!]!
  name: String!
  series: Serie
  seriesId: Int
  updatedAt: DateTime!
}

type ActorAvgAggregate {
  id: Float
  seriesId: Float
}

input ActorAvgOrderByAggregateInput {
  id: SortOrder
  seriesId: SortOrder
}

type ActorCount {
  movies: Int!
}

type ActorCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  name: Int!
  seriesId: Int!
  updatedAt: Int!
}

input ActorCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  seriesId: SortOrder
  updatedAt: SortOrder
}

input ActorCreateInput {
  createdAt: DateTime
  movies: MovieCreateNestedManyWithoutActorsInput
  name: String!
  series: SerieCreateNestedOneWithoutActorsInput
  updatedAt: DateTime
}

input ActorCreateManyInput {
  createdAt: DateTime
  id: Int
  name: String!
  seriesId: Int
  updatedAt: DateTime
}

input ActorCreateManySeriesInput {
  createdAt: DateTime
  id: Int
  name: String!
  updatedAt: DateTime
}

input ActorCreateManySeriesInputEnvelope {
  data: [ActorCreateManySeriesInput!]!
  skipDuplicates: Boolean
}

input ActorCreateNestedManyWithoutMoviesInput {
  connect: [ActorWhereUniqueInput!]
  connectOrCreate: [ActorCreateOrConnectWithoutMoviesInput!]
  create: [ActorCreateWithoutMoviesInput!]
}

input ActorCreateNestedManyWithoutSeriesInput {
  connect: [ActorWhereUniqueInput!]
  connectOrCreate: [ActorCreateOrConnectWithoutSeriesInput!]
  create: [ActorCreateWithoutSeriesInput!]
  createMany: ActorCreateManySeriesInputEnvelope
}

input ActorCreateOrConnectWithoutMoviesInput {
  create: ActorCreateWithoutMoviesInput!
  where: ActorWhereUniqueInput!
}

input ActorCreateOrConnectWithoutSeriesInput {
  create: ActorCreateWithoutSeriesInput!
  where: ActorWhereUniqueInput!
}

input ActorCreateWithoutMoviesInput {
  createdAt: DateTime
  name: String!
  series: SerieCreateNestedOneWithoutActorsInput
  updatedAt: DateTime
}

input ActorCreateWithoutSeriesInput {
  createdAt: DateTime
  movies: MovieCreateNestedManyWithoutActorsInput
  name: String!
  updatedAt: DateTime
}

type ActorGroupBy {
  _avg: ActorAvgAggregate
  _count: ActorCountAggregate
  _max: ActorMaxAggregate
  _min: ActorMinAggregate
  _sum: ActorSumAggregate
  createdAt: DateTime!
  id: Int!
  name: String!
  seriesId: Int
  updatedAt: DateTime!
}

input ActorListRelationFilter {
  every: ActorWhereInput
  none: ActorWhereInput
  some: ActorWhereInput
}

type ActorMaxAggregate {
  createdAt: DateTime
  id: Int
  name: String
  seriesId: Int
  updatedAt: DateTime
}

input ActorMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  seriesId: SortOrder
  updatedAt: SortOrder
}

type ActorMinAggregate {
  createdAt: DateTime
  id: Int
  name: String
  seriesId: Int
  updatedAt: DateTime
}

input ActorMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  seriesId: SortOrder
  updatedAt: SortOrder
}

input ActorOrderByRelationAggregateInput {
  _count: SortOrder
}

enum ActorOrderByRelevanceFieldEnum {
  name
}

input ActorOrderByRelevanceInput {
  fields: [ActorOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input ActorOrderByWithAggregationInput {
  _avg: ActorAvgOrderByAggregateInput
  _count: ActorCountOrderByAggregateInput
  _max: ActorMaxOrderByAggregateInput
  _min: ActorMinOrderByAggregateInput
  _sum: ActorSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  seriesId: SortOrder
  updatedAt: SortOrder
}

input ActorOrderByWithRelationAndSearchRelevanceInput {
  _relevance: ActorOrderByRelevanceInput
  createdAt: SortOrder
  id: SortOrder
  movies: MovieOrderByRelationAggregateInput
  name: SortOrder
  series: SerieOrderByWithRelationAndSearchRelevanceInput
  seriesId: SortOrder
  updatedAt: SortOrder
}

enum ActorScalarFieldEnum {
  createdAt
  id
  name
  seriesId
  updatedAt
}

input ActorScalarWhereInput {
  AND: [ActorScalarWhereInput!]
  NOT: [ActorScalarWhereInput!]
  OR: [ActorScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  seriesId: IntNullableFilter
  updatedAt: DateTimeFilter
}

input ActorScalarWhereWithAggregatesInput {
  AND: [ActorScalarWhereWithAggregatesInput!]
  NOT: [ActorScalarWhereWithAggregatesInput!]
  OR: [ActorScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  seriesId: IntNullableWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type ActorSumAggregate {
  id: Int
  seriesId: Int
}

input ActorSumOrderByAggregateInput {
  id: SortOrder
  seriesId: SortOrder
}

input ActorUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  movies: MovieUpdateManyWithoutActorsInput
  name: StringFieldUpdateOperationsInput
  series: SerieUpdateOneWithoutActorsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ActorUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ActorUpdateManyWithWhereWithoutMoviesInput {
  data: ActorUpdateManyMutationInput!
  where: ActorScalarWhereInput!
}

input ActorUpdateManyWithWhereWithoutSeriesInput {
  data: ActorUpdateManyMutationInput!
  where: ActorScalarWhereInput!
}

input ActorUpdateManyWithoutMoviesInput {
  connect: [ActorWhereUniqueInput!]
  connectOrCreate: [ActorCreateOrConnectWithoutMoviesInput!]
  create: [ActorCreateWithoutMoviesInput!]
  delete: [ActorWhereUniqueInput!]
  deleteMany: [ActorScalarWhereInput!]
  disconnect: [ActorWhereUniqueInput!]
  set: [ActorWhereUniqueInput!]
  update: [ActorUpdateWithWhereUniqueWithoutMoviesInput!]
  updateMany: [ActorUpdateManyWithWhereWithoutMoviesInput!]
  upsert: [ActorUpsertWithWhereUniqueWithoutMoviesInput!]
}

input ActorUpdateManyWithoutSeriesInput {
  connect: [ActorWhereUniqueInput!]
  connectOrCreate: [ActorCreateOrConnectWithoutSeriesInput!]
  create: [ActorCreateWithoutSeriesInput!]
  createMany: ActorCreateManySeriesInputEnvelope
  delete: [ActorWhereUniqueInput!]
  deleteMany: [ActorScalarWhereInput!]
  disconnect: [ActorWhereUniqueInput!]
  set: [ActorWhereUniqueInput!]
  update: [ActorUpdateWithWhereUniqueWithoutSeriesInput!]
  updateMany: [ActorUpdateManyWithWhereWithoutSeriesInput!]
  upsert: [ActorUpsertWithWhereUniqueWithoutSeriesInput!]
}

input ActorUpdateWithWhereUniqueWithoutMoviesInput {
  data: ActorUpdateWithoutMoviesInput!
  where: ActorWhereUniqueInput!
}

input ActorUpdateWithWhereUniqueWithoutSeriesInput {
  data: ActorUpdateWithoutSeriesInput!
  where: ActorWhereUniqueInput!
}

input ActorUpdateWithoutMoviesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  series: SerieUpdateOneWithoutActorsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ActorUpdateWithoutSeriesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  movies: MovieUpdateManyWithoutActorsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ActorUpsertWithWhereUniqueWithoutMoviesInput {
  create: ActorCreateWithoutMoviesInput!
  update: ActorUpdateWithoutMoviesInput!
  where: ActorWhereUniqueInput!
}

input ActorUpsertWithWhereUniqueWithoutSeriesInput {
  create: ActorCreateWithoutSeriesInput!
  update: ActorUpdateWithoutSeriesInput!
  where: ActorWhereUniqueInput!
}

input ActorWhereInput {
  AND: [ActorWhereInput!]
  NOT: [ActorWhereInput!]
  OR: [ActorWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  movies: MovieListRelationFilter
  name: StringFilter
  series: SerieRelationFilter
  seriesId: IntNullableFilter
  updatedAt: DateTimeFilter
}

input ActorWhereUniqueInput {
  id: Int
}

type AffectedRowsOutput {
  count: Int!
}

type AggregateAccount {
  _count: AccountCountAggregate
  _max: AccountMaxAggregate
  _min: AccountMinAggregate
}

type AggregateActor {
  _avg: ActorAvgAggregate
  _count: ActorCountAggregate
  _max: ActorMaxAggregate
  _min: ActorMinAggregate
  _sum: ActorSumAggregate
}

type AggregateAppSettings {
  _count: AppSettingsCountAggregate
  _max: AppSettingsMaxAggregate
  _min: AppSettingsMinAggregate
}

type AggregateDirector {
  _avg: DirectorAvgAggregate
  _count: DirectorCountAggregate
  _max: DirectorMaxAggregate
  _min: DirectorMinAggregate
  _sum: DirectorSumAggregate
}

type AggregateEpisode {
  _avg: EpisodeAvgAggregate
  _count: EpisodeCountAggregate
  _max: EpisodeMaxAggregate
  _min: EpisodeMinAggregate
  _sum: EpisodeSumAggregate
}

type AggregateEpisodesWatchlist {
  _avg: EpisodesWatchlistAvgAggregate
  _count: EpisodesWatchlistCountAggregate
  _max: EpisodesWatchlistMaxAggregate
  _min: EpisodesWatchlistMinAggregate
  _sum: EpisodesWatchlistSumAggregate
}

type AggregateGenre {
  _avg: GenreAvgAggregate
  _count: GenreCountAggregate
  _max: GenreMaxAggregate
  _min: GenreMinAggregate
  _sum: GenreSumAggregate
}

type AggregateLanguage {
  _avg: LanguageAvgAggregate
  _count: LanguageCountAggregate
  _max: LanguageMaxAggregate
  _min: LanguageMinAggregate
  _sum: LanguageSumAggregate
}

type AggregateMovie {
  _avg: MovieAvgAggregate
  _count: MovieCountAggregate
  _max: MovieMaxAggregate
  _min: MovieMinAggregate
  _sum: MovieSumAggregate
}

type AggregateMoviesWatchlist {
  _avg: MoviesWatchlistAvgAggregate
  _count: MoviesWatchlistCountAggregate
  _max: MoviesWatchlistMaxAggregate
  _min: MoviesWatchlistMinAggregate
  _sum: MoviesWatchlistSumAggregate
}

type AggregateSeason {
  _avg: SeasonAvgAggregate
  _count: SeasonCountAggregate
  _max: SeasonMaxAggregate
  _min: SeasonMinAggregate
  _sum: SeasonSumAggregate
}

type AggregateSerie {
  _avg: SerieAvgAggregate
  _count: SerieCountAggregate
  _max: SerieMaxAggregate
  _min: SerieMinAggregate
  _sum: SerieSumAggregate
}

type AggregateSeriesWatchlist {
  _avg: SeriesWatchlistAvgAggregate
  _count: SeriesWatchlistCountAggregate
  _max: SeriesWatchlistMaxAggregate
  _min: SeriesWatchlistMinAggregate
  _sum: SeriesWatchlistSumAggregate
}

type AggregateSession {
  _count: SessionCountAggregate
  _max: SessionMaxAggregate
  _min: SessionMinAggregate
}

type AggregateUser {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
}

type AggregateVerificationRequest {
  _count: VerificationRequestCountAggregate
  _max: VerificationRequestMaxAggregate
  _min: VerificationRequestMinAggregate
}

type AggregateWatchlist {
  _avg: WatchlistAvgAggregate
  _count: WatchlistCountAggregate
  _max: WatchlistMaxAggregate
  _min: WatchlistMinAggregate
  _sum: WatchlistSumAggregate
}

type AggregateWatchlistedEpisode {
  _avg: WatchlistedEpisodeAvgAggregate
  _count: WatchlistedEpisodeCountAggregate
  _max: WatchlistedEpisodeMaxAggregate
  _min: WatchlistedEpisodeMinAggregate
  _sum: WatchlistedEpisodeSumAggregate
}

type AggregateWatchlistedMovie {
  _avg: WatchlistedMovieAvgAggregate
  _count: WatchlistedMovieCountAggregate
  _max: WatchlistedMovieMaxAggregate
  _min: WatchlistedMovieMinAggregate
  _sum: WatchlistedMovieSumAggregate
}

type AggregateWatchlistedSerie {
  _avg: WatchlistedSerieAvgAggregate
  _count: WatchlistedSerieCountAggregate
  _max: WatchlistedSerieMaxAggregate
  _min: WatchlistedSerieMinAggregate
  _sum: WatchlistedSerieSumAggregate
}

type AppSettings {
  User: User
  createdAt: DateTime!
  id: String!
  name: String!
  updatedAt: DateTime!
  userId: String
  value: String!
}

type AppSettingsCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  name: Int!
  updatedAt: Int!
  userId: Int!
  value: Int!
}

input AppSettingsCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
  value: SortOrder
}

input AppSettingsCreateInput {
  User: UserCreateNestedOneWithoutSettingsInput
  createdAt: DateTime
  id: String
  name: String!
  updatedAt: DateTime
  value: String!
}

input AppSettingsCreateManyInput {
  createdAt: DateTime
  id: String
  name: String!
  updatedAt: DateTime
  userId: String
  value: String!
}

input AppSettingsCreateManyUserInput {
  createdAt: DateTime
  id: String
  name: String!
  updatedAt: DateTime
  value: String!
}

input AppSettingsCreateManyUserInputEnvelope {
  data: [AppSettingsCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input AppSettingsCreateNestedManyWithoutUserInput {
  connect: [AppSettingsWhereUniqueInput!]
  connectOrCreate: [AppSettingsCreateOrConnectWithoutUserInput!]
  create: [AppSettingsCreateWithoutUserInput!]
  createMany: AppSettingsCreateManyUserInputEnvelope
}

input AppSettingsCreateOrConnectWithoutUserInput {
  create: AppSettingsCreateWithoutUserInput!
  where: AppSettingsWhereUniqueInput!
}

input AppSettingsCreateWithoutUserInput {
  createdAt: DateTime
  id: String
  name: String!
  updatedAt: DateTime
  value: String!
}

type AppSettingsGroupBy {
  _count: AppSettingsCountAggregate
  _max: AppSettingsMaxAggregate
  _min: AppSettingsMinAggregate
  createdAt: DateTime!
  id: String!
  name: String!
  updatedAt: DateTime!
  userId: String
  value: String!
}

input AppSettingsListRelationFilter {
  every: AppSettingsWhereInput
  none: AppSettingsWhereInput
  some: AppSettingsWhereInput
}

type AppSettingsMaxAggregate {
  createdAt: DateTime
  id: String
  name: String
  updatedAt: DateTime
  userId: String
  value: String
}

input AppSettingsMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
  value: SortOrder
}

type AppSettingsMinAggregate {
  createdAt: DateTime
  id: String
  name: String
  updatedAt: DateTime
  userId: String
  value: String
}

input AppSettingsMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
  value: SortOrder
}

input AppSettingsNameUserIdCompoundUniqueInput {
  name: String!
  userId: String!
}

input AppSettingsOrderByRelationAggregateInput {
  _count: SortOrder
}

enum AppSettingsOrderByRelevanceFieldEnum {
  id
  name
  userId
  value
}

input AppSettingsOrderByRelevanceInput {
  fields: [AppSettingsOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input AppSettingsOrderByWithAggregationInput {
  _count: AppSettingsCountOrderByAggregateInput
  _max: AppSettingsMaxOrderByAggregateInput
  _min: AppSettingsMinOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
  value: SortOrder
}

input AppSettingsOrderByWithRelationAndSearchRelevanceInput {
  User: UserOrderByWithRelationAndSearchRelevanceInput
  _relevance: AppSettingsOrderByRelevanceInput
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
  value: SortOrder
}

enum AppSettingsScalarFieldEnum {
  createdAt
  id
  name
  updatedAt
  userId
  value
}

input AppSettingsScalarWhereInput {
  AND: [AppSettingsScalarWhereInput!]
  NOT: [AppSettingsScalarWhereInput!]
  OR: [AppSettingsScalarWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  name: StringFilter
  updatedAt: DateTimeFilter
  userId: StringNullableFilter
  value: StringFilter
}

input AppSettingsScalarWhereWithAggregatesInput {
  AND: [AppSettingsScalarWhereWithAggregatesInput!]
  NOT: [AppSettingsScalarWhereWithAggregatesInput!]
  OR: [AppSettingsScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: StringNullableWithAggregatesFilter
  value: StringWithAggregatesFilter
}

input AppSettingsUpdateInput {
  User: UserUpdateOneWithoutSettingsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
}

input AppSettingsUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
}

input AppSettingsUpdateManyWithWhereWithoutUserInput {
  data: AppSettingsUpdateManyMutationInput!
  where: AppSettingsScalarWhereInput!
}

input AppSettingsUpdateManyWithoutUserInput {
  connect: [AppSettingsWhereUniqueInput!]
  connectOrCreate: [AppSettingsCreateOrConnectWithoutUserInput!]
  create: [AppSettingsCreateWithoutUserInput!]
  createMany: AppSettingsCreateManyUserInputEnvelope
  delete: [AppSettingsWhereUniqueInput!]
  deleteMany: [AppSettingsScalarWhereInput!]
  disconnect: [AppSettingsWhereUniqueInput!]
  set: [AppSettingsWhereUniqueInput!]
  update: [AppSettingsUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [AppSettingsUpdateManyWithWhereWithoutUserInput!]
  upsert: [AppSettingsUpsertWithWhereUniqueWithoutUserInput!]
}

input AppSettingsUpdateWithWhereUniqueWithoutUserInput {
  data: AppSettingsUpdateWithoutUserInput!
  where: AppSettingsWhereUniqueInput!
}

input AppSettingsUpdateWithoutUserInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
}

input AppSettingsUpsertWithWhereUniqueWithoutUserInput {
  create: AppSettingsCreateWithoutUserInput!
  update: AppSettingsUpdateWithoutUserInput!
  where: AppSettingsWhereUniqueInput!
}

input AppSettingsWhereInput {
  AND: [AppSettingsWhereInput!]
  NOT: [AppSettingsWhereInput!]
  OR: [AppSettingsWhereInput!]
  User: UserRelationFilter
  createdAt: DateTimeFilter
  id: StringFilter
  name: StringFilter
  updatedAt: DateTimeFilter
  userId: StringNullableFilter
  value: StringFilter
}

input AppSettingsWhereUniqueInput {
  id: String
  name_userId: AppSettingsNameUserIdCompoundUniqueInput
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input DateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

type Director {
  _count: DirectorCount
  createdAt: DateTime!
  id: Int!
  movies(cursor: MovieWhereUniqueInput, distinct: [MovieScalarFieldEnum!], orderBy: [MovieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: MovieWhereInput): [Movie!]!
  name: String!
  series: Serie
  seriesId: Int
  updatedAt: DateTime!
}

type DirectorAvgAggregate {
  id: Float
  seriesId: Float
}

input DirectorAvgOrderByAggregateInput {
  id: SortOrder
  seriesId: SortOrder
}

type DirectorCount {
  movies: Int!
}

type DirectorCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  name: Int!
  seriesId: Int!
  updatedAt: Int!
}

input DirectorCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  seriesId: SortOrder
  updatedAt: SortOrder
}

input DirectorCreateInput {
  createdAt: DateTime
  movies: MovieCreateNestedManyWithoutDirectorsInput
  name: String!
  series: SerieCreateNestedOneWithoutDirectorsInput
  updatedAt: DateTime
}

input DirectorCreateManyInput {
  createdAt: DateTime
  id: Int
  name: String!
  seriesId: Int
  updatedAt: DateTime
}

input DirectorCreateManySeriesInput {
  createdAt: DateTime
  id: Int
  name: String!
  updatedAt: DateTime
}

input DirectorCreateManySeriesInputEnvelope {
  data: [DirectorCreateManySeriesInput!]!
  skipDuplicates: Boolean
}

input DirectorCreateNestedManyWithoutMoviesInput {
  connect: [DirectorWhereUniqueInput!]
  connectOrCreate: [DirectorCreateOrConnectWithoutMoviesInput!]
  create: [DirectorCreateWithoutMoviesInput!]
}

input DirectorCreateNestedManyWithoutSeriesInput {
  connect: [DirectorWhereUniqueInput!]
  connectOrCreate: [DirectorCreateOrConnectWithoutSeriesInput!]
  create: [DirectorCreateWithoutSeriesInput!]
  createMany: DirectorCreateManySeriesInputEnvelope
}

input DirectorCreateOrConnectWithoutMoviesInput {
  create: DirectorCreateWithoutMoviesInput!
  where: DirectorWhereUniqueInput!
}

input DirectorCreateOrConnectWithoutSeriesInput {
  create: DirectorCreateWithoutSeriesInput!
  where: DirectorWhereUniqueInput!
}

input DirectorCreateWithoutMoviesInput {
  createdAt: DateTime
  name: String!
  series: SerieCreateNestedOneWithoutDirectorsInput
  updatedAt: DateTime
}

input DirectorCreateWithoutSeriesInput {
  createdAt: DateTime
  movies: MovieCreateNestedManyWithoutDirectorsInput
  name: String!
  updatedAt: DateTime
}

type DirectorGroupBy {
  _avg: DirectorAvgAggregate
  _count: DirectorCountAggregate
  _max: DirectorMaxAggregate
  _min: DirectorMinAggregate
  _sum: DirectorSumAggregate
  createdAt: DateTime!
  id: Int!
  name: String!
  seriesId: Int
  updatedAt: DateTime!
}

input DirectorListRelationFilter {
  every: DirectorWhereInput
  none: DirectorWhereInput
  some: DirectorWhereInput
}

type DirectorMaxAggregate {
  createdAt: DateTime
  id: Int
  name: String
  seriesId: Int
  updatedAt: DateTime
}

input DirectorMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  seriesId: SortOrder
  updatedAt: SortOrder
}

type DirectorMinAggregate {
  createdAt: DateTime
  id: Int
  name: String
  seriesId: Int
  updatedAt: DateTime
}

input DirectorMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  seriesId: SortOrder
  updatedAt: SortOrder
}

input DirectorOrderByRelationAggregateInput {
  _count: SortOrder
}

enum DirectorOrderByRelevanceFieldEnum {
  name
}

input DirectorOrderByRelevanceInput {
  fields: [DirectorOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input DirectorOrderByWithAggregationInput {
  _avg: DirectorAvgOrderByAggregateInput
  _count: DirectorCountOrderByAggregateInput
  _max: DirectorMaxOrderByAggregateInput
  _min: DirectorMinOrderByAggregateInput
  _sum: DirectorSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  seriesId: SortOrder
  updatedAt: SortOrder
}

input DirectorOrderByWithRelationAndSearchRelevanceInput {
  _relevance: DirectorOrderByRelevanceInput
  createdAt: SortOrder
  id: SortOrder
  movies: MovieOrderByRelationAggregateInput
  name: SortOrder
  series: SerieOrderByWithRelationAndSearchRelevanceInput
  seriesId: SortOrder
  updatedAt: SortOrder
}

enum DirectorScalarFieldEnum {
  createdAt
  id
  name
  seriesId
  updatedAt
}

input DirectorScalarWhereInput {
  AND: [DirectorScalarWhereInput!]
  NOT: [DirectorScalarWhereInput!]
  OR: [DirectorScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  seriesId: IntNullableFilter
  updatedAt: DateTimeFilter
}

input DirectorScalarWhereWithAggregatesInput {
  AND: [DirectorScalarWhereWithAggregatesInput!]
  NOT: [DirectorScalarWhereWithAggregatesInput!]
  OR: [DirectorScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  seriesId: IntNullableWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type DirectorSumAggregate {
  id: Int
  seriesId: Int
}

input DirectorSumOrderByAggregateInput {
  id: SortOrder
  seriesId: SortOrder
}

input DirectorUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  movies: MovieUpdateManyWithoutDirectorsInput
  name: StringFieldUpdateOperationsInput
  series: SerieUpdateOneWithoutDirectorsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input DirectorUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input DirectorUpdateManyWithWhereWithoutMoviesInput {
  data: DirectorUpdateManyMutationInput!
  where: DirectorScalarWhereInput!
}

input DirectorUpdateManyWithWhereWithoutSeriesInput {
  data: DirectorUpdateManyMutationInput!
  where: DirectorScalarWhereInput!
}

input DirectorUpdateManyWithoutMoviesInput {
  connect: [DirectorWhereUniqueInput!]
  connectOrCreate: [DirectorCreateOrConnectWithoutMoviesInput!]
  create: [DirectorCreateWithoutMoviesInput!]
  delete: [DirectorWhereUniqueInput!]
  deleteMany: [DirectorScalarWhereInput!]
  disconnect: [DirectorWhereUniqueInput!]
  set: [DirectorWhereUniqueInput!]
  update: [DirectorUpdateWithWhereUniqueWithoutMoviesInput!]
  updateMany: [DirectorUpdateManyWithWhereWithoutMoviesInput!]
  upsert: [DirectorUpsertWithWhereUniqueWithoutMoviesInput!]
}

input DirectorUpdateManyWithoutSeriesInput {
  connect: [DirectorWhereUniqueInput!]
  connectOrCreate: [DirectorCreateOrConnectWithoutSeriesInput!]
  create: [DirectorCreateWithoutSeriesInput!]
  createMany: DirectorCreateManySeriesInputEnvelope
  delete: [DirectorWhereUniqueInput!]
  deleteMany: [DirectorScalarWhereInput!]
  disconnect: [DirectorWhereUniqueInput!]
  set: [DirectorWhereUniqueInput!]
  update: [DirectorUpdateWithWhereUniqueWithoutSeriesInput!]
  updateMany: [DirectorUpdateManyWithWhereWithoutSeriesInput!]
  upsert: [DirectorUpsertWithWhereUniqueWithoutSeriesInput!]
}

input DirectorUpdateWithWhereUniqueWithoutMoviesInput {
  data: DirectorUpdateWithoutMoviesInput!
  where: DirectorWhereUniqueInput!
}

input DirectorUpdateWithWhereUniqueWithoutSeriesInput {
  data: DirectorUpdateWithoutSeriesInput!
  where: DirectorWhereUniqueInput!
}

input DirectorUpdateWithoutMoviesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  series: SerieUpdateOneWithoutDirectorsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input DirectorUpdateWithoutSeriesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  movies: MovieUpdateManyWithoutDirectorsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input DirectorUpsertWithWhereUniqueWithoutMoviesInput {
  create: DirectorCreateWithoutMoviesInput!
  update: DirectorUpdateWithoutMoviesInput!
  where: DirectorWhereUniqueInput!
}

input DirectorUpsertWithWhereUniqueWithoutSeriesInput {
  create: DirectorCreateWithoutSeriesInput!
  update: DirectorUpdateWithoutSeriesInput!
  where: DirectorWhereUniqueInput!
}

input DirectorWhereInput {
  AND: [DirectorWhereInput!]
  NOT: [DirectorWhereInput!]
  OR: [DirectorWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  movies: MovieListRelationFilter
  name: StringFilter
  series: SerieRelationFilter
  seriesId: IntNullableFilter
  updatedAt: DateTimeFilter
}

input DirectorWhereUniqueInput {
  id: Int
}

input EnumRoleFieldUpdateOperationsInput {
  set: Role
}

input EnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input EnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

type Episode {
  _count: EpisodeCount
  createdAt: DateTime!
  id: Int!
  imdbID: String!
  imdbRating: Float!
  plot: String!
  poster: String!
  runtime: Int!
  season: Season!
  seasonId: Int!
  title: String!
  updatedAt: DateTime!
  watchlist(cursor: WatchlistedEpisodeWhereUniqueInput, distinct: [WatchlistedEpisodeScalarFieldEnum!], orderBy: [WatchlistedEpisodeOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: WatchlistedEpisodeWhereInput): [WatchlistedEpisode!]!
}

type EpisodeAvgAggregate {
  id: Float
  imdbRating: Float
  runtime: Float
  seasonId: Float
}

input EpisodeAvgOrderByAggregateInput {
  id: SortOrder
  imdbRating: SortOrder
  runtime: SortOrder
  seasonId: SortOrder
}

type EpisodeCount {
  watchlist: Int!
}

type EpisodeCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  imdbID: Int!
  imdbRating: Int!
  plot: Int!
  poster: Int!
  runtime: Int!
  seasonId: Int!
  title: Int!
  updatedAt: Int!
}

input EpisodeCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  imdbID: SortOrder
  imdbRating: SortOrder
  plot: SortOrder
  poster: SortOrder
  runtime: SortOrder
  seasonId: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input EpisodeCreateInput {
  createdAt: DateTime
  imdbID: String!
  imdbRating: Float!
  plot: String!
  poster: String!
  runtime: Int!
  season: SeasonCreateNestedOneWithoutEpisodeIdsInput!
  title: String!
  updatedAt: DateTime
  watchlist: WatchlistedEpisodeCreateNestedManyWithoutEpisodeInput
}

input EpisodeCreateManyInput {
  createdAt: DateTime
  id: Int
  imdbID: String!
  imdbRating: Float!
  plot: String!
  poster: String!
  runtime: Int!
  seasonId: Int!
  title: String!
  updatedAt: DateTime
}

input EpisodeCreateManySeasonInput {
  createdAt: DateTime
  id: Int
  imdbID: String!
  imdbRating: Float!
  plot: String!
  poster: String!
  runtime: Int!
  title: String!
  updatedAt: DateTime
}

input EpisodeCreateManySeasonInputEnvelope {
  data: [EpisodeCreateManySeasonInput!]!
  skipDuplicates: Boolean
}

input EpisodeCreateNestedManyWithoutSeasonInput {
  connect: [EpisodeWhereUniqueInput!]
  connectOrCreate: [EpisodeCreateOrConnectWithoutSeasonInput!]
  create: [EpisodeCreateWithoutSeasonInput!]
  createMany: EpisodeCreateManySeasonInputEnvelope
}

input EpisodeCreateNestedOneWithoutWatchlistInput {
  connect: EpisodeWhereUniqueInput
  connectOrCreate: EpisodeCreateOrConnectWithoutWatchlistInput
  create: EpisodeCreateWithoutWatchlistInput
}

input EpisodeCreateOrConnectWithoutSeasonInput {
  create: EpisodeCreateWithoutSeasonInput!
  where: EpisodeWhereUniqueInput!
}

input EpisodeCreateOrConnectWithoutWatchlistInput {
  create: EpisodeCreateWithoutWatchlistInput!
  where: EpisodeWhereUniqueInput!
}

input EpisodeCreateWithoutSeasonInput {
  createdAt: DateTime
  imdbID: String!
  imdbRating: Float!
  plot: String!
  poster: String!
  runtime: Int!
  title: String!
  updatedAt: DateTime
  watchlist: WatchlistedEpisodeCreateNestedManyWithoutEpisodeInput
}

input EpisodeCreateWithoutWatchlistInput {
  createdAt: DateTime
  imdbID: String!
  imdbRating: Float!
  plot: String!
  poster: String!
  runtime: Int!
  season: SeasonCreateNestedOneWithoutEpisodeIdsInput!
  title: String!
  updatedAt: DateTime
}

type EpisodeGroupBy {
  _avg: EpisodeAvgAggregate
  _count: EpisodeCountAggregate
  _max: EpisodeMaxAggregate
  _min: EpisodeMinAggregate
  _sum: EpisodeSumAggregate
  createdAt: DateTime!
  id: Int!
  imdbID: String!
  imdbRating: Float!
  plot: String!
  poster: String!
  runtime: Int!
  seasonId: Int!
  title: String!
  updatedAt: DateTime!
}

input EpisodeListRelationFilter {
  every: EpisodeWhereInput
  none: EpisodeWhereInput
  some: EpisodeWhereInput
}

type EpisodeMaxAggregate {
  createdAt: DateTime
  id: Int
  imdbID: String
  imdbRating: Float
  plot: String
  poster: String
  runtime: Int
  seasonId: Int
  title: String
  updatedAt: DateTime
}

input EpisodeMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  imdbID: SortOrder
  imdbRating: SortOrder
  plot: SortOrder
  poster: SortOrder
  runtime: SortOrder
  seasonId: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

type EpisodeMinAggregate {
  createdAt: DateTime
  id: Int
  imdbID: String
  imdbRating: Float
  plot: String
  poster: String
  runtime: Int
  seasonId: Int
  title: String
  updatedAt: DateTime
}

input EpisodeMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  imdbID: SortOrder
  imdbRating: SortOrder
  plot: SortOrder
  poster: SortOrder
  runtime: SortOrder
  seasonId: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input EpisodeOrderByRelationAggregateInput {
  _count: SortOrder
}

enum EpisodeOrderByRelevanceFieldEnum {
  imdbID
  plot
  poster
  title
}

input EpisodeOrderByRelevanceInput {
  fields: [EpisodeOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input EpisodeOrderByWithAggregationInput {
  _avg: EpisodeAvgOrderByAggregateInput
  _count: EpisodeCountOrderByAggregateInput
  _max: EpisodeMaxOrderByAggregateInput
  _min: EpisodeMinOrderByAggregateInput
  _sum: EpisodeSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  imdbID: SortOrder
  imdbRating: SortOrder
  plot: SortOrder
  poster: SortOrder
  runtime: SortOrder
  seasonId: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input EpisodeOrderByWithRelationAndSearchRelevanceInput {
  _relevance: EpisodeOrderByRelevanceInput
  createdAt: SortOrder
  id: SortOrder
  imdbID: SortOrder
  imdbRating: SortOrder
  plot: SortOrder
  poster: SortOrder
  runtime: SortOrder
  season: SeasonOrderByWithRelationAndSearchRelevanceInput
  seasonId: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  watchlist: WatchlistedEpisodeOrderByRelationAggregateInput
}

input EpisodeRelationFilter {
  is: EpisodeWhereInput
  isNot: EpisodeWhereInput
}

enum EpisodeScalarFieldEnum {
  createdAt
  id
  imdbID
  imdbRating
  plot
  poster
  runtime
  seasonId
  title
  updatedAt
}

input EpisodeScalarWhereInput {
  AND: [EpisodeScalarWhereInput!]
  NOT: [EpisodeScalarWhereInput!]
  OR: [EpisodeScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  imdbID: StringFilter
  imdbRating: FloatFilter
  plot: StringFilter
  poster: StringFilter
  runtime: IntFilter
  seasonId: IntFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input EpisodeScalarWhereWithAggregatesInput {
  AND: [EpisodeScalarWhereWithAggregatesInput!]
  NOT: [EpisodeScalarWhereWithAggregatesInput!]
  OR: [EpisodeScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  imdbID: StringWithAggregatesFilter
  imdbRating: FloatWithAggregatesFilter
  plot: StringWithAggregatesFilter
  poster: StringWithAggregatesFilter
  runtime: IntWithAggregatesFilter
  seasonId: IntWithAggregatesFilter
  title: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type EpisodeSumAggregate {
  id: Int
  imdbRating: Float
  runtime: Int
  seasonId: Int
}

input EpisodeSumOrderByAggregateInput {
  id: SortOrder
  imdbRating: SortOrder
  runtime: SortOrder
  seasonId: SortOrder
}

input EpisodeUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  season: SeasonUpdateOneRequiredWithoutEpisodeIdsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  watchlist: WatchlistedEpisodeUpdateManyWithoutEpisodeInput
}

input EpisodeUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input EpisodeUpdateManyWithWhereWithoutSeasonInput {
  data: EpisodeUpdateManyMutationInput!
  where: EpisodeScalarWhereInput!
}

input EpisodeUpdateManyWithoutSeasonInput {
  connect: [EpisodeWhereUniqueInput!]
  connectOrCreate: [EpisodeCreateOrConnectWithoutSeasonInput!]
  create: [EpisodeCreateWithoutSeasonInput!]
  createMany: EpisodeCreateManySeasonInputEnvelope
  delete: [EpisodeWhereUniqueInput!]
  deleteMany: [EpisodeScalarWhereInput!]
  disconnect: [EpisodeWhereUniqueInput!]
  set: [EpisodeWhereUniqueInput!]
  update: [EpisodeUpdateWithWhereUniqueWithoutSeasonInput!]
  updateMany: [EpisodeUpdateManyWithWhereWithoutSeasonInput!]
  upsert: [EpisodeUpsertWithWhereUniqueWithoutSeasonInput!]
}

input EpisodeUpdateOneRequiredWithoutWatchlistInput {
  connect: EpisodeWhereUniqueInput
  connectOrCreate: EpisodeCreateOrConnectWithoutWatchlistInput
  create: EpisodeCreateWithoutWatchlistInput
  update: EpisodeUpdateWithoutWatchlistInput
  upsert: EpisodeUpsertWithoutWatchlistInput
}

input EpisodeUpdateWithWhereUniqueWithoutSeasonInput {
  data: EpisodeUpdateWithoutSeasonInput!
  where: EpisodeWhereUniqueInput!
}

input EpisodeUpdateWithoutSeasonInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  watchlist: WatchlistedEpisodeUpdateManyWithoutEpisodeInput
}

input EpisodeUpdateWithoutWatchlistInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  season: SeasonUpdateOneRequiredWithoutEpisodeIdsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input EpisodeUpsertWithWhereUniqueWithoutSeasonInput {
  create: EpisodeCreateWithoutSeasonInput!
  update: EpisodeUpdateWithoutSeasonInput!
  where: EpisodeWhereUniqueInput!
}

input EpisodeUpsertWithoutWatchlistInput {
  create: EpisodeCreateWithoutWatchlistInput!
  update: EpisodeUpdateWithoutWatchlistInput!
}

input EpisodeWhereInput {
  AND: [EpisodeWhereInput!]
  NOT: [EpisodeWhereInput!]
  OR: [EpisodeWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  imdbID: StringFilter
  imdbRating: FloatFilter
  plot: StringFilter
  poster: StringFilter
  runtime: IntFilter
  season: SeasonRelationFilter
  seasonId: IntFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  watchlist: WatchlistedEpisodeListRelationFilter
}

input EpisodeWhereUniqueInput {
  id: Int
  imdbID: String
}

type EpisodesWatchlist {
  _count: EpisodesWatchlistCount
  episodes(cursor: WatchlistedEpisodeWhereUniqueInput, distinct: [WatchlistedEpisodeScalarFieldEnum!], orderBy: [WatchlistedEpisodeOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: WatchlistedEpisodeWhereInput): [WatchlistedEpisode!]!
  id: Int!
  watchlist: Watchlist!
  watchlistId: Int!
}

type EpisodesWatchlistAvgAggregate {
  id: Float
  watchlistId: Float
}

input EpisodesWatchlistAvgOrderByAggregateInput {
  id: SortOrder
  watchlistId: SortOrder
}

type EpisodesWatchlistCount {
  episodes: Int!
}

type EpisodesWatchlistCountAggregate {
  _all: Int!
  id: Int!
  watchlistId: Int!
}

input EpisodesWatchlistCountOrderByAggregateInput {
  id: SortOrder
  watchlistId: SortOrder
}

input EpisodesWatchlistCreateInput {
  episodes: WatchlistedEpisodeCreateNestedManyWithoutWatchlistInput
  id: Int!
  watchlist: WatchlistCreateNestedOneWithoutEpisodeWatchlistInput!
}

input EpisodesWatchlistCreateManyInput {
  id: Int!
  watchlistId: Int!
}

input EpisodesWatchlistCreateNestedOneWithoutEpisodesInput {
  connect: EpisodesWatchlistWhereUniqueInput
  connectOrCreate: EpisodesWatchlistCreateOrConnectWithoutEpisodesInput
  create: EpisodesWatchlistCreateWithoutEpisodesInput
}

input EpisodesWatchlistCreateNestedOneWithoutWatchlistInput {
  connect: EpisodesWatchlistWhereUniqueInput
  connectOrCreate: EpisodesWatchlistCreateOrConnectWithoutWatchlistInput
  create: EpisodesWatchlistCreateWithoutWatchlistInput
}

input EpisodesWatchlistCreateOrConnectWithoutEpisodesInput {
  create: EpisodesWatchlistCreateWithoutEpisodesInput!
  where: EpisodesWatchlistWhereUniqueInput!
}

input EpisodesWatchlistCreateOrConnectWithoutWatchlistInput {
  create: EpisodesWatchlistCreateWithoutWatchlistInput!
  where: EpisodesWatchlistWhereUniqueInput!
}

input EpisodesWatchlistCreateWithoutEpisodesInput {
  id: Int!
  watchlist: WatchlistCreateNestedOneWithoutEpisodeWatchlistInput!
}

input EpisodesWatchlistCreateWithoutWatchlistInput {
  episodes: WatchlistedEpisodeCreateNestedManyWithoutWatchlistInput
  id: Int!
}

type EpisodesWatchlistGroupBy {
  _avg: EpisodesWatchlistAvgAggregate
  _count: EpisodesWatchlistCountAggregate
  _max: EpisodesWatchlistMaxAggregate
  _min: EpisodesWatchlistMinAggregate
  _sum: EpisodesWatchlistSumAggregate
  id: Int!
  watchlistId: Int!
}

type EpisodesWatchlistMaxAggregate {
  id: Int
  watchlistId: Int
}

input EpisodesWatchlistMaxOrderByAggregateInput {
  id: SortOrder
  watchlistId: SortOrder
}

type EpisodesWatchlistMinAggregate {
  id: Int
  watchlistId: Int
}

input EpisodesWatchlistMinOrderByAggregateInput {
  id: SortOrder
  watchlistId: SortOrder
}

input EpisodesWatchlistOrderByWithAggregationInput {
  _avg: EpisodesWatchlistAvgOrderByAggregateInput
  _count: EpisodesWatchlistCountOrderByAggregateInput
  _max: EpisodesWatchlistMaxOrderByAggregateInput
  _min: EpisodesWatchlistMinOrderByAggregateInput
  _sum: EpisodesWatchlistSumOrderByAggregateInput
  id: SortOrder
  watchlistId: SortOrder
}

input EpisodesWatchlistOrderByWithRelationAndSearchRelevanceInput {
  episodes: WatchlistedEpisodeOrderByRelationAggregateInput
  id: SortOrder
  watchlist: WatchlistOrderByWithRelationAndSearchRelevanceInput
  watchlistId: SortOrder
}

input EpisodesWatchlistRelationFilter {
  is: EpisodesWatchlistWhereInput
  isNot: EpisodesWatchlistWhereInput
}

enum EpisodesWatchlistScalarFieldEnum {
  id
  watchlistId
}

input EpisodesWatchlistScalarWhereWithAggregatesInput {
  AND: [EpisodesWatchlistScalarWhereWithAggregatesInput!]
  NOT: [EpisodesWatchlistScalarWhereWithAggregatesInput!]
  OR: [EpisodesWatchlistScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  watchlistId: IntWithAggregatesFilter
}

type EpisodesWatchlistSumAggregate {
  id: Int
  watchlistId: Int
}

input EpisodesWatchlistSumOrderByAggregateInput {
  id: SortOrder
  watchlistId: SortOrder
}

input EpisodesWatchlistUpdateInput {
  episodes: WatchlistedEpisodeUpdateManyWithoutWatchlistInput
  id: IntFieldUpdateOperationsInput
  watchlist: WatchlistUpdateOneRequiredWithoutEpisodeWatchlistInput
}

input EpisodesWatchlistUpdateManyMutationInput {
  id: IntFieldUpdateOperationsInput
}

input EpisodesWatchlistUpdateOneRequiredWithoutEpisodesInput {
  connect: EpisodesWatchlistWhereUniqueInput
  connectOrCreate: EpisodesWatchlistCreateOrConnectWithoutEpisodesInput
  create: EpisodesWatchlistCreateWithoutEpisodesInput
  update: EpisodesWatchlistUpdateWithoutEpisodesInput
  upsert: EpisodesWatchlistUpsertWithoutEpisodesInput
}

input EpisodesWatchlistUpdateOneWithoutWatchlistInput {
  connect: EpisodesWatchlistWhereUniqueInput
  connectOrCreate: EpisodesWatchlistCreateOrConnectWithoutWatchlistInput
  create: EpisodesWatchlistCreateWithoutWatchlistInput
  delete: Boolean
  disconnect: Boolean
  update: EpisodesWatchlistUpdateWithoutWatchlistInput
  upsert: EpisodesWatchlistUpsertWithoutWatchlistInput
}

input EpisodesWatchlistUpdateWithoutEpisodesInput {
  id: IntFieldUpdateOperationsInput
  watchlist: WatchlistUpdateOneRequiredWithoutEpisodeWatchlistInput
}

input EpisodesWatchlistUpdateWithoutWatchlistInput {
  episodes: WatchlistedEpisodeUpdateManyWithoutWatchlistInput
  id: IntFieldUpdateOperationsInput
}

input EpisodesWatchlistUpsertWithoutEpisodesInput {
  create: EpisodesWatchlistCreateWithoutEpisodesInput!
  update: EpisodesWatchlistUpdateWithoutEpisodesInput!
}

input EpisodesWatchlistUpsertWithoutWatchlistInput {
  create: EpisodesWatchlistCreateWithoutWatchlistInput!
  update: EpisodesWatchlistUpdateWithoutWatchlistInput!
}

input EpisodesWatchlistWhereInput {
  AND: [EpisodesWatchlistWhereInput!]
  NOT: [EpisodesWatchlistWhereInput!]
  OR: [EpisodesWatchlistWhereInput!]
  episodes: WatchlistedEpisodeListRelationFilter
  id: IntFilter
  watchlist: WatchlistRelationFilter
  watchlistId: IntFilter
}

input EpisodesWatchlistWhereUniqueInput {
  id: Int
  watchlistId: Int
}

input FloatFieldUpdateOperationsInput {
  decrement: Float
  divide: Float
  increment: Float
  multiply: Float
  set: Float
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input FloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float!]
}

type Genre {
  _count: GenreCount
  createdAt: DateTime!
  id: Int!
  movies(cursor: MovieWhereUniqueInput, distinct: [MovieScalarFieldEnum!], orderBy: [MovieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: MovieWhereInput): [Movie!]!
  name: String!
  series(cursor: SerieWhereUniqueInput, distinct: [SerieScalarFieldEnum!], orderBy: [SerieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: SerieWhereInput): [Serie!]!
  updatedAt: DateTime!
}

type GenreAvgAggregate {
  id: Float
}

input GenreAvgOrderByAggregateInput {
  id: SortOrder
}

type GenreCount {
  movies: Int!
  series: Int!
}

type GenreCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  name: Int!
  updatedAt: Int!
}

input GenreCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input GenreCreateInput {
  createdAt: DateTime
  movies: MovieCreateNestedManyWithoutGenresInput
  name: String!
  series: SerieCreateNestedManyWithoutGenresInput
  updatedAt: DateTime
}

input GenreCreateManyInput {
  createdAt: DateTime
  id: Int
  name: String!
  updatedAt: DateTime
}

input GenreCreateNestedManyWithoutMoviesInput {
  connect: [GenreWhereUniqueInput!]
  connectOrCreate: [GenreCreateOrConnectWithoutMoviesInput!]
  create: [GenreCreateWithoutMoviesInput!]
}

input GenreCreateNestedManyWithoutSeriesInput {
  connect: [GenreWhereUniqueInput!]
  connectOrCreate: [GenreCreateOrConnectWithoutSeriesInput!]
  create: [GenreCreateWithoutSeriesInput!]
}

input GenreCreateOrConnectWithoutMoviesInput {
  create: GenreCreateWithoutMoviesInput!
  where: GenreWhereUniqueInput!
}

input GenreCreateOrConnectWithoutSeriesInput {
  create: GenreCreateWithoutSeriesInput!
  where: GenreWhereUniqueInput!
}

input GenreCreateWithoutMoviesInput {
  createdAt: DateTime
  name: String!
  series: SerieCreateNestedManyWithoutGenresInput
  updatedAt: DateTime
}

input GenreCreateWithoutSeriesInput {
  createdAt: DateTime
  movies: MovieCreateNestedManyWithoutGenresInput
  name: String!
  updatedAt: DateTime
}

type GenreGroupBy {
  _avg: GenreAvgAggregate
  _count: GenreCountAggregate
  _max: GenreMaxAggregate
  _min: GenreMinAggregate
  _sum: GenreSumAggregate
  createdAt: DateTime!
  id: Int!
  name: String!
  updatedAt: DateTime!
}

input GenreListRelationFilter {
  every: GenreWhereInput
  none: GenreWhereInput
  some: GenreWhereInput
}

type GenreMaxAggregate {
  createdAt: DateTime
  id: Int
  name: String
  updatedAt: DateTime
}

input GenreMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

type GenreMinAggregate {
  createdAt: DateTime
  id: Int
  name: String
  updatedAt: DateTime
}

input GenreMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input GenreOrderByRelationAggregateInput {
  _count: SortOrder
}

enum GenreOrderByRelevanceFieldEnum {
  name
}

input GenreOrderByRelevanceInput {
  fields: [GenreOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input GenreOrderByWithAggregationInput {
  _avg: GenreAvgOrderByAggregateInput
  _count: GenreCountOrderByAggregateInput
  _max: GenreMaxOrderByAggregateInput
  _min: GenreMinOrderByAggregateInput
  _sum: GenreSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input GenreOrderByWithRelationAndSearchRelevanceInput {
  _relevance: GenreOrderByRelevanceInput
  createdAt: SortOrder
  id: SortOrder
  movies: MovieOrderByRelationAggregateInput
  name: SortOrder
  series: SerieOrderByRelationAggregateInput
  updatedAt: SortOrder
}

enum GenreScalarFieldEnum {
  createdAt
  id
  name
  updatedAt
}

input GenreScalarWhereInput {
  AND: [GenreScalarWhereInput!]
  NOT: [GenreScalarWhereInput!]
  OR: [GenreScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  updatedAt: DateTimeFilter
}

input GenreScalarWhereWithAggregatesInput {
  AND: [GenreScalarWhereWithAggregatesInput!]
  NOT: [GenreScalarWhereWithAggregatesInput!]
  OR: [GenreScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type GenreSumAggregate {
  id: Int
}

input GenreSumOrderByAggregateInput {
  id: SortOrder
}

input GenreUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  movies: MovieUpdateManyWithoutGenresInput
  name: StringFieldUpdateOperationsInput
  series: SerieUpdateManyWithoutGenresInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input GenreUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input GenreUpdateManyWithWhereWithoutMoviesInput {
  data: GenreUpdateManyMutationInput!
  where: GenreScalarWhereInput!
}

input GenreUpdateManyWithWhereWithoutSeriesInput {
  data: GenreUpdateManyMutationInput!
  where: GenreScalarWhereInput!
}

input GenreUpdateManyWithoutMoviesInput {
  connect: [GenreWhereUniqueInput!]
  connectOrCreate: [GenreCreateOrConnectWithoutMoviesInput!]
  create: [GenreCreateWithoutMoviesInput!]
  delete: [GenreWhereUniqueInput!]
  deleteMany: [GenreScalarWhereInput!]
  disconnect: [GenreWhereUniqueInput!]
  set: [GenreWhereUniqueInput!]
  update: [GenreUpdateWithWhereUniqueWithoutMoviesInput!]
  updateMany: [GenreUpdateManyWithWhereWithoutMoviesInput!]
  upsert: [GenreUpsertWithWhereUniqueWithoutMoviesInput!]
}

input GenreUpdateManyWithoutSeriesInput {
  connect: [GenreWhereUniqueInput!]
  connectOrCreate: [GenreCreateOrConnectWithoutSeriesInput!]
  create: [GenreCreateWithoutSeriesInput!]
  delete: [GenreWhereUniqueInput!]
  deleteMany: [GenreScalarWhereInput!]
  disconnect: [GenreWhereUniqueInput!]
  set: [GenreWhereUniqueInput!]
  update: [GenreUpdateWithWhereUniqueWithoutSeriesInput!]
  updateMany: [GenreUpdateManyWithWhereWithoutSeriesInput!]
  upsert: [GenreUpsertWithWhereUniqueWithoutSeriesInput!]
}

input GenreUpdateWithWhereUniqueWithoutMoviesInput {
  data: GenreUpdateWithoutMoviesInput!
  where: GenreWhereUniqueInput!
}

input GenreUpdateWithWhereUniqueWithoutSeriesInput {
  data: GenreUpdateWithoutSeriesInput!
  where: GenreWhereUniqueInput!
}

input GenreUpdateWithoutMoviesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  series: SerieUpdateManyWithoutGenresInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input GenreUpdateWithoutSeriesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  movies: MovieUpdateManyWithoutGenresInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input GenreUpsertWithWhereUniqueWithoutMoviesInput {
  create: GenreCreateWithoutMoviesInput!
  update: GenreUpdateWithoutMoviesInput!
  where: GenreWhereUniqueInput!
}

input GenreUpsertWithWhereUniqueWithoutSeriesInput {
  create: GenreCreateWithoutSeriesInput!
  update: GenreUpdateWithoutSeriesInput!
  where: GenreWhereUniqueInput!
}

input GenreWhereInput {
  AND: [GenreWhereInput!]
  NOT: [GenreWhereInput!]
  OR: [GenreWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  movies: MovieListRelationFilter
  name: StringFilter
  series: SerieListRelationFilter
  updatedAt: DateTimeFilter
}

input GenreWhereUniqueInput {
  id: Int
  name: String
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Language {
  _count: LanguageCount
  createdAt: DateTime!
  id: Int!
  movies(cursor: MovieWhereUniqueInput, distinct: [MovieScalarFieldEnum!], orderBy: [MovieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: MovieWhereInput): [Movie!]!
  name: String!
  series(cursor: SerieWhereUniqueInput, distinct: [SerieScalarFieldEnum!], orderBy: [SerieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: SerieWhereInput): [Serie!]!
  seriesId: Int
  updatedAt: DateTime!
}

type LanguageAvgAggregate {
  id: Float
  seriesId: Float
}

input LanguageAvgOrderByAggregateInput {
  id: SortOrder
  seriesId: SortOrder
}

type LanguageCount {
  movies: Int!
  series: Int!
}

type LanguageCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  name: Int!
  seriesId: Int!
  updatedAt: Int!
}

input LanguageCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  seriesId: SortOrder
  updatedAt: SortOrder
}

input LanguageCreateInput {
  createdAt: DateTime
  movies: MovieCreateNestedManyWithoutLanguagesInput
  name: String!
  series: SerieCreateNestedManyWithoutLanguagesInput
  seriesId: Int
  updatedAt: DateTime
}

input LanguageCreateManyInput {
  createdAt: DateTime
  id: Int
  name: String!
  seriesId: Int
  updatedAt: DateTime
}

input LanguageCreateNestedManyWithoutMoviesInput {
  connect: [LanguageWhereUniqueInput!]
  connectOrCreate: [LanguageCreateOrConnectWithoutMoviesInput!]
  create: [LanguageCreateWithoutMoviesInput!]
}

input LanguageCreateNestedManyWithoutSeriesInput {
  connect: [LanguageWhereUniqueInput!]
  connectOrCreate: [LanguageCreateOrConnectWithoutSeriesInput!]
  create: [LanguageCreateWithoutSeriesInput!]
}

input LanguageCreateOrConnectWithoutMoviesInput {
  create: LanguageCreateWithoutMoviesInput!
  where: LanguageWhereUniqueInput!
}

input LanguageCreateOrConnectWithoutSeriesInput {
  create: LanguageCreateWithoutSeriesInput!
  where: LanguageWhereUniqueInput!
}

input LanguageCreateWithoutMoviesInput {
  createdAt: DateTime
  name: String!
  series: SerieCreateNestedManyWithoutLanguagesInput
  seriesId: Int
  updatedAt: DateTime
}

input LanguageCreateWithoutSeriesInput {
  createdAt: DateTime
  movies: MovieCreateNestedManyWithoutLanguagesInput
  name: String!
  seriesId: Int
  updatedAt: DateTime
}

type LanguageGroupBy {
  _avg: LanguageAvgAggregate
  _count: LanguageCountAggregate
  _max: LanguageMaxAggregate
  _min: LanguageMinAggregate
  _sum: LanguageSumAggregate
  createdAt: DateTime!
  id: Int!
  name: String!
  seriesId: Int
  updatedAt: DateTime!
}

input LanguageListRelationFilter {
  every: LanguageWhereInput
  none: LanguageWhereInput
  some: LanguageWhereInput
}

type LanguageMaxAggregate {
  createdAt: DateTime
  id: Int
  name: String
  seriesId: Int
  updatedAt: DateTime
}

input LanguageMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  seriesId: SortOrder
  updatedAt: SortOrder
}

type LanguageMinAggregate {
  createdAt: DateTime
  id: Int
  name: String
  seriesId: Int
  updatedAt: DateTime
}

input LanguageMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  seriesId: SortOrder
  updatedAt: SortOrder
}

input LanguageOrderByRelationAggregateInput {
  _count: SortOrder
}

enum LanguageOrderByRelevanceFieldEnum {
  name
}

input LanguageOrderByRelevanceInput {
  fields: [LanguageOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input LanguageOrderByWithAggregationInput {
  _avg: LanguageAvgOrderByAggregateInput
  _count: LanguageCountOrderByAggregateInput
  _max: LanguageMaxOrderByAggregateInput
  _min: LanguageMinOrderByAggregateInput
  _sum: LanguageSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  seriesId: SortOrder
  updatedAt: SortOrder
}

input LanguageOrderByWithRelationAndSearchRelevanceInput {
  _relevance: LanguageOrderByRelevanceInput
  createdAt: SortOrder
  id: SortOrder
  movies: MovieOrderByRelationAggregateInput
  name: SortOrder
  series: SerieOrderByRelationAggregateInput
  seriesId: SortOrder
  updatedAt: SortOrder
}

enum LanguageScalarFieldEnum {
  createdAt
  id
  name
  seriesId
  updatedAt
}

input LanguageScalarWhereInput {
  AND: [LanguageScalarWhereInput!]
  NOT: [LanguageScalarWhereInput!]
  OR: [LanguageScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  seriesId: IntNullableFilter
  updatedAt: DateTimeFilter
}

input LanguageScalarWhereWithAggregatesInput {
  AND: [LanguageScalarWhereWithAggregatesInput!]
  NOT: [LanguageScalarWhereWithAggregatesInput!]
  OR: [LanguageScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  seriesId: IntNullableWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type LanguageSumAggregate {
  id: Int
  seriesId: Int
}

input LanguageSumOrderByAggregateInput {
  id: SortOrder
  seriesId: SortOrder
}

input LanguageUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  movies: MovieUpdateManyWithoutLanguagesInput
  name: StringFieldUpdateOperationsInput
  series: SerieUpdateManyWithoutLanguagesInput
  seriesId: NullableIntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input LanguageUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  seriesId: NullableIntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input LanguageUpdateManyWithWhereWithoutMoviesInput {
  data: LanguageUpdateManyMutationInput!
  where: LanguageScalarWhereInput!
}

input LanguageUpdateManyWithWhereWithoutSeriesInput {
  data: LanguageUpdateManyMutationInput!
  where: LanguageScalarWhereInput!
}

input LanguageUpdateManyWithoutMoviesInput {
  connect: [LanguageWhereUniqueInput!]
  connectOrCreate: [LanguageCreateOrConnectWithoutMoviesInput!]
  create: [LanguageCreateWithoutMoviesInput!]
  delete: [LanguageWhereUniqueInput!]
  deleteMany: [LanguageScalarWhereInput!]
  disconnect: [LanguageWhereUniqueInput!]
  set: [LanguageWhereUniqueInput!]
  update: [LanguageUpdateWithWhereUniqueWithoutMoviesInput!]
  updateMany: [LanguageUpdateManyWithWhereWithoutMoviesInput!]
  upsert: [LanguageUpsertWithWhereUniqueWithoutMoviesInput!]
}

input LanguageUpdateManyWithoutSeriesInput {
  connect: [LanguageWhereUniqueInput!]
  connectOrCreate: [LanguageCreateOrConnectWithoutSeriesInput!]
  create: [LanguageCreateWithoutSeriesInput!]
  delete: [LanguageWhereUniqueInput!]
  deleteMany: [LanguageScalarWhereInput!]
  disconnect: [LanguageWhereUniqueInput!]
  set: [LanguageWhereUniqueInput!]
  update: [LanguageUpdateWithWhereUniqueWithoutSeriesInput!]
  updateMany: [LanguageUpdateManyWithWhereWithoutSeriesInput!]
  upsert: [LanguageUpsertWithWhereUniqueWithoutSeriesInput!]
}

input LanguageUpdateWithWhereUniqueWithoutMoviesInput {
  data: LanguageUpdateWithoutMoviesInput!
  where: LanguageWhereUniqueInput!
}

input LanguageUpdateWithWhereUniqueWithoutSeriesInput {
  data: LanguageUpdateWithoutSeriesInput!
  where: LanguageWhereUniqueInput!
}

input LanguageUpdateWithoutMoviesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  series: SerieUpdateManyWithoutLanguagesInput
  seriesId: NullableIntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input LanguageUpdateWithoutSeriesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  movies: MovieUpdateManyWithoutLanguagesInput
  name: StringFieldUpdateOperationsInput
  seriesId: NullableIntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input LanguageUpsertWithWhereUniqueWithoutMoviesInput {
  create: LanguageCreateWithoutMoviesInput!
  update: LanguageUpdateWithoutMoviesInput!
  where: LanguageWhereUniqueInput!
}

input LanguageUpsertWithWhereUniqueWithoutSeriesInput {
  create: LanguageCreateWithoutSeriesInput!
  update: LanguageUpdateWithoutSeriesInput!
  where: LanguageWhereUniqueInput!
}

input LanguageWhereInput {
  AND: [LanguageWhereInput!]
  NOT: [LanguageWhereInput!]
  OR: [LanguageWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  movies: MovieListRelationFilter
  name: StringFilter
  series: SerieListRelationFilter
  seriesId: IntNullableFilter
  updatedAt: DateTimeFilter
}

input LanguageWhereUniqueInput {
  id: Int
  name: String
}

type Movie {
  _count: MovieCount
  actors(cursor: ActorWhereUniqueInput, distinct: [ActorScalarFieldEnum!], orderBy: [ActorOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: ActorWhereInput): [Actor!]!
  createdAt: DateTime!
  directors(cursor: DirectorWhereUniqueInput, distinct: [DirectorScalarFieldEnum!], orderBy: [DirectorOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: DirectorWhereInput): [Director!]!
  genres(cursor: GenreWhereUniqueInput, distinct: [GenreScalarFieldEnum!], orderBy: [GenreOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: GenreWhereInput): [Genre!]!
  id: Int!
  imdbID: String!
  imdbRating: Float!
  languages(cursor: LanguageWhereUniqueInput, distinct: [LanguageScalarFieldEnum!], orderBy: [LanguageOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: LanguageWhereInput): [Language!]!
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  title: String!
  updatedAt: DateTime!
  watchlist(cursor: WatchlistedMovieWhereUniqueInput, distinct: [WatchlistedMovieScalarFieldEnum!], orderBy: [WatchlistedMovieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: WatchlistedMovieWhereInput): [WatchlistedMovie!]!
  year: Int!
}

type MovieAvgAggregate {
  id: Float
  imdbRating: Float
  runtime: Float
  year: Float
}

input MovieAvgOrderByAggregateInput {
  id: SortOrder
  imdbRating: SortOrder
  runtime: SortOrder
  year: SortOrder
}

type MovieCount {
  actors: Int!
  directors: Int!
  genres: Int!
  languages: Int!
  watchlist: Int!
}

type MovieCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  imdbID: Int!
  imdbRating: Int!
  plot: Int!
  poster: Int!
  rating: Int!
  release: Int!
  runtime: Int!
  title: Int!
  updatedAt: Int!
  year: Int!
}

input MovieCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  imdbID: SortOrder
  imdbRating: SortOrder
  plot: SortOrder
  poster: SortOrder
  rating: SortOrder
  release: SortOrder
  runtime: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  year: SortOrder
}

input MovieCreateInput {
  actors: ActorCreateNestedManyWithoutMoviesInput
  createdAt: DateTime
  directors: DirectorCreateNestedManyWithoutMoviesInput
  genres: GenreCreateNestedManyWithoutMoviesInput
  imdbID: String!
  imdbRating: Float!
  languages: LanguageCreateNestedManyWithoutMoviesInput
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  title: String!
  updatedAt: DateTime
  watchlist: WatchlistedMovieCreateNestedManyWithoutMovieInput
  year: Int!
}

input MovieCreateManyInput {
  createdAt: DateTime
  id: Int
  imdbID: String!
  imdbRating: Float!
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  title: String!
  updatedAt: DateTime
  year: Int!
}

input MovieCreateNestedManyWithoutActorsInput {
  connect: [MovieWhereUniqueInput!]
  connectOrCreate: [MovieCreateOrConnectWithoutActorsInput!]
  create: [MovieCreateWithoutActorsInput!]
}

input MovieCreateNestedManyWithoutDirectorsInput {
  connect: [MovieWhereUniqueInput!]
  connectOrCreate: [MovieCreateOrConnectWithoutDirectorsInput!]
  create: [MovieCreateWithoutDirectorsInput!]
}

input MovieCreateNestedManyWithoutGenresInput {
  connect: [MovieWhereUniqueInput!]
  connectOrCreate: [MovieCreateOrConnectWithoutGenresInput!]
  create: [MovieCreateWithoutGenresInput!]
}

input MovieCreateNestedManyWithoutLanguagesInput {
  connect: [MovieWhereUniqueInput!]
  connectOrCreate: [MovieCreateOrConnectWithoutLanguagesInput!]
  create: [MovieCreateWithoutLanguagesInput!]
}

input MovieCreateNestedOneWithoutWatchlistInput {
  connect: MovieWhereUniqueInput
  connectOrCreate: MovieCreateOrConnectWithoutWatchlistInput
  create: MovieCreateWithoutWatchlistInput
}

input MovieCreateOrConnectWithoutActorsInput {
  create: MovieCreateWithoutActorsInput!
  where: MovieWhereUniqueInput!
}

input MovieCreateOrConnectWithoutDirectorsInput {
  create: MovieCreateWithoutDirectorsInput!
  where: MovieWhereUniqueInput!
}

input MovieCreateOrConnectWithoutGenresInput {
  create: MovieCreateWithoutGenresInput!
  where: MovieWhereUniqueInput!
}

input MovieCreateOrConnectWithoutLanguagesInput {
  create: MovieCreateWithoutLanguagesInput!
  where: MovieWhereUniqueInput!
}

input MovieCreateOrConnectWithoutWatchlistInput {
  create: MovieCreateWithoutWatchlistInput!
  where: MovieWhereUniqueInput!
}

input MovieCreateWithoutActorsInput {
  createdAt: DateTime
  directors: DirectorCreateNestedManyWithoutMoviesInput
  genres: GenreCreateNestedManyWithoutMoviesInput
  imdbID: String!
  imdbRating: Float!
  languages: LanguageCreateNestedManyWithoutMoviesInput
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  title: String!
  updatedAt: DateTime
  watchlist: WatchlistedMovieCreateNestedManyWithoutMovieInput
  year: Int!
}

input MovieCreateWithoutDirectorsInput {
  actors: ActorCreateNestedManyWithoutMoviesInput
  createdAt: DateTime
  genres: GenreCreateNestedManyWithoutMoviesInput
  imdbID: String!
  imdbRating: Float!
  languages: LanguageCreateNestedManyWithoutMoviesInput
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  title: String!
  updatedAt: DateTime
  watchlist: WatchlistedMovieCreateNestedManyWithoutMovieInput
  year: Int!
}

input MovieCreateWithoutGenresInput {
  actors: ActorCreateNestedManyWithoutMoviesInput
  createdAt: DateTime
  directors: DirectorCreateNestedManyWithoutMoviesInput
  imdbID: String!
  imdbRating: Float!
  languages: LanguageCreateNestedManyWithoutMoviesInput
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  title: String!
  updatedAt: DateTime
  watchlist: WatchlistedMovieCreateNestedManyWithoutMovieInput
  year: Int!
}

input MovieCreateWithoutLanguagesInput {
  actors: ActorCreateNestedManyWithoutMoviesInput
  createdAt: DateTime
  directors: DirectorCreateNestedManyWithoutMoviesInput
  genres: GenreCreateNestedManyWithoutMoviesInput
  imdbID: String!
  imdbRating: Float!
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  title: String!
  updatedAt: DateTime
  watchlist: WatchlistedMovieCreateNestedManyWithoutMovieInput
  year: Int!
}

input MovieCreateWithoutWatchlistInput {
  actors: ActorCreateNestedManyWithoutMoviesInput
  createdAt: DateTime
  directors: DirectorCreateNestedManyWithoutMoviesInput
  genres: GenreCreateNestedManyWithoutMoviesInput
  imdbID: String!
  imdbRating: Float!
  languages: LanguageCreateNestedManyWithoutMoviesInput
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  title: String!
  updatedAt: DateTime
  year: Int!
}

type MovieGroupBy {
  _avg: MovieAvgAggregate
  _count: MovieCountAggregate
  _max: MovieMaxAggregate
  _min: MovieMinAggregate
  _sum: MovieSumAggregate
  createdAt: DateTime!
  id: Int!
  imdbID: String!
  imdbRating: Float!
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  title: String!
  updatedAt: DateTime!
  year: Int!
}

input MovieListRelationFilter {
  every: MovieWhereInput
  none: MovieWhereInput
  some: MovieWhereInput
}

type MovieMaxAggregate {
  createdAt: DateTime
  id: Int
  imdbID: String
  imdbRating: Float
  plot: String
  poster: String
  rating: String
  release: DateTime
  runtime: Int
  title: String
  updatedAt: DateTime
  year: Int
}

input MovieMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  imdbID: SortOrder
  imdbRating: SortOrder
  plot: SortOrder
  poster: SortOrder
  rating: SortOrder
  release: SortOrder
  runtime: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  year: SortOrder
}

type MovieMinAggregate {
  createdAt: DateTime
  id: Int
  imdbID: String
  imdbRating: Float
  plot: String
  poster: String
  rating: String
  release: DateTime
  runtime: Int
  title: String
  updatedAt: DateTime
  year: Int
}

input MovieMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  imdbID: SortOrder
  imdbRating: SortOrder
  plot: SortOrder
  poster: SortOrder
  rating: SortOrder
  release: SortOrder
  runtime: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  year: SortOrder
}

input MovieOrderByRelationAggregateInput {
  _count: SortOrder
}

enum MovieOrderByRelevanceFieldEnum {
  imdbID
  plot
  poster
  rating
  title
}

input MovieOrderByRelevanceInput {
  fields: [MovieOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input MovieOrderByWithAggregationInput {
  _avg: MovieAvgOrderByAggregateInput
  _count: MovieCountOrderByAggregateInput
  _max: MovieMaxOrderByAggregateInput
  _min: MovieMinOrderByAggregateInput
  _sum: MovieSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  imdbID: SortOrder
  imdbRating: SortOrder
  plot: SortOrder
  poster: SortOrder
  rating: SortOrder
  release: SortOrder
  runtime: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  year: SortOrder
}

input MovieOrderByWithRelationAndSearchRelevanceInput {
  _relevance: MovieOrderByRelevanceInput
  actors: ActorOrderByRelationAggregateInput
  createdAt: SortOrder
  directors: DirectorOrderByRelationAggregateInput
  genres: GenreOrderByRelationAggregateInput
  id: SortOrder
  imdbID: SortOrder
  imdbRating: SortOrder
  languages: LanguageOrderByRelationAggregateInput
  plot: SortOrder
  poster: SortOrder
  rating: SortOrder
  release: SortOrder
  runtime: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  watchlist: WatchlistedMovieOrderByRelationAggregateInput
  year: SortOrder
}

input MovieRelationFilter {
  is: MovieWhereInput
  isNot: MovieWhereInput
}

enum MovieScalarFieldEnum {
  createdAt
  id
  imdbID
  imdbRating
  plot
  poster
  rating
  release
  runtime
  title
  updatedAt
  year
}

input MovieScalarWhereInput {
  AND: [MovieScalarWhereInput!]
  NOT: [MovieScalarWhereInput!]
  OR: [MovieScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  imdbID: StringFilter
  imdbRating: FloatFilter
  plot: StringFilter
  poster: StringFilter
  rating: StringFilter
  release: DateTimeFilter
  runtime: IntFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  year: IntFilter
}

input MovieScalarWhereWithAggregatesInput {
  AND: [MovieScalarWhereWithAggregatesInput!]
  NOT: [MovieScalarWhereWithAggregatesInput!]
  OR: [MovieScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  imdbID: StringWithAggregatesFilter
  imdbRating: FloatWithAggregatesFilter
  plot: StringWithAggregatesFilter
  poster: StringWithAggregatesFilter
  rating: StringWithAggregatesFilter
  release: DateTimeWithAggregatesFilter
  runtime: IntWithAggregatesFilter
  title: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  year: IntWithAggregatesFilter
}

type MovieSumAggregate {
  id: Int
  imdbRating: Float
  runtime: Int
  year: Int
}

input MovieSumOrderByAggregateInput {
  id: SortOrder
  imdbRating: SortOrder
  runtime: SortOrder
  year: SortOrder
}

input MovieUpdateInput {
  actors: ActorUpdateManyWithoutMoviesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  directors: DirectorUpdateManyWithoutMoviesInput
  genres: GenreUpdateManyWithoutMoviesInput
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  languages: LanguageUpdateManyWithoutMoviesInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  rating: StringFieldUpdateOperationsInput
  release: DateTimeFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  watchlist: WatchlistedMovieUpdateManyWithoutMovieInput
  year: IntFieldUpdateOperationsInput
}

input MovieUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  rating: StringFieldUpdateOperationsInput
  release: DateTimeFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  year: IntFieldUpdateOperationsInput
}

input MovieUpdateManyWithWhereWithoutActorsInput {
  data: MovieUpdateManyMutationInput!
  where: MovieScalarWhereInput!
}

input MovieUpdateManyWithWhereWithoutDirectorsInput {
  data: MovieUpdateManyMutationInput!
  where: MovieScalarWhereInput!
}

input MovieUpdateManyWithWhereWithoutGenresInput {
  data: MovieUpdateManyMutationInput!
  where: MovieScalarWhereInput!
}

input MovieUpdateManyWithWhereWithoutLanguagesInput {
  data: MovieUpdateManyMutationInput!
  where: MovieScalarWhereInput!
}

input MovieUpdateManyWithoutActorsInput {
  connect: [MovieWhereUniqueInput!]
  connectOrCreate: [MovieCreateOrConnectWithoutActorsInput!]
  create: [MovieCreateWithoutActorsInput!]
  delete: [MovieWhereUniqueInput!]
  deleteMany: [MovieScalarWhereInput!]
  disconnect: [MovieWhereUniqueInput!]
  set: [MovieWhereUniqueInput!]
  update: [MovieUpdateWithWhereUniqueWithoutActorsInput!]
  updateMany: [MovieUpdateManyWithWhereWithoutActorsInput!]
  upsert: [MovieUpsertWithWhereUniqueWithoutActorsInput!]
}

input MovieUpdateManyWithoutDirectorsInput {
  connect: [MovieWhereUniqueInput!]
  connectOrCreate: [MovieCreateOrConnectWithoutDirectorsInput!]
  create: [MovieCreateWithoutDirectorsInput!]
  delete: [MovieWhereUniqueInput!]
  deleteMany: [MovieScalarWhereInput!]
  disconnect: [MovieWhereUniqueInput!]
  set: [MovieWhereUniqueInput!]
  update: [MovieUpdateWithWhereUniqueWithoutDirectorsInput!]
  updateMany: [MovieUpdateManyWithWhereWithoutDirectorsInput!]
  upsert: [MovieUpsertWithWhereUniqueWithoutDirectorsInput!]
}

input MovieUpdateManyWithoutGenresInput {
  connect: [MovieWhereUniqueInput!]
  connectOrCreate: [MovieCreateOrConnectWithoutGenresInput!]
  create: [MovieCreateWithoutGenresInput!]
  delete: [MovieWhereUniqueInput!]
  deleteMany: [MovieScalarWhereInput!]
  disconnect: [MovieWhereUniqueInput!]
  set: [MovieWhereUniqueInput!]
  update: [MovieUpdateWithWhereUniqueWithoutGenresInput!]
  updateMany: [MovieUpdateManyWithWhereWithoutGenresInput!]
  upsert: [MovieUpsertWithWhereUniqueWithoutGenresInput!]
}

input MovieUpdateManyWithoutLanguagesInput {
  connect: [MovieWhereUniqueInput!]
  connectOrCreate: [MovieCreateOrConnectWithoutLanguagesInput!]
  create: [MovieCreateWithoutLanguagesInput!]
  delete: [MovieWhereUniqueInput!]
  deleteMany: [MovieScalarWhereInput!]
  disconnect: [MovieWhereUniqueInput!]
  set: [MovieWhereUniqueInput!]
  update: [MovieUpdateWithWhereUniqueWithoutLanguagesInput!]
  updateMany: [MovieUpdateManyWithWhereWithoutLanguagesInput!]
  upsert: [MovieUpsertWithWhereUniqueWithoutLanguagesInput!]
}

input MovieUpdateOneRequiredWithoutWatchlistInput {
  connect: MovieWhereUniqueInput
  connectOrCreate: MovieCreateOrConnectWithoutWatchlistInput
  create: MovieCreateWithoutWatchlistInput
  update: MovieUpdateWithoutWatchlistInput
  upsert: MovieUpsertWithoutWatchlistInput
}

input MovieUpdateWithWhereUniqueWithoutActorsInput {
  data: MovieUpdateWithoutActorsInput!
  where: MovieWhereUniqueInput!
}

input MovieUpdateWithWhereUniqueWithoutDirectorsInput {
  data: MovieUpdateWithoutDirectorsInput!
  where: MovieWhereUniqueInput!
}

input MovieUpdateWithWhereUniqueWithoutGenresInput {
  data: MovieUpdateWithoutGenresInput!
  where: MovieWhereUniqueInput!
}

input MovieUpdateWithWhereUniqueWithoutLanguagesInput {
  data: MovieUpdateWithoutLanguagesInput!
  where: MovieWhereUniqueInput!
}

input MovieUpdateWithoutActorsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  directors: DirectorUpdateManyWithoutMoviesInput
  genres: GenreUpdateManyWithoutMoviesInput
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  languages: LanguageUpdateManyWithoutMoviesInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  rating: StringFieldUpdateOperationsInput
  release: DateTimeFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  watchlist: WatchlistedMovieUpdateManyWithoutMovieInput
  year: IntFieldUpdateOperationsInput
}

input MovieUpdateWithoutDirectorsInput {
  actors: ActorUpdateManyWithoutMoviesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  genres: GenreUpdateManyWithoutMoviesInput
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  languages: LanguageUpdateManyWithoutMoviesInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  rating: StringFieldUpdateOperationsInput
  release: DateTimeFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  watchlist: WatchlistedMovieUpdateManyWithoutMovieInput
  year: IntFieldUpdateOperationsInput
}

input MovieUpdateWithoutGenresInput {
  actors: ActorUpdateManyWithoutMoviesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  directors: DirectorUpdateManyWithoutMoviesInput
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  languages: LanguageUpdateManyWithoutMoviesInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  rating: StringFieldUpdateOperationsInput
  release: DateTimeFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  watchlist: WatchlistedMovieUpdateManyWithoutMovieInput
  year: IntFieldUpdateOperationsInput
}

input MovieUpdateWithoutLanguagesInput {
  actors: ActorUpdateManyWithoutMoviesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  directors: DirectorUpdateManyWithoutMoviesInput
  genres: GenreUpdateManyWithoutMoviesInput
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  rating: StringFieldUpdateOperationsInput
  release: DateTimeFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  watchlist: WatchlistedMovieUpdateManyWithoutMovieInput
  year: IntFieldUpdateOperationsInput
}

input MovieUpdateWithoutWatchlistInput {
  actors: ActorUpdateManyWithoutMoviesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  directors: DirectorUpdateManyWithoutMoviesInput
  genres: GenreUpdateManyWithoutMoviesInput
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  languages: LanguageUpdateManyWithoutMoviesInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  rating: StringFieldUpdateOperationsInput
  release: DateTimeFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  year: IntFieldUpdateOperationsInput
}

input MovieUpsertWithWhereUniqueWithoutActorsInput {
  create: MovieCreateWithoutActorsInput!
  update: MovieUpdateWithoutActorsInput!
  where: MovieWhereUniqueInput!
}

input MovieUpsertWithWhereUniqueWithoutDirectorsInput {
  create: MovieCreateWithoutDirectorsInput!
  update: MovieUpdateWithoutDirectorsInput!
  where: MovieWhereUniqueInput!
}

input MovieUpsertWithWhereUniqueWithoutGenresInput {
  create: MovieCreateWithoutGenresInput!
  update: MovieUpdateWithoutGenresInput!
  where: MovieWhereUniqueInput!
}

input MovieUpsertWithWhereUniqueWithoutLanguagesInput {
  create: MovieCreateWithoutLanguagesInput!
  update: MovieUpdateWithoutLanguagesInput!
  where: MovieWhereUniqueInput!
}

input MovieUpsertWithoutWatchlistInput {
  create: MovieCreateWithoutWatchlistInput!
  update: MovieUpdateWithoutWatchlistInput!
}

input MovieWhereInput {
  AND: [MovieWhereInput!]
  NOT: [MovieWhereInput!]
  OR: [MovieWhereInput!]
  actors: ActorListRelationFilter
  createdAt: DateTimeFilter
  directors: DirectorListRelationFilter
  genres: GenreListRelationFilter
  id: IntFilter
  imdbID: StringFilter
  imdbRating: FloatFilter
  languages: LanguageListRelationFilter
  plot: StringFilter
  poster: StringFilter
  rating: StringFilter
  release: DateTimeFilter
  runtime: IntFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  watchlist: WatchlistedMovieListRelationFilter
  year: IntFilter
}

input MovieWhereUniqueInput {
  id: Int
  imdbID: String
}

type MoviesWatchlist {
  _count: MoviesWatchlistCount
  id: Int!
  movies(cursor: WatchlistedMovieWhereUniqueInput, distinct: [WatchlistedMovieScalarFieldEnum!], orderBy: [WatchlistedMovieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: WatchlistedMovieWhereInput): [WatchlistedMovie!]!
  watchlist: Watchlist!
  watchlistId: Int!
}

type MoviesWatchlistAvgAggregate {
  id: Float
  watchlistId: Float
}

input MoviesWatchlistAvgOrderByAggregateInput {
  id: SortOrder
  watchlistId: SortOrder
}

type MoviesWatchlistCount {
  movies: Int!
}

type MoviesWatchlistCountAggregate {
  _all: Int!
  id: Int!
  watchlistId: Int!
}

input MoviesWatchlistCountOrderByAggregateInput {
  id: SortOrder
  watchlistId: SortOrder
}

input MoviesWatchlistCreateInput {
  id: Int!
  movies: WatchlistedMovieCreateNestedManyWithoutWatchlistInput
  watchlist: WatchlistCreateNestedOneWithoutMovieWatchlistInput!
}

input MoviesWatchlistCreateManyInput {
  id: Int!
  watchlistId: Int!
}

input MoviesWatchlistCreateNestedOneWithoutMoviesInput {
  connect: MoviesWatchlistWhereUniqueInput
  connectOrCreate: MoviesWatchlistCreateOrConnectWithoutMoviesInput
  create: MoviesWatchlistCreateWithoutMoviesInput
}

input MoviesWatchlistCreateNestedOneWithoutWatchlistInput {
  connect: MoviesWatchlistWhereUniqueInput
  connectOrCreate: MoviesWatchlistCreateOrConnectWithoutWatchlistInput
  create: MoviesWatchlistCreateWithoutWatchlistInput
}

input MoviesWatchlistCreateOrConnectWithoutMoviesInput {
  create: MoviesWatchlistCreateWithoutMoviesInput!
  where: MoviesWatchlistWhereUniqueInput!
}

input MoviesWatchlistCreateOrConnectWithoutWatchlistInput {
  create: MoviesWatchlistCreateWithoutWatchlistInput!
  where: MoviesWatchlistWhereUniqueInput!
}

input MoviesWatchlistCreateWithoutMoviesInput {
  id: Int!
  watchlist: WatchlistCreateNestedOneWithoutMovieWatchlistInput!
}

input MoviesWatchlistCreateWithoutWatchlistInput {
  id: Int!
  movies: WatchlistedMovieCreateNestedManyWithoutWatchlistInput
}

type MoviesWatchlistGroupBy {
  _avg: MoviesWatchlistAvgAggregate
  _count: MoviesWatchlistCountAggregate
  _max: MoviesWatchlistMaxAggregate
  _min: MoviesWatchlistMinAggregate
  _sum: MoviesWatchlistSumAggregate
  id: Int!
  watchlistId: Int!
}

type MoviesWatchlistMaxAggregate {
  id: Int
  watchlistId: Int
}

input MoviesWatchlistMaxOrderByAggregateInput {
  id: SortOrder
  watchlistId: SortOrder
}

type MoviesWatchlistMinAggregate {
  id: Int
  watchlistId: Int
}

input MoviesWatchlistMinOrderByAggregateInput {
  id: SortOrder
  watchlistId: SortOrder
}

input MoviesWatchlistOrderByWithAggregationInput {
  _avg: MoviesWatchlistAvgOrderByAggregateInput
  _count: MoviesWatchlistCountOrderByAggregateInput
  _max: MoviesWatchlistMaxOrderByAggregateInput
  _min: MoviesWatchlistMinOrderByAggregateInput
  _sum: MoviesWatchlistSumOrderByAggregateInput
  id: SortOrder
  watchlistId: SortOrder
}

input MoviesWatchlistOrderByWithRelationAndSearchRelevanceInput {
  id: SortOrder
  movies: WatchlistedMovieOrderByRelationAggregateInput
  watchlist: WatchlistOrderByWithRelationAndSearchRelevanceInput
  watchlistId: SortOrder
}

input MoviesWatchlistRelationFilter {
  is: MoviesWatchlistWhereInput
  isNot: MoviesWatchlistWhereInput
}

enum MoviesWatchlistScalarFieldEnum {
  id
  watchlistId
}

input MoviesWatchlistScalarWhereWithAggregatesInput {
  AND: [MoviesWatchlistScalarWhereWithAggregatesInput!]
  NOT: [MoviesWatchlistScalarWhereWithAggregatesInput!]
  OR: [MoviesWatchlistScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  watchlistId: IntWithAggregatesFilter
}

type MoviesWatchlistSumAggregate {
  id: Int
  watchlistId: Int
}

input MoviesWatchlistSumOrderByAggregateInput {
  id: SortOrder
  watchlistId: SortOrder
}

input MoviesWatchlistUpdateInput {
  id: IntFieldUpdateOperationsInput
  movies: WatchlistedMovieUpdateManyWithoutWatchlistInput
  watchlist: WatchlistUpdateOneRequiredWithoutMovieWatchlistInput
}

input MoviesWatchlistUpdateManyMutationInput {
  id: IntFieldUpdateOperationsInput
}

input MoviesWatchlistUpdateOneRequiredWithoutMoviesInput {
  connect: MoviesWatchlistWhereUniqueInput
  connectOrCreate: MoviesWatchlistCreateOrConnectWithoutMoviesInput
  create: MoviesWatchlistCreateWithoutMoviesInput
  update: MoviesWatchlistUpdateWithoutMoviesInput
  upsert: MoviesWatchlistUpsertWithoutMoviesInput
}

input MoviesWatchlistUpdateOneWithoutWatchlistInput {
  connect: MoviesWatchlistWhereUniqueInput
  connectOrCreate: MoviesWatchlistCreateOrConnectWithoutWatchlistInput
  create: MoviesWatchlistCreateWithoutWatchlistInput
  delete: Boolean
  disconnect: Boolean
  update: MoviesWatchlistUpdateWithoutWatchlistInput
  upsert: MoviesWatchlistUpsertWithoutWatchlistInput
}

input MoviesWatchlistUpdateWithoutMoviesInput {
  id: IntFieldUpdateOperationsInput
  watchlist: WatchlistUpdateOneRequiredWithoutMovieWatchlistInput
}

input MoviesWatchlistUpdateWithoutWatchlistInput {
  id: IntFieldUpdateOperationsInput
  movies: WatchlistedMovieUpdateManyWithoutWatchlistInput
}

input MoviesWatchlistUpsertWithoutMoviesInput {
  create: MoviesWatchlistCreateWithoutMoviesInput!
  update: MoviesWatchlistUpdateWithoutMoviesInput!
}

input MoviesWatchlistUpsertWithoutWatchlistInput {
  create: MoviesWatchlistCreateWithoutWatchlistInput!
  update: MoviesWatchlistUpdateWithoutWatchlistInput!
}

input MoviesWatchlistWhereInput {
  AND: [MoviesWatchlistWhereInput!]
  NOT: [MoviesWatchlistWhereInput!]
  OR: [MoviesWatchlistWhereInput!]
  id: IntFilter
  movies: WatchlistedMovieListRelationFilter
  watchlist: WatchlistRelationFilter
  watchlistId: IntFilter
}

input MoviesWatchlistWhereUniqueInput {
  id: Int
  watchlistId: Int
}

type Mutation {
  createAccount(data: AccountCreateInput!): Account!
  createActor(data: ActorCreateInput!): Actor!
  createAppSettings(data: AppSettingsCreateInput!): AppSettings!
  createDirector(data: DirectorCreateInput!): Director!
  createEpisode(data: EpisodeCreateInput!): Episode!
  createEpisodesWatchlist(data: EpisodesWatchlistCreateInput!): EpisodesWatchlist!
  createGenre(data: GenreCreateInput!): Genre!
  createLanguage(data: LanguageCreateInput!): Language!
  createManyAccount(data: [AccountCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyActor(data: [ActorCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyAppSettings(data: [AppSettingsCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyDirector(data: [DirectorCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyEpisode(data: [EpisodeCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyEpisodesWatchlist(data: [EpisodesWatchlistCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyGenre(data: [GenreCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyLanguage(data: [LanguageCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyMovie(data: [MovieCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyMoviesWatchlist(data: [MoviesWatchlistCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManySeason(data: [SeasonCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManySerie(data: [SerieCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManySeriesWatchlist(data: [SeriesWatchlistCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManySession(data: [SessionCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyVerificationRequest(data: [VerificationRequestCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyWatchlist(data: [WatchlistCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyWatchlistedEpisode(data: [WatchlistedEpisodeCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyWatchlistedMovie(data: [WatchlistedMovieCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyWatchlistedSerie(data: [WatchlistedSerieCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createMovie(data: MovieCreateInput!): Movie!
  createMoviesWatchlist(data: MoviesWatchlistCreateInput!): MoviesWatchlist!
  createSeason(data: SeasonCreateInput!): Season!
  createSerie(data: SerieCreateInput!): Serie!
  createSeriesWatchlist(data: SeriesWatchlistCreateInput!): SeriesWatchlist!
  createSession(data: SessionCreateInput!): Session!
  createUser(data: UserCreateInput!): User!
  createVerificationRequest(data: VerificationRequestCreateInput!): VerificationRequest!
  createWatchlist(data: WatchlistCreateInput!): Watchlist!
  createWatchlistedEpisode(data: WatchlistedEpisodeCreateInput!): WatchlistedEpisode!
  createWatchlistedMovie(data: WatchlistedMovieCreateInput!): WatchlistedMovie!
  createWatchlistedSerie(data: WatchlistedSerieCreateInput!): WatchlistedSerie!
  deleteAccount(where: AccountWhereUniqueInput!): Account
  deleteActor(where: ActorWhereUniqueInput!): Actor
  deleteAppSettings(where: AppSettingsWhereUniqueInput!): AppSettings
  deleteDirector(where: DirectorWhereUniqueInput!): Director
  deleteEpisode(where: EpisodeWhereUniqueInput!): Episode
  deleteEpisodesWatchlist(where: EpisodesWatchlistWhereUniqueInput!): EpisodesWatchlist
  deleteGenre(where: GenreWhereUniqueInput!): Genre
  deleteLanguage(where: LanguageWhereUniqueInput!): Language
  deleteManyAccount(where: AccountWhereInput): AffectedRowsOutput!
  deleteManyActor(where: ActorWhereInput): AffectedRowsOutput!
  deleteManyAppSettings(where: AppSettingsWhereInput): AffectedRowsOutput!
  deleteManyDirector(where: DirectorWhereInput): AffectedRowsOutput!
  deleteManyEpisode(where: EpisodeWhereInput): AffectedRowsOutput!
  deleteManyEpisodesWatchlist(where: EpisodesWatchlistWhereInput): AffectedRowsOutput!
  deleteManyGenre(where: GenreWhereInput): AffectedRowsOutput!
  deleteManyLanguage(where: LanguageWhereInput): AffectedRowsOutput!
  deleteManyMovie(where: MovieWhereInput): AffectedRowsOutput!
  deleteManyMoviesWatchlist(where: MoviesWatchlistWhereInput): AffectedRowsOutput!
  deleteManySeason(where: SeasonWhereInput): AffectedRowsOutput!
  deleteManySerie(where: SerieWhereInput): AffectedRowsOutput!
  deleteManySeriesWatchlist(where: SeriesWatchlistWhereInput): AffectedRowsOutput!
  deleteManySession(where: SessionWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteManyVerificationRequest(where: VerificationRequestWhereInput): AffectedRowsOutput!
  deleteManyWatchlist(where: WatchlistWhereInput): AffectedRowsOutput!
  deleteManyWatchlistedEpisode(where: WatchlistedEpisodeWhereInput): AffectedRowsOutput!
  deleteManyWatchlistedMovie(where: WatchlistedMovieWhereInput): AffectedRowsOutput!
  deleteManyWatchlistedSerie(where: WatchlistedSerieWhereInput): AffectedRowsOutput!
  deleteMovie(where: MovieWhereUniqueInput!): Movie
  deleteMoviesWatchlist(where: MoviesWatchlistWhereUniqueInput!): MoviesWatchlist
  deleteSeason(where: SeasonWhereUniqueInput!): Season
  deleteSerie(where: SerieWhereUniqueInput!): Serie
  deleteSeriesWatchlist(where: SeriesWatchlistWhereUniqueInput!): SeriesWatchlist
  deleteSession(where: SessionWhereUniqueInput!): Session
  deleteUser(where: UserWhereUniqueInput!): User
  deleteVerificationRequest(where: VerificationRequestWhereUniqueInput!): VerificationRequest
  deleteWatchlist(where: WatchlistWhereUniqueInput!): Watchlist
  deleteWatchlistedEpisode(where: WatchlistedEpisodeWhereUniqueInput!): WatchlistedEpisode
  deleteWatchlistedMovie(where: WatchlistedMovieWhereUniqueInput!): WatchlistedMovie
  deleteWatchlistedSerie(where: WatchlistedSerieWhereUniqueInput!): WatchlistedSerie
  updateAccount(data: AccountUpdateInput!, where: AccountWhereUniqueInput!): Account
  updateActor(data: ActorUpdateInput!, where: ActorWhereUniqueInput!): Actor
  updateAppSettings(data: AppSettingsUpdateInput!, where: AppSettingsWhereUniqueInput!): AppSettings
  updateDirector(data: DirectorUpdateInput!, where: DirectorWhereUniqueInput!): Director
  updateEpisode(data: EpisodeUpdateInput!, where: EpisodeWhereUniqueInput!): Episode
  updateEpisodesWatchlist(data: EpisodesWatchlistUpdateInput!, where: EpisodesWatchlistWhereUniqueInput!): EpisodesWatchlist
  updateGenre(data: GenreUpdateInput!, where: GenreWhereUniqueInput!): Genre
  updateLanguage(data: LanguageUpdateInput!, where: LanguageWhereUniqueInput!): Language
  updateManyAccount(data: AccountUpdateManyMutationInput!, where: AccountWhereInput): AffectedRowsOutput!
  updateManyActor(data: ActorUpdateManyMutationInput!, where: ActorWhereInput): AffectedRowsOutput!
  updateManyAppSettings(data: AppSettingsUpdateManyMutationInput!, where: AppSettingsWhereInput): AffectedRowsOutput!
  updateManyDirector(data: DirectorUpdateManyMutationInput!, where: DirectorWhereInput): AffectedRowsOutput!
  updateManyEpisode(data: EpisodeUpdateManyMutationInput!, where: EpisodeWhereInput): AffectedRowsOutput!
  updateManyEpisodesWatchlist(data: EpisodesWatchlistUpdateManyMutationInput!, where: EpisodesWatchlistWhereInput): AffectedRowsOutput!
  updateManyGenre(data: GenreUpdateManyMutationInput!, where: GenreWhereInput): AffectedRowsOutput!
  updateManyLanguage(data: LanguageUpdateManyMutationInput!, where: LanguageWhereInput): AffectedRowsOutput!
  updateManyMovie(data: MovieUpdateManyMutationInput!, where: MovieWhereInput): AffectedRowsOutput!
  updateManyMoviesWatchlist(data: MoviesWatchlistUpdateManyMutationInput!, where: MoviesWatchlistWhereInput): AffectedRowsOutput!
  updateManySeason(data: SeasonUpdateManyMutationInput!, where: SeasonWhereInput): AffectedRowsOutput!
  updateManySerie(data: SerieUpdateManyMutationInput!, where: SerieWhereInput): AffectedRowsOutput!
  updateManySeriesWatchlist(data: SeriesWatchlistUpdateManyMutationInput!, where: SeriesWatchlistWhereInput): AffectedRowsOutput!
  updateManySession(data: SessionUpdateManyMutationInput!, where: SessionWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateManyVerificationRequest(data: VerificationRequestUpdateManyMutationInput!, where: VerificationRequestWhereInput): AffectedRowsOutput!
  updateManyWatchlist(data: WatchlistUpdateManyMutationInput!, where: WatchlistWhereInput): AffectedRowsOutput!
  updateManyWatchlistedEpisode(data: WatchlistedEpisodeUpdateManyMutationInput!, where: WatchlistedEpisodeWhereInput): AffectedRowsOutput!
  updateManyWatchlistedMovie(data: WatchlistedMovieUpdateManyMutationInput!, where: WatchlistedMovieWhereInput): AffectedRowsOutput!
  updateManyWatchlistedSerie(data: WatchlistedSerieUpdateManyMutationInput!, where: WatchlistedSerieWhereInput): AffectedRowsOutput!
  updateMovie(data: MovieUpdateInput!, where: MovieWhereUniqueInput!): Movie
  updateMoviesWatchlist(data: MoviesWatchlistUpdateInput!, where: MoviesWatchlistWhereUniqueInput!): MoviesWatchlist
  updateSeason(data: SeasonUpdateInput!, where: SeasonWhereUniqueInput!): Season
  updateSerie(data: SerieUpdateInput!, where: SerieWhereUniqueInput!): Serie
  updateSeriesWatchlist(data: SeriesWatchlistUpdateInput!, where: SeriesWatchlistWhereUniqueInput!): SeriesWatchlist
  updateSession(data: SessionUpdateInput!, where: SessionWhereUniqueInput!): Session
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateVerificationRequest(data: VerificationRequestUpdateInput!, where: VerificationRequestWhereUniqueInput!): VerificationRequest
  updateWatchlist(data: WatchlistUpdateInput!, where: WatchlistWhereUniqueInput!): Watchlist
  updateWatchlistedEpisode(data: WatchlistedEpisodeUpdateInput!, where: WatchlistedEpisodeWhereUniqueInput!): WatchlistedEpisode
  updateWatchlistedMovie(data: WatchlistedMovieUpdateInput!, where: WatchlistedMovieWhereUniqueInput!): WatchlistedMovie
  updateWatchlistedSerie(data: WatchlistedSerieUpdateInput!, where: WatchlistedSerieWhereUniqueInput!): WatchlistedSerie
  upsertAccount(create: AccountCreateInput!, update: AccountUpdateInput!, where: AccountWhereUniqueInput!): Account!
  upsertActor(create: ActorCreateInput!, update: ActorUpdateInput!, where: ActorWhereUniqueInput!): Actor!
  upsertAppSettings(create: AppSettingsCreateInput!, update: AppSettingsUpdateInput!, where: AppSettingsWhereUniqueInput!): AppSettings!
  upsertDirector(create: DirectorCreateInput!, update: DirectorUpdateInput!, where: DirectorWhereUniqueInput!): Director!
  upsertEpisode(create: EpisodeCreateInput!, update: EpisodeUpdateInput!, where: EpisodeWhereUniqueInput!): Episode!
  upsertEpisodesWatchlist(create: EpisodesWatchlistCreateInput!, update: EpisodesWatchlistUpdateInput!, where: EpisodesWatchlistWhereUniqueInput!): EpisodesWatchlist!
  upsertGenre(create: GenreCreateInput!, update: GenreUpdateInput!, where: GenreWhereUniqueInput!): Genre!
  upsertLanguage(create: LanguageCreateInput!, update: LanguageUpdateInput!, where: LanguageWhereUniqueInput!): Language!
  upsertMovie(create: MovieCreateInput!, update: MovieUpdateInput!, where: MovieWhereUniqueInput!): Movie!
  upsertMoviesWatchlist(create: MoviesWatchlistCreateInput!, update: MoviesWatchlistUpdateInput!, where: MoviesWatchlistWhereUniqueInput!): MoviesWatchlist!
  upsertSeason(create: SeasonCreateInput!, update: SeasonUpdateInput!, where: SeasonWhereUniqueInput!): Season!
  upsertSerie(create: SerieCreateInput!, update: SerieUpdateInput!, where: SerieWhereUniqueInput!): Serie!
  upsertSeriesWatchlist(create: SeriesWatchlistCreateInput!, update: SeriesWatchlistUpdateInput!, where: SeriesWatchlistWhereUniqueInput!): SeriesWatchlist!
  upsertSession(create: SessionCreateInput!, update: SessionUpdateInput!, where: SessionWhereUniqueInput!): Session!
  upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
  upsertVerificationRequest(create: VerificationRequestCreateInput!, update: VerificationRequestUpdateInput!, where: VerificationRequestWhereUniqueInput!): VerificationRequest!
  upsertWatchlist(create: WatchlistCreateInput!, update: WatchlistUpdateInput!, where: WatchlistWhereUniqueInput!): Watchlist!
  upsertWatchlistedEpisode(create: WatchlistedEpisodeCreateInput!, update: WatchlistedEpisodeUpdateInput!, where: WatchlistedEpisodeWhereUniqueInput!): WatchlistedEpisode!
  upsertWatchlistedMovie(create: WatchlistedMovieCreateInput!, update: WatchlistedMovieUpdateInput!, where: WatchlistedMovieWhereUniqueInput!): WatchlistedMovie!
  upsertWatchlistedSerie(create: WatchlistedSerieCreateInput!, update: WatchlistedSerieUpdateInput!, where: WatchlistedSerieWhereUniqueInput!): WatchlistedSerie!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedEnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input NestedEnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedFloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input NullableIntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  account(where: AccountWhereUniqueInput!): Account
  accounts(cursor: AccountWhereUniqueInput, distinct: [AccountScalarFieldEnum!], orderBy: [AccountOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: AccountWhereInput): [Account!]!
  actor(where: ActorWhereUniqueInput!): Actor
  actors(cursor: ActorWhereUniqueInput, distinct: [ActorScalarFieldEnum!], orderBy: [ActorOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: ActorWhereInput): [Actor!]!
  aggregateAccount(cursor: AccountWhereUniqueInput, orderBy: [AccountOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: AccountWhereInput): AggregateAccount!
  aggregateActor(cursor: ActorWhereUniqueInput, orderBy: [ActorOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: ActorWhereInput): AggregateActor!
  aggregateAppSettings(cursor: AppSettingsWhereUniqueInput, orderBy: [AppSettingsOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: AppSettingsWhereInput): AggregateAppSettings!
  aggregateDirector(cursor: DirectorWhereUniqueInput, orderBy: [DirectorOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: DirectorWhereInput): AggregateDirector!
  aggregateEpisode(cursor: EpisodeWhereUniqueInput, orderBy: [EpisodeOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: EpisodeWhereInput): AggregateEpisode!
  aggregateEpisodesWatchlist(cursor: EpisodesWatchlistWhereUniqueInput, orderBy: [EpisodesWatchlistOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: EpisodesWatchlistWhereInput): AggregateEpisodesWatchlist!
  aggregateGenre(cursor: GenreWhereUniqueInput, orderBy: [GenreOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: GenreWhereInput): AggregateGenre!
  aggregateLanguage(cursor: LanguageWhereUniqueInput, orderBy: [LanguageOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: LanguageWhereInput): AggregateLanguage!
  aggregateMovie(cursor: MovieWhereUniqueInput, orderBy: [MovieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: MovieWhereInput): AggregateMovie!
  aggregateMoviesWatchlist(cursor: MoviesWatchlistWhereUniqueInput, orderBy: [MoviesWatchlistOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: MoviesWatchlistWhereInput): AggregateMoviesWatchlist!
  aggregateSeason(cursor: SeasonWhereUniqueInput, orderBy: [SeasonOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: SeasonWhereInput): AggregateSeason!
  aggregateSerie(cursor: SerieWhereUniqueInput, orderBy: [SerieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: SerieWhereInput): AggregateSerie!
  aggregateSeriesWatchlist(cursor: SeriesWatchlistWhereUniqueInput, orderBy: [SeriesWatchlistOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: SeriesWatchlistWhereInput): AggregateSeriesWatchlist!
  aggregateSession(cursor: SessionWhereUniqueInput, orderBy: [SessionOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: SessionWhereInput): AggregateSession!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  aggregateVerificationRequest(cursor: VerificationRequestWhereUniqueInput, orderBy: [VerificationRequestOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: VerificationRequestWhereInput): AggregateVerificationRequest!
  aggregateWatchlist(cursor: WatchlistWhereUniqueInput, orderBy: [WatchlistOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: WatchlistWhereInput): AggregateWatchlist!
  aggregateWatchlistedEpisode(cursor: WatchlistedEpisodeWhereUniqueInput, orderBy: [WatchlistedEpisodeOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: WatchlistedEpisodeWhereInput): AggregateWatchlistedEpisode!
  aggregateWatchlistedMovie(cursor: WatchlistedMovieWhereUniqueInput, orderBy: [WatchlistedMovieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: WatchlistedMovieWhereInput): AggregateWatchlistedMovie!
  aggregateWatchlistedSerie(cursor: WatchlistedSerieWhereUniqueInput, orderBy: [WatchlistedSerieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: WatchlistedSerieWhereInput): AggregateWatchlistedSerie!
  director(where: DirectorWhereUniqueInput!): Director
  directors(cursor: DirectorWhereUniqueInput, distinct: [DirectorScalarFieldEnum!], orderBy: [DirectorOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: DirectorWhereInput): [Director!]!
  episode(where: EpisodeWhereUniqueInput!): Episode
  episodes(cursor: EpisodeWhereUniqueInput, distinct: [EpisodeScalarFieldEnum!], orderBy: [EpisodeOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: EpisodeWhereInput): [Episode!]!
  episodesWatchlist(where: EpisodesWatchlistWhereUniqueInput!): EpisodesWatchlist
  episodesWatchlists(cursor: EpisodesWatchlistWhereUniqueInput, distinct: [EpisodesWatchlistScalarFieldEnum!], orderBy: [EpisodesWatchlistOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: EpisodesWatchlistWhereInput): [EpisodesWatchlist!]!
  findFirstAccount(cursor: AccountWhereUniqueInput, distinct: [AccountScalarFieldEnum!], orderBy: [AccountOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: AccountWhereInput): Account
  findFirstActor(cursor: ActorWhereUniqueInput, distinct: [ActorScalarFieldEnum!], orderBy: [ActorOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: ActorWhereInput): Actor
  findFirstAppSettings(cursor: AppSettingsWhereUniqueInput, distinct: [AppSettingsScalarFieldEnum!], orderBy: [AppSettingsOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: AppSettingsWhereInput): AppSettings
  findFirstDirector(cursor: DirectorWhereUniqueInput, distinct: [DirectorScalarFieldEnum!], orderBy: [DirectorOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: DirectorWhereInput): Director
  findFirstEpisode(cursor: EpisodeWhereUniqueInput, distinct: [EpisodeScalarFieldEnum!], orderBy: [EpisodeOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: EpisodeWhereInput): Episode
  findFirstEpisodesWatchlist(cursor: EpisodesWatchlistWhereUniqueInput, distinct: [EpisodesWatchlistScalarFieldEnum!], orderBy: [EpisodesWatchlistOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: EpisodesWatchlistWhereInput): EpisodesWatchlist
  findFirstGenre(cursor: GenreWhereUniqueInput, distinct: [GenreScalarFieldEnum!], orderBy: [GenreOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: GenreWhereInput): Genre
  findFirstLanguage(cursor: LanguageWhereUniqueInput, distinct: [LanguageScalarFieldEnum!], orderBy: [LanguageOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: LanguageWhereInput): Language
  findFirstMovie(cursor: MovieWhereUniqueInput, distinct: [MovieScalarFieldEnum!], orderBy: [MovieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: MovieWhereInput): Movie
  findFirstMoviesWatchlist(cursor: MoviesWatchlistWhereUniqueInput, distinct: [MoviesWatchlistScalarFieldEnum!], orderBy: [MoviesWatchlistOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: MoviesWatchlistWhereInput): MoviesWatchlist
  findFirstSeason(cursor: SeasonWhereUniqueInput, distinct: [SeasonScalarFieldEnum!], orderBy: [SeasonOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: SeasonWhereInput): Season
  findFirstSerie(cursor: SerieWhereUniqueInput, distinct: [SerieScalarFieldEnum!], orderBy: [SerieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: SerieWhereInput): Serie
  findFirstSeriesWatchlist(cursor: SeriesWatchlistWhereUniqueInput, distinct: [SeriesWatchlistScalarFieldEnum!], orderBy: [SeriesWatchlistOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: SeriesWatchlistWhereInput): SeriesWatchlist
  findFirstSession(cursor: SessionWhereUniqueInput, distinct: [SessionScalarFieldEnum!], orderBy: [SessionOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: SessionWhereInput): Session
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: UserWhereInput): User
  findFirstVerificationRequest(cursor: VerificationRequestWhereUniqueInput, distinct: [VerificationRequestScalarFieldEnum!], orderBy: [VerificationRequestOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: VerificationRequestWhereInput): VerificationRequest
  findFirstWatchlist(cursor: WatchlistWhereUniqueInput, distinct: [WatchlistScalarFieldEnum!], orderBy: [WatchlistOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: WatchlistWhereInput): Watchlist
  findFirstWatchlistedEpisode(cursor: WatchlistedEpisodeWhereUniqueInput, distinct: [WatchlistedEpisodeScalarFieldEnum!], orderBy: [WatchlistedEpisodeOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: WatchlistedEpisodeWhereInput): WatchlistedEpisode
  findFirstWatchlistedMovie(cursor: WatchlistedMovieWhereUniqueInput, distinct: [WatchlistedMovieScalarFieldEnum!], orderBy: [WatchlistedMovieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: WatchlistedMovieWhereInput): WatchlistedMovie
  findFirstWatchlistedSerie(cursor: WatchlistedSerieWhereUniqueInput, distinct: [WatchlistedSerieScalarFieldEnum!], orderBy: [WatchlistedSerieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: WatchlistedSerieWhereInput): WatchlistedSerie
  findManyAppSettings(cursor: AppSettingsWhereUniqueInput, distinct: [AppSettingsScalarFieldEnum!], orderBy: [AppSettingsOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: AppSettingsWhereInput): [AppSettings!]!
  findUniqueAppSettings(where: AppSettingsWhereUniqueInput!): AppSettings
  genre(where: GenreWhereUniqueInput!): Genre
  genres(cursor: GenreWhereUniqueInput, distinct: [GenreScalarFieldEnum!], orderBy: [GenreOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: GenreWhereInput): [Genre!]!
  groupByAccount(by: [AccountScalarFieldEnum!]!, having: AccountScalarWhereWithAggregatesInput, orderBy: [AccountOrderByWithAggregationInput!], skip: Int, take: Int, where: AccountWhereInput): [AccountGroupBy!]!
  groupByActor(by: [ActorScalarFieldEnum!]!, having: ActorScalarWhereWithAggregatesInput, orderBy: [ActorOrderByWithAggregationInput!], skip: Int, take: Int, where: ActorWhereInput): [ActorGroupBy!]!
  groupByAppSettings(by: [AppSettingsScalarFieldEnum!]!, having: AppSettingsScalarWhereWithAggregatesInput, orderBy: [AppSettingsOrderByWithAggregationInput!], skip: Int, take: Int, where: AppSettingsWhereInput): [AppSettingsGroupBy!]!
  groupByDirector(by: [DirectorScalarFieldEnum!]!, having: DirectorScalarWhereWithAggregatesInput, orderBy: [DirectorOrderByWithAggregationInput!], skip: Int, take: Int, where: DirectorWhereInput): [DirectorGroupBy!]!
  groupByEpisode(by: [EpisodeScalarFieldEnum!]!, having: EpisodeScalarWhereWithAggregatesInput, orderBy: [EpisodeOrderByWithAggregationInput!], skip: Int, take: Int, where: EpisodeWhereInput): [EpisodeGroupBy!]!
  groupByEpisodesWatchlist(by: [EpisodesWatchlistScalarFieldEnum!]!, having: EpisodesWatchlistScalarWhereWithAggregatesInput, orderBy: [EpisodesWatchlistOrderByWithAggregationInput!], skip: Int, take: Int, where: EpisodesWatchlistWhereInput): [EpisodesWatchlistGroupBy!]!
  groupByGenre(by: [GenreScalarFieldEnum!]!, having: GenreScalarWhereWithAggregatesInput, orderBy: [GenreOrderByWithAggregationInput!], skip: Int, take: Int, where: GenreWhereInput): [GenreGroupBy!]!
  groupByLanguage(by: [LanguageScalarFieldEnum!]!, having: LanguageScalarWhereWithAggregatesInput, orderBy: [LanguageOrderByWithAggregationInput!], skip: Int, take: Int, where: LanguageWhereInput): [LanguageGroupBy!]!
  groupByMovie(by: [MovieScalarFieldEnum!]!, having: MovieScalarWhereWithAggregatesInput, orderBy: [MovieOrderByWithAggregationInput!], skip: Int, take: Int, where: MovieWhereInput): [MovieGroupBy!]!
  groupByMoviesWatchlist(by: [MoviesWatchlistScalarFieldEnum!]!, having: MoviesWatchlistScalarWhereWithAggregatesInput, orderBy: [MoviesWatchlistOrderByWithAggregationInput!], skip: Int, take: Int, where: MoviesWatchlistWhereInput): [MoviesWatchlistGroupBy!]!
  groupBySeason(by: [SeasonScalarFieldEnum!]!, having: SeasonScalarWhereWithAggregatesInput, orderBy: [SeasonOrderByWithAggregationInput!], skip: Int, take: Int, where: SeasonWhereInput): [SeasonGroupBy!]!
  groupBySerie(by: [SerieScalarFieldEnum!]!, having: SerieScalarWhereWithAggregatesInput, orderBy: [SerieOrderByWithAggregationInput!], skip: Int, take: Int, where: SerieWhereInput): [SerieGroupBy!]!
  groupBySeriesWatchlist(by: [SeriesWatchlistScalarFieldEnum!]!, having: SeriesWatchlistScalarWhereWithAggregatesInput, orderBy: [SeriesWatchlistOrderByWithAggregationInput!], skip: Int, take: Int, where: SeriesWatchlistWhereInput): [SeriesWatchlistGroupBy!]!
  groupBySession(by: [SessionScalarFieldEnum!]!, having: SessionScalarWhereWithAggregatesInput, orderBy: [SessionOrderByWithAggregationInput!], skip: Int, take: Int, where: SessionWhereInput): [SessionGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  groupByVerificationRequest(by: [VerificationRequestScalarFieldEnum!]!, having: VerificationRequestScalarWhereWithAggregatesInput, orderBy: [VerificationRequestOrderByWithAggregationInput!], skip: Int, take: Int, where: VerificationRequestWhereInput): [VerificationRequestGroupBy!]!
  groupByWatchlist(by: [WatchlistScalarFieldEnum!]!, having: WatchlistScalarWhereWithAggregatesInput, orderBy: [WatchlistOrderByWithAggregationInput!], skip: Int, take: Int, where: WatchlistWhereInput): [WatchlistGroupBy!]!
  groupByWatchlistedEpisode(by: [WatchlistedEpisodeScalarFieldEnum!]!, having: WatchlistedEpisodeScalarWhereWithAggregatesInput, orderBy: [WatchlistedEpisodeOrderByWithAggregationInput!], skip: Int, take: Int, where: WatchlistedEpisodeWhereInput): [WatchlistedEpisodeGroupBy!]!
  groupByWatchlistedMovie(by: [WatchlistedMovieScalarFieldEnum!]!, having: WatchlistedMovieScalarWhereWithAggregatesInput, orderBy: [WatchlistedMovieOrderByWithAggregationInput!], skip: Int, take: Int, where: WatchlistedMovieWhereInput): [WatchlistedMovieGroupBy!]!
  groupByWatchlistedSerie(by: [WatchlistedSerieScalarFieldEnum!]!, having: WatchlistedSerieScalarWhereWithAggregatesInput, orderBy: [WatchlistedSerieOrderByWithAggregationInput!], skip: Int, take: Int, where: WatchlistedSerieWhereInput): [WatchlistedSerieGroupBy!]!
  language(where: LanguageWhereUniqueInput!): Language
  languages(cursor: LanguageWhereUniqueInput, distinct: [LanguageScalarFieldEnum!], orderBy: [LanguageOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: LanguageWhereInput): [Language!]!
  movie(where: MovieWhereUniqueInput!): Movie
  movies(cursor: MovieWhereUniqueInput, distinct: [MovieScalarFieldEnum!], orderBy: [MovieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: MovieWhereInput): [Movie!]!
  moviesWatchlist(where: MoviesWatchlistWhereUniqueInput!): MoviesWatchlist
  moviesWatchlists(cursor: MoviesWatchlistWhereUniqueInput, distinct: [MoviesWatchlistScalarFieldEnum!], orderBy: [MoviesWatchlistOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: MoviesWatchlistWhereInput): [MoviesWatchlist!]!
  season(where: SeasonWhereUniqueInput!): Season
  seasons(cursor: SeasonWhereUniqueInput, distinct: [SeasonScalarFieldEnum!], orderBy: [SeasonOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: SeasonWhereInput): [Season!]!
  serie(where: SerieWhereUniqueInput!): Serie
  series(cursor: SerieWhereUniqueInput, distinct: [SerieScalarFieldEnum!], orderBy: [SerieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: SerieWhereInput): [Serie!]!
  seriesWatchlist(where: SeriesWatchlistWhereUniqueInput!): SeriesWatchlist
  seriesWatchlists(cursor: SeriesWatchlistWhereUniqueInput, distinct: [SeriesWatchlistScalarFieldEnum!], orderBy: [SeriesWatchlistOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: SeriesWatchlistWhereInput): [SeriesWatchlist!]!
  session(where: SessionWhereUniqueInput!): Session
  sessions(cursor: SessionWhereUniqueInput, distinct: [SessionScalarFieldEnum!], orderBy: [SessionOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: SessionWhereInput): [Session!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
  verificationRequest(where: VerificationRequestWhereUniqueInput!): VerificationRequest
  verificationRequests(cursor: VerificationRequestWhereUniqueInput, distinct: [VerificationRequestScalarFieldEnum!], orderBy: [VerificationRequestOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: VerificationRequestWhereInput): [VerificationRequest!]!
  watchlist(where: WatchlistWhereUniqueInput!): Watchlist
  watchlistedEpisode(where: WatchlistedEpisodeWhereUniqueInput!): WatchlistedEpisode
  watchlistedEpisodes(cursor: WatchlistedEpisodeWhereUniqueInput, distinct: [WatchlistedEpisodeScalarFieldEnum!], orderBy: [WatchlistedEpisodeOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: WatchlistedEpisodeWhereInput): [WatchlistedEpisode!]!
  watchlistedMovie(where: WatchlistedMovieWhereUniqueInput!): WatchlistedMovie
  watchlistedMovies(cursor: WatchlistedMovieWhereUniqueInput, distinct: [WatchlistedMovieScalarFieldEnum!], orderBy: [WatchlistedMovieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: WatchlistedMovieWhereInput): [WatchlistedMovie!]!
  watchlistedSerie(where: WatchlistedSerieWhereUniqueInput!): WatchlistedSerie
  watchlistedSeries(cursor: WatchlistedSerieWhereUniqueInput, distinct: [WatchlistedSerieScalarFieldEnum!], orderBy: [WatchlistedSerieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: WatchlistedSerieWhereInput): [WatchlistedSerie!]!
  watchlists(cursor: WatchlistWhereUniqueInput, distinct: [WatchlistScalarFieldEnum!], orderBy: [WatchlistOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: WatchlistWhereInput): [Watchlist!]!
}

enum QueryMode {
  default
  insensitive
}

enum Role {
  ADMIN
  USER
}

type Season {
  _count: SeasonCount
  createdAt: DateTime!
  episodeIds(cursor: EpisodeWhereUniqueInput, distinct: [EpisodeScalarFieldEnum!], orderBy: [EpisodeOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: EpisodeWhereInput): [Episode!]!
  episodes: Int!
  id: Int!
  index: Int!
  launchDate: DateTime!
  series: Serie!
  seriesId: Int!
  title: String!
  updatedAt: DateTime!
}

type SeasonAvgAggregate {
  episodes: Float
  id: Float
  index: Float
  seriesId: Float
}

input SeasonAvgOrderByAggregateInput {
  episodes: SortOrder
  id: SortOrder
  index: SortOrder
  seriesId: SortOrder
}

type SeasonCount {
  episodeIds: Int!
}

type SeasonCountAggregate {
  _all: Int!
  createdAt: Int!
  episodes: Int!
  id: Int!
  index: Int!
  launchDate: Int!
  seriesId: Int!
  title: Int!
  updatedAt: Int!
}

input SeasonCountOrderByAggregateInput {
  createdAt: SortOrder
  episodes: SortOrder
  id: SortOrder
  index: SortOrder
  launchDate: SortOrder
  seriesId: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input SeasonCreateInput {
  createdAt: DateTime
  episodeIds: EpisodeCreateNestedManyWithoutSeasonInput
  episodes: Int!
  index: Int!
  launchDate: DateTime
  series: SerieCreateNestedOneWithoutSeasonsInput!
  title: String!
  updatedAt: DateTime
}

input SeasonCreateManyInput {
  createdAt: DateTime
  episodes: Int!
  id: Int
  index: Int!
  launchDate: DateTime
  seriesId: Int!
  title: String!
  updatedAt: DateTime
}

input SeasonCreateManySeriesInput {
  createdAt: DateTime
  episodes: Int!
  id: Int
  index: Int!
  launchDate: DateTime
  title: String!
  updatedAt: DateTime
}

input SeasonCreateManySeriesInputEnvelope {
  data: [SeasonCreateManySeriesInput!]!
  skipDuplicates: Boolean
}

input SeasonCreateNestedManyWithoutSeriesInput {
  connect: [SeasonWhereUniqueInput!]
  connectOrCreate: [SeasonCreateOrConnectWithoutSeriesInput!]
  create: [SeasonCreateWithoutSeriesInput!]
  createMany: SeasonCreateManySeriesInputEnvelope
}

input SeasonCreateNestedOneWithoutEpisodeIdsInput {
  connect: SeasonWhereUniqueInput
  connectOrCreate: SeasonCreateOrConnectWithoutEpisodeIdsInput
  create: SeasonCreateWithoutEpisodeIdsInput
}

input SeasonCreateOrConnectWithoutEpisodeIdsInput {
  create: SeasonCreateWithoutEpisodeIdsInput!
  where: SeasonWhereUniqueInput!
}

input SeasonCreateOrConnectWithoutSeriesInput {
  create: SeasonCreateWithoutSeriesInput!
  where: SeasonWhereUniqueInput!
}

input SeasonCreateWithoutEpisodeIdsInput {
  createdAt: DateTime
  episodes: Int!
  index: Int!
  launchDate: DateTime
  series: SerieCreateNestedOneWithoutSeasonsInput!
  title: String!
  updatedAt: DateTime
}

input SeasonCreateWithoutSeriesInput {
  createdAt: DateTime
  episodeIds: EpisodeCreateNestedManyWithoutSeasonInput
  episodes: Int!
  index: Int!
  launchDate: DateTime
  title: String!
  updatedAt: DateTime
}

type SeasonGroupBy {
  _avg: SeasonAvgAggregate
  _count: SeasonCountAggregate
  _max: SeasonMaxAggregate
  _min: SeasonMinAggregate
  _sum: SeasonSumAggregate
  createdAt: DateTime!
  episodes: Int!
  id: Int!
  index: Int!
  launchDate: DateTime!
  seriesId: Int!
  title: String!
  updatedAt: DateTime!
}

input SeasonListRelationFilter {
  every: SeasonWhereInput
  none: SeasonWhereInput
  some: SeasonWhereInput
}

type SeasonMaxAggregate {
  createdAt: DateTime
  episodes: Int
  id: Int
  index: Int
  launchDate: DateTime
  seriesId: Int
  title: String
  updatedAt: DateTime
}

input SeasonMaxOrderByAggregateInput {
  createdAt: SortOrder
  episodes: SortOrder
  id: SortOrder
  index: SortOrder
  launchDate: SortOrder
  seriesId: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

type SeasonMinAggregate {
  createdAt: DateTime
  episodes: Int
  id: Int
  index: Int
  launchDate: DateTime
  seriesId: Int
  title: String
  updatedAt: DateTime
}

input SeasonMinOrderByAggregateInput {
  createdAt: SortOrder
  episodes: SortOrder
  id: SortOrder
  index: SortOrder
  launchDate: SortOrder
  seriesId: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input SeasonOrderByRelationAggregateInput {
  _count: SortOrder
}

enum SeasonOrderByRelevanceFieldEnum {
  title
}

input SeasonOrderByRelevanceInput {
  fields: [SeasonOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input SeasonOrderByWithAggregationInput {
  _avg: SeasonAvgOrderByAggregateInput
  _count: SeasonCountOrderByAggregateInput
  _max: SeasonMaxOrderByAggregateInput
  _min: SeasonMinOrderByAggregateInput
  _sum: SeasonSumOrderByAggregateInput
  createdAt: SortOrder
  episodes: SortOrder
  id: SortOrder
  index: SortOrder
  launchDate: SortOrder
  seriesId: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input SeasonOrderByWithRelationAndSearchRelevanceInput {
  _relevance: SeasonOrderByRelevanceInput
  createdAt: SortOrder
  episodeIds: EpisodeOrderByRelationAggregateInput
  episodes: SortOrder
  id: SortOrder
  index: SortOrder
  launchDate: SortOrder
  series: SerieOrderByWithRelationAndSearchRelevanceInput
  seriesId: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input SeasonRelationFilter {
  is: SeasonWhereInput
  isNot: SeasonWhereInput
}

enum SeasonScalarFieldEnum {
  createdAt
  episodes
  id
  index
  launchDate
  seriesId
  title
  updatedAt
}

input SeasonScalarWhereInput {
  AND: [SeasonScalarWhereInput!]
  NOT: [SeasonScalarWhereInput!]
  OR: [SeasonScalarWhereInput!]
  createdAt: DateTimeFilter
  episodes: IntFilter
  id: IntFilter
  index: IntFilter
  launchDate: DateTimeFilter
  seriesId: IntFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input SeasonScalarWhereWithAggregatesInput {
  AND: [SeasonScalarWhereWithAggregatesInput!]
  NOT: [SeasonScalarWhereWithAggregatesInput!]
  OR: [SeasonScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  episodes: IntWithAggregatesFilter
  id: IntWithAggregatesFilter
  index: IntWithAggregatesFilter
  launchDate: DateTimeWithAggregatesFilter
  seriesId: IntWithAggregatesFilter
  title: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

input SeasonSeriesIdIndexCompoundUniqueInput {
  index: Int!
  seriesId: Int!
}

type SeasonSumAggregate {
  episodes: Int
  id: Int
  index: Int
  seriesId: Int
}

input SeasonSumOrderByAggregateInput {
  episodes: SortOrder
  id: SortOrder
  index: SortOrder
  seriesId: SortOrder
}

input SeasonUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  episodeIds: EpisodeUpdateManyWithoutSeasonInput
  episodes: IntFieldUpdateOperationsInput
  index: IntFieldUpdateOperationsInput
  launchDate: DateTimeFieldUpdateOperationsInput
  series: SerieUpdateOneRequiredWithoutSeasonsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SeasonUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  episodes: IntFieldUpdateOperationsInput
  index: IntFieldUpdateOperationsInput
  launchDate: DateTimeFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SeasonUpdateManyWithWhereWithoutSeriesInput {
  data: SeasonUpdateManyMutationInput!
  where: SeasonScalarWhereInput!
}

input SeasonUpdateManyWithoutSeriesInput {
  connect: [SeasonWhereUniqueInput!]
  connectOrCreate: [SeasonCreateOrConnectWithoutSeriesInput!]
  create: [SeasonCreateWithoutSeriesInput!]
  createMany: SeasonCreateManySeriesInputEnvelope
  delete: [SeasonWhereUniqueInput!]
  deleteMany: [SeasonScalarWhereInput!]
  disconnect: [SeasonWhereUniqueInput!]
  set: [SeasonWhereUniqueInput!]
  update: [SeasonUpdateWithWhereUniqueWithoutSeriesInput!]
  updateMany: [SeasonUpdateManyWithWhereWithoutSeriesInput!]
  upsert: [SeasonUpsertWithWhereUniqueWithoutSeriesInput!]
}

input SeasonUpdateOneRequiredWithoutEpisodeIdsInput {
  connect: SeasonWhereUniqueInput
  connectOrCreate: SeasonCreateOrConnectWithoutEpisodeIdsInput
  create: SeasonCreateWithoutEpisodeIdsInput
  update: SeasonUpdateWithoutEpisodeIdsInput
  upsert: SeasonUpsertWithoutEpisodeIdsInput
}

input SeasonUpdateWithWhereUniqueWithoutSeriesInput {
  data: SeasonUpdateWithoutSeriesInput!
  where: SeasonWhereUniqueInput!
}

input SeasonUpdateWithoutEpisodeIdsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  episodes: IntFieldUpdateOperationsInput
  index: IntFieldUpdateOperationsInput
  launchDate: DateTimeFieldUpdateOperationsInput
  series: SerieUpdateOneRequiredWithoutSeasonsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SeasonUpdateWithoutSeriesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  episodeIds: EpisodeUpdateManyWithoutSeasonInput
  episodes: IntFieldUpdateOperationsInput
  index: IntFieldUpdateOperationsInput
  launchDate: DateTimeFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SeasonUpsertWithWhereUniqueWithoutSeriesInput {
  create: SeasonCreateWithoutSeriesInput!
  update: SeasonUpdateWithoutSeriesInput!
  where: SeasonWhereUniqueInput!
}

input SeasonUpsertWithoutEpisodeIdsInput {
  create: SeasonCreateWithoutEpisodeIdsInput!
  update: SeasonUpdateWithoutEpisodeIdsInput!
}

input SeasonWhereInput {
  AND: [SeasonWhereInput!]
  NOT: [SeasonWhereInput!]
  OR: [SeasonWhereInput!]
  createdAt: DateTimeFilter
  episodeIds: EpisodeListRelationFilter
  episodes: IntFilter
  id: IntFilter
  index: IntFilter
  launchDate: DateTimeFilter
  series: SerieRelationFilter
  seriesId: IntFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input SeasonWhereUniqueInput {
  id: Int
  seriesId_index: SeasonSeriesIdIndexCompoundUniqueInput
}

type Serie {
  _count: SerieCount
  actors(cursor: ActorWhereUniqueInput, distinct: [ActorScalarFieldEnum!], orderBy: [ActorOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: ActorWhereInput): [Actor!]!
  createdAt: DateTime!
  directors(cursor: DirectorWhereUniqueInput, distinct: [DirectorScalarFieldEnum!], orderBy: [DirectorOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: DirectorWhereInput): [Director!]!
  genres(cursor: GenreWhereUniqueInput, distinct: [GenreScalarFieldEnum!], orderBy: [GenreOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: GenreWhereInput): [Genre!]!
  id: Int!
  imdbID: String!
  imdbRating: Float!
  languages(cursor: LanguageWhereUniqueInput, distinct: [LanguageScalarFieldEnum!], orderBy: [LanguageOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: LanguageWhereInput): [Language!]!
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  seasons(cursor: SeasonWhereUniqueInput, distinct: [SeasonScalarFieldEnum!], orderBy: [SeasonOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: SeasonWhereInput): [Season!]!
  title: String!
  totalSeasons: Int!
  updatedAt: DateTime!
  watchlist(cursor: WatchlistedSerieWhereUniqueInput, distinct: [WatchlistedSerieScalarFieldEnum!], orderBy: [WatchlistedSerieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: WatchlistedSerieWhereInput): [WatchlistedSerie!]!
  year: Int!
}

type SerieAvgAggregate {
  id: Float
  imdbRating: Float
  runtime: Float
  totalSeasons: Float
  year: Float
}

input SerieAvgOrderByAggregateInput {
  id: SortOrder
  imdbRating: SortOrder
  runtime: SortOrder
  totalSeasons: SortOrder
  year: SortOrder
}

type SerieCount {
  actors: Int!
  directors: Int!
  genres: Int!
  languages: Int!
  seasons: Int!
  watchlist: Int!
}

type SerieCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  imdbID: Int!
  imdbRating: Int!
  plot: Int!
  poster: Int!
  rating: Int!
  release: Int!
  runtime: Int!
  title: Int!
  totalSeasons: Int!
  updatedAt: Int!
  year: Int!
}

input SerieCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  imdbID: SortOrder
  imdbRating: SortOrder
  plot: SortOrder
  poster: SortOrder
  rating: SortOrder
  release: SortOrder
  runtime: SortOrder
  title: SortOrder
  totalSeasons: SortOrder
  updatedAt: SortOrder
  year: SortOrder
}

input SerieCreateInput {
  actors: ActorCreateNestedManyWithoutSeriesInput
  createdAt: DateTime
  directors: DirectorCreateNestedManyWithoutSeriesInput
  genres: GenreCreateNestedManyWithoutSeriesInput
  imdbID: String!
  imdbRating: Float!
  languages: LanguageCreateNestedManyWithoutSeriesInput
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  seasons: SeasonCreateNestedManyWithoutSeriesInput
  title: String!
  totalSeasons: Int!
  updatedAt: DateTime
  watchlist: WatchlistedSerieCreateNestedManyWithoutSerieInput
  year: Int!
}

input SerieCreateManyInput {
  createdAt: DateTime
  id: Int
  imdbID: String!
  imdbRating: Float!
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  title: String!
  totalSeasons: Int!
  updatedAt: DateTime
  year: Int!
}

input SerieCreateNestedManyWithoutGenresInput {
  connect: [SerieWhereUniqueInput!]
  connectOrCreate: [SerieCreateOrConnectWithoutGenresInput!]
  create: [SerieCreateWithoutGenresInput!]
}

input SerieCreateNestedManyWithoutLanguagesInput {
  connect: [SerieWhereUniqueInput!]
  connectOrCreate: [SerieCreateOrConnectWithoutLanguagesInput!]
  create: [SerieCreateWithoutLanguagesInput!]
}

input SerieCreateNestedOneWithoutActorsInput {
  connect: SerieWhereUniqueInput
  connectOrCreate: SerieCreateOrConnectWithoutActorsInput
  create: SerieCreateWithoutActorsInput
}

input SerieCreateNestedOneWithoutDirectorsInput {
  connect: SerieWhereUniqueInput
  connectOrCreate: SerieCreateOrConnectWithoutDirectorsInput
  create: SerieCreateWithoutDirectorsInput
}

input SerieCreateNestedOneWithoutSeasonsInput {
  connect: SerieWhereUniqueInput
  connectOrCreate: SerieCreateOrConnectWithoutSeasonsInput
  create: SerieCreateWithoutSeasonsInput
}

input SerieCreateNestedOneWithoutWatchlistInput {
  connect: SerieWhereUniqueInput
  connectOrCreate: SerieCreateOrConnectWithoutWatchlistInput
  create: SerieCreateWithoutWatchlistInput
}

input SerieCreateOrConnectWithoutActorsInput {
  create: SerieCreateWithoutActorsInput!
  where: SerieWhereUniqueInput!
}

input SerieCreateOrConnectWithoutDirectorsInput {
  create: SerieCreateWithoutDirectorsInput!
  where: SerieWhereUniqueInput!
}

input SerieCreateOrConnectWithoutGenresInput {
  create: SerieCreateWithoutGenresInput!
  where: SerieWhereUniqueInput!
}

input SerieCreateOrConnectWithoutLanguagesInput {
  create: SerieCreateWithoutLanguagesInput!
  where: SerieWhereUniqueInput!
}

input SerieCreateOrConnectWithoutSeasonsInput {
  create: SerieCreateWithoutSeasonsInput!
  where: SerieWhereUniqueInput!
}

input SerieCreateOrConnectWithoutWatchlistInput {
  create: SerieCreateWithoutWatchlistInput!
  where: SerieWhereUniqueInput!
}

input SerieCreateWithoutActorsInput {
  createdAt: DateTime
  directors: DirectorCreateNestedManyWithoutSeriesInput
  genres: GenreCreateNestedManyWithoutSeriesInput
  imdbID: String!
  imdbRating: Float!
  languages: LanguageCreateNestedManyWithoutSeriesInput
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  seasons: SeasonCreateNestedManyWithoutSeriesInput
  title: String!
  totalSeasons: Int!
  updatedAt: DateTime
  watchlist: WatchlistedSerieCreateNestedManyWithoutSerieInput
  year: Int!
}

input SerieCreateWithoutDirectorsInput {
  actors: ActorCreateNestedManyWithoutSeriesInput
  createdAt: DateTime
  genres: GenreCreateNestedManyWithoutSeriesInput
  imdbID: String!
  imdbRating: Float!
  languages: LanguageCreateNestedManyWithoutSeriesInput
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  seasons: SeasonCreateNestedManyWithoutSeriesInput
  title: String!
  totalSeasons: Int!
  updatedAt: DateTime
  watchlist: WatchlistedSerieCreateNestedManyWithoutSerieInput
  year: Int!
}

input SerieCreateWithoutGenresInput {
  actors: ActorCreateNestedManyWithoutSeriesInput
  createdAt: DateTime
  directors: DirectorCreateNestedManyWithoutSeriesInput
  imdbID: String!
  imdbRating: Float!
  languages: LanguageCreateNestedManyWithoutSeriesInput
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  seasons: SeasonCreateNestedManyWithoutSeriesInput
  title: String!
  totalSeasons: Int!
  updatedAt: DateTime
  watchlist: WatchlistedSerieCreateNestedManyWithoutSerieInput
  year: Int!
}

input SerieCreateWithoutLanguagesInput {
  actors: ActorCreateNestedManyWithoutSeriesInput
  createdAt: DateTime
  directors: DirectorCreateNestedManyWithoutSeriesInput
  genres: GenreCreateNestedManyWithoutSeriesInput
  imdbID: String!
  imdbRating: Float!
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  seasons: SeasonCreateNestedManyWithoutSeriesInput
  title: String!
  totalSeasons: Int!
  updatedAt: DateTime
  watchlist: WatchlistedSerieCreateNestedManyWithoutSerieInput
  year: Int!
}

input SerieCreateWithoutSeasonsInput {
  actors: ActorCreateNestedManyWithoutSeriesInput
  createdAt: DateTime
  directors: DirectorCreateNestedManyWithoutSeriesInput
  genres: GenreCreateNestedManyWithoutSeriesInput
  imdbID: String!
  imdbRating: Float!
  languages: LanguageCreateNestedManyWithoutSeriesInput
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  title: String!
  totalSeasons: Int!
  updatedAt: DateTime
  watchlist: WatchlistedSerieCreateNestedManyWithoutSerieInput
  year: Int!
}

input SerieCreateWithoutWatchlistInput {
  actors: ActorCreateNestedManyWithoutSeriesInput
  createdAt: DateTime
  directors: DirectorCreateNestedManyWithoutSeriesInput
  genres: GenreCreateNestedManyWithoutSeriesInput
  imdbID: String!
  imdbRating: Float!
  languages: LanguageCreateNestedManyWithoutSeriesInput
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  seasons: SeasonCreateNestedManyWithoutSeriesInput
  title: String!
  totalSeasons: Int!
  updatedAt: DateTime
  year: Int!
}

type SerieGroupBy {
  _avg: SerieAvgAggregate
  _count: SerieCountAggregate
  _max: SerieMaxAggregate
  _min: SerieMinAggregate
  _sum: SerieSumAggregate
  createdAt: DateTime!
  id: Int!
  imdbID: String!
  imdbRating: Float!
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  title: String!
  totalSeasons: Int!
  updatedAt: DateTime!
  year: Int!
}

input SerieListRelationFilter {
  every: SerieWhereInput
  none: SerieWhereInput
  some: SerieWhereInput
}

type SerieMaxAggregate {
  createdAt: DateTime
  id: Int
  imdbID: String
  imdbRating: Float
  plot: String
  poster: String
  rating: String
  release: DateTime
  runtime: Int
  title: String
  totalSeasons: Int
  updatedAt: DateTime
  year: Int
}

input SerieMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  imdbID: SortOrder
  imdbRating: SortOrder
  plot: SortOrder
  poster: SortOrder
  rating: SortOrder
  release: SortOrder
  runtime: SortOrder
  title: SortOrder
  totalSeasons: SortOrder
  updatedAt: SortOrder
  year: SortOrder
}

type SerieMinAggregate {
  createdAt: DateTime
  id: Int
  imdbID: String
  imdbRating: Float
  plot: String
  poster: String
  rating: String
  release: DateTime
  runtime: Int
  title: String
  totalSeasons: Int
  updatedAt: DateTime
  year: Int
}

input SerieMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  imdbID: SortOrder
  imdbRating: SortOrder
  plot: SortOrder
  poster: SortOrder
  rating: SortOrder
  release: SortOrder
  runtime: SortOrder
  title: SortOrder
  totalSeasons: SortOrder
  updatedAt: SortOrder
  year: SortOrder
}

input SerieOrderByRelationAggregateInput {
  _count: SortOrder
}

enum SerieOrderByRelevanceFieldEnum {
  imdbID
  plot
  poster
  rating
  title
}

input SerieOrderByRelevanceInput {
  fields: [SerieOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input SerieOrderByWithAggregationInput {
  _avg: SerieAvgOrderByAggregateInput
  _count: SerieCountOrderByAggregateInput
  _max: SerieMaxOrderByAggregateInput
  _min: SerieMinOrderByAggregateInput
  _sum: SerieSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  imdbID: SortOrder
  imdbRating: SortOrder
  plot: SortOrder
  poster: SortOrder
  rating: SortOrder
  release: SortOrder
  runtime: SortOrder
  title: SortOrder
  totalSeasons: SortOrder
  updatedAt: SortOrder
  year: SortOrder
}

input SerieOrderByWithRelationAndSearchRelevanceInput {
  _relevance: SerieOrderByRelevanceInput
  actors: ActorOrderByRelationAggregateInput
  createdAt: SortOrder
  directors: DirectorOrderByRelationAggregateInput
  genres: GenreOrderByRelationAggregateInput
  id: SortOrder
  imdbID: SortOrder
  imdbRating: SortOrder
  languages: LanguageOrderByRelationAggregateInput
  plot: SortOrder
  poster: SortOrder
  rating: SortOrder
  release: SortOrder
  runtime: SortOrder
  seasons: SeasonOrderByRelationAggregateInput
  title: SortOrder
  totalSeasons: SortOrder
  updatedAt: SortOrder
  watchlist: WatchlistedSerieOrderByRelationAggregateInput
  year: SortOrder
}

input SerieRelationFilter {
  is: SerieWhereInput
  isNot: SerieWhereInput
}

enum SerieScalarFieldEnum {
  createdAt
  id
  imdbID
  imdbRating
  plot
  poster
  rating
  release
  runtime
  title
  totalSeasons
  updatedAt
  year
}

input SerieScalarWhereInput {
  AND: [SerieScalarWhereInput!]
  NOT: [SerieScalarWhereInput!]
  OR: [SerieScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  imdbID: StringFilter
  imdbRating: FloatFilter
  plot: StringFilter
  poster: StringFilter
  rating: StringFilter
  release: DateTimeFilter
  runtime: IntFilter
  title: StringFilter
  totalSeasons: IntFilter
  updatedAt: DateTimeFilter
  year: IntFilter
}

input SerieScalarWhereWithAggregatesInput {
  AND: [SerieScalarWhereWithAggregatesInput!]
  NOT: [SerieScalarWhereWithAggregatesInput!]
  OR: [SerieScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  imdbID: StringWithAggregatesFilter
  imdbRating: FloatWithAggregatesFilter
  plot: StringWithAggregatesFilter
  poster: StringWithAggregatesFilter
  rating: StringWithAggregatesFilter
  release: DateTimeWithAggregatesFilter
  runtime: IntWithAggregatesFilter
  title: StringWithAggregatesFilter
  totalSeasons: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  year: IntWithAggregatesFilter
}

type SerieSumAggregate {
  id: Int
  imdbRating: Float
  runtime: Int
  totalSeasons: Int
  year: Int
}

input SerieSumOrderByAggregateInput {
  id: SortOrder
  imdbRating: SortOrder
  runtime: SortOrder
  totalSeasons: SortOrder
  year: SortOrder
}

input SerieUpdateInput {
  actors: ActorUpdateManyWithoutSeriesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  directors: DirectorUpdateManyWithoutSeriesInput
  genres: GenreUpdateManyWithoutSeriesInput
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  languages: LanguageUpdateManyWithoutSeriesInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  rating: StringFieldUpdateOperationsInput
  release: DateTimeFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  seasons: SeasonUpdateManyWithoutSeriesInput
  title: StringFieldUpdateOperationsInput
  totalSeasons: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  watchlist: WatchlistedSerieUpdateManyWithoutSerieInput
  year: IntFieldUpdateOperationsInput
}

input SerieUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  rating: StringFieldUpdateOperationsInput
  release: DateTimeFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  totalSeasons: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  year: IntFieldUpdateOperationsInput
}

input SerieUpdateManyWithWhereWithoutGenresInput {
  data: SerieUpdateManyMutationInput!
  where: SerieScalarWhereInput!
}

input SerieUpdateManyWithWhereWithoutLanguagesInput {
  data: SerieUpdateManyMutationInput!
  where: SerieScalarWhereInput!
}

input SerieUpdateManyWithoutGenresInput {
  connect: [SerieWhereUniqueInput!]
  connectOrCreate: [SerieCreateOrConnectWithoutGenresInput!]
  create: [SerieCreateWithoutGenresInput!]
  delete: [SerieWhereUniqueInput!]
  deleteMany: [SerieScalarWhereInput!]
  disconnect: [SerieWhereUniqueInput!]
  set: [SerieWhereUniqueInput!]
  update: [SerieUpdateWithWhereUniqueWithoutGenresInput!]
  updateMany: [SerieUpdateManyWithWhereWithoutGenresInput!]
  upsert: [SerieUpsertWithWhereUniqueWithoutGenresInput!]
}

input SerieUpdateManyWithoutLanguagesInput {
  connect: [SerieWhereUniqueInput!]
  connectOrCreate: [SerieCreateOrConnectWithoutLanguagesInput!]
  create: [SerieCreateWithoutLanguagesInput!]
  delete: [SerieWhereUniqueInput!]
  deleteMany: [SerieScalarWhereInput!]
  disconnect: [SerieWhereUniqueInput!]
  set: [SerieWhereUniqueInput!]
  update: [SerieUpdateWithWhereUniqueWithoutLanguagesInput!]
  updateMany: [SerieUpdateManyWithWhereWithoutLanguagesInput!]
  upsert: [SerieUpsertWithWhereUniqueWithoutLanguagesInput!]
}

input SerieUpdateOneRequiredWithoutSeasonsInput {
  connect: SerieWhereUniqueInput
  connectOrCreate: SerieCreateOrConnectWithoutSeasonsInput
  create: SerieCreateWithoutSeasonsInput
  update: SerieUpdateWithoutSeasonsInput
  upsert: SerieUpsertWithoutSeasonsInput
}

input SerieUpdateOneRequiredWithoutWatchlistInput {
  connect: SerieWhereUniqueInput
  connectOrCreate: SerieCreateOrConnectWithoutWatchlistInput
  create: SerieCreateWithoutWatchlistInput
  update: SerieUpdateWithoutWatchlistInput
  upsert: SerieUpsertWithoutWatchlistInput
}

input SerieUpdateOneWithoutActorsInput {
  connect: SerieWhereUniqueInput
  connectOrCreate: SerieCreateOrConnectWithoutActorsInput
  create: SerieCreateWithoutActorsInput
  delete: Boolean
  disconnect: Boolean
  update: SerieUpdateWithoutActorsInput
  upsert: SerieUpsertWithoutActorsInput
}

input SerieUpdateOneWithoutDirectorsInput {
  connect: SerieWhereUniqueInput
  connectOrCreate: SerieCreateOrConnectWithoutDirectorsInput
  create: SerieCreateWithoutDirectorsInput
  delete: Boolean
  disconnect: Boolean
  update: SerieUpdateWithoutDirectorsInput
  upsert: SerieUpsertWithoutDirectorsInput
}

input SerieUpdateWithWhereUniqueWithoutGenresInput {
  data: SerieUpdateWithoutGenresInput!
  where: SerieWhereUniqueInput!
}

input SerieUpdateWithWhereUniqueWithoutLanguagesInput {
  data: SerieUpdateWithoutLanguagesInput!
  where: SerieWhereUniqueInput!
}

input SerieUpdateWithoutActorsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  directors: DirectorUpdateManyWithoutSeriesInput
  genres: GenreUpdateManyWithoutSeriesInput
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  languages: LanguageUpdateManyWithoutSeriesInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  rating: StringFieldUpdateOperationsInput
  release: DateTimeFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  seasons: SeasonUpdateManyWithoutSeriesInput
  title: StringFieldUpdateOperationsInput
  totalSeasons: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  watchlist: WatchlistedSerieUpdateManyWithoutSerieInput
  year: IntFieldUpdateOperationsInput
}

input SerieUpdateWithoutDirectorsInput {
  actors: ActorUpdateManyWithoutSeriesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  genres: GenreUpdateManyWithoutSeriesInput
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  languages: LanguageUpdateManyWithoutSeriesInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  rating: StringFieldUpdateOperationsInput
  release: DateTimeFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  seasons: SeasonUpdateManyWithoutSeriesInput
  title: StringFieldUpdateOperationsInput
  totalSeasons: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  watchlist: WatchlistedSerieUpdateManyWithoutSerieInput
  year: IntFieldUpdateOperationsInput
}

input SerieUpdateWithoutGenresInput {
  actors: ActorUpdateManyWithoutSeriesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  directors: DirectorUpdateManyWithoutSeriesInput
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  languages: LanguageUpdateManyWithoutSeriesInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  rating: StringFieldUpdateOperationsInput
  release: DateTimeFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  seasons: SeasonUpdateManyWithoutSeriesInput
  title: StringFieldUpdateOperationsInput
  totalSeasons: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  watchlist: WatchlistedSerieUpdateManyWithoutSerieInput
  year: IntFieldUpdateOperationsInput
}

input SerieUpdateWithoutLanguagesInput {
  actors: ActorUpdateManyWithoutSeriesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  directors: DirectorUpdateManyWithoutSeriesInput
  genres: GenreUpdateManyWithoutSeriesInput
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  rating: StringFieldUpdateOperationsInput
  release: DateTimeFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  seasons: SeasonUpdateManyWithoutSeriesInput
  title: StringFieldUpdateOperationsInput
  totalSeasons: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  watchlist: WatchlistedSerieUpdateManyWithoutSerieInput
  year: IntFieldUpdateOperationsInput
}

input SerieUpdateWithoutSeasonsInput {
  actors: ActorUpdateManyWithoutSeriesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  directors: DirectorUpdateManyWithoutSeriesInput
  genres: GenreUpdateManyWithoutSeriesInput
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  languages: LanguageUpdateManyWithoutSeriesInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  rating: StringFieldUpdateOperationsInput
  release: DateTimeFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  totalSeasons: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  watchlist: WatchlistedSerieUpdateManyWithoutSerieInput
  year: IntFieldUpdateOperationsInput
}

input SerieUpdateWithoutWatchlistInput {
  actors: ActorUpdateManyWithoutSeriesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  directors: DirectorUpdateManyWithoutSeriesInput
  genres: GenreUpdateManyWithoutSeriesInput
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  languages: LanguageUpdateManyWithoutSeriesInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  rating: StringFieldUpdateOperationsInput
  release: DateTimeFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  seasons: SeasonUpdateManyWithoutSeriesInput
  title: StringFieldUpdateOperationsInput
  totalSeasons: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  year: IntFieldUpdateOperationsInput
}

input SerieUpsertWithWhereUniqueWithoutGenresInput {
  create: SerieCreateWithoutGenresInput!
  update: SerieUpdateWithoutGenresInput!
  where: SerieWhereUniqueInput!
}

input SerieUpsertWithWhereUniqueWithoutLanguagesInput {
  create: SerieCreateWithoutLanguagesInput!
  update: SerieUpdateWithoutLanguagesInput!
  where: SerieWhereUniqueInput!
}

input SerieUpsertWithoutActorsInput {
  create: SerieCreateWithoutActorsInput!
  update: SerieUpdateWithoutActorsInput!
}

input SerieUpsertWithoutDirectorsInput {
  create: SerieCreateWithoutDirectorsInput!
  update: SerieUpdateWithoutDirectorsInput!
}

input SerieUpsertWithoutSeasonsInput {
  create: SerieCreateWithoutSeasonsInput!
  update: SerieUpdateWithoutSeasonsInput!
}

input SerieUpsertWithoutWatchlistInput {
  create: SerieCreateWithoutWatchlistInput!
  update: SerieUpdateWithoutWatchlistInput!
}

input SerieWhereInput {
  AND: [SerieWhereInput!]
  NOT: [SerieWhereInput!]
  OR: [SerieWhereInput!]
  actors: ActorListRelationFilter
  createdAt: DateTimeFilter
  directors: DirectorListRelationFilter
  genres: GenreListRelationFilter
  id: IntFilter
  imdbID: StringFilter
  imdbRating: FloatFilter
  languages: LanguageListRelationFilter
  plot: StringFilter
  poster: StringFilter
  rating: StringFilter
  release: DateTimeFilter
  runtime: IntFilter
  seasons: SeasonListRelationFilter
  title: StringFilter
  totalSeasons: IntFilter
  updatedAt: DateTimeFilter
  watchlist: WatchlistedSerieListRelationFilter
  year: IntFilter
}

input SerieWhereUniqueInput {
  id: Int
  imdbID: String
}

type SeriesWatchlist {
  _count: SeriesWatchlistCount
  id: Int!
  series(cursor: WatchlistedSerieWhereUniqueInput, distinct: [WatchlistedSerieScalarFieldEnum!], orderBy: [WatchlistedSerieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: WatchlistedSerieWhereInput): [WatchlistedSerie!]!
  watchlist: Watchlist!
  watchlistId: Int!
}

type SeriesWatchlistAvgAggregate {
  id: Float
  watchlistId: Float
}

input SeriesWatchlistAvgOrderByAggregateInput {
  id: SortOrder
  watchlistId: SortOrder
}

type SeriesWatchlistCount {
  series: Int!
}

type SeriesWatchlistCountAggregate {
  _all: Int!
  id: Int!
  watchlistId: Int!
}

input SeriesWatchlistCountOrderByAggregateInput {
  id: SortOrder
  watchlistId: SortOrder
}

input SeriesWatchlistCreateInput {
  id: Int!
  series: WatchlistedSerieCreateNestedManyWithoutWatchlistInput
  watchlist: WatchlistCreateNestedOneWithoutSeriesWatchlistInput!
}

input SeriesWatchlistCreateManyInput {
  id: Int!
  watchlistId: Int!
}

input SeriesWatchlistCreateNestedOneWithoutSeriesInput {
  connect: SeriesWatchlistWhereUniqueInput
  connectOrCreate: SeriesWatchlistCreateOrConnectWithoutSeriesInput
  create: SeriesWatchlistCreateWithoutSeriesInput
}

input SeriesWatchlistCreateNestedOneWithoutWatchlistInput {
  connect: SeriesWatchlistWhereUniqueInput
  connectOrCreate: SeriesWatchlistCreateOrConnectWithoutWatchlistInput
  create: SeriesWatchlistCreateWithoutWatchlistInput
}

input SeriesWatchlistCreateOrConnectWithoutSeriesInput {
  create: SeriesWatchlistCreateWithoutSeriesInput!
  where: SeriesWatchlistWhereUniqueInput!
}

input SeriesWatchlistCreateOrConnectWithoutWatchlistInput {
  create: SeriesWatchlistCreateWithoutWatchlistInput!
  where: SeriesWatchlistWhereUniqueInput!
}

input SeriesWatchlistCreateWithoutSeriesInput {
  id: Int!
  watchlist: WatchlistCreateNestedOneWithoutSeriesWatchlistInput!
}

input SeriesWatchlistCreateWithoutWatchlistInput {
  id: Int!
  series: WatchlistedSerieCreateNestedManyWithoutWatchlistInput
}

type SeriesWatchlistGroupBy {
  _avg: SeriesWatchlistAvgAggregate
  _count: SeriesWatchlistCountAggregate
  _max: SeriesWatchlistMaxAggregate
  _min: SeriesWatchlistMinAggregate
  _sum: SeriesWatchlistSumAggregate
  id: Int!
  watchlistId: Int!
}

type SeriesWatchlistMaxAggregate {
  id: Int
  watchlistId: Int
}

input SeriesWatchlistMaxOrderByAggregateInput {
  id: SortOrder
  watchlistId: SortOrder
}

type SeriesWatchlistMinAggregate {
  id: Int
  watchlistId: Int
}

input SeriesWatchlistMinOrderByAggregateInput {
  id: SortOrder
  watchlistId: SortOrder
}

input SeriesWatchlistOrderByWithAggregationInput {
  _avg: SeriesWatchlistAvgOrderByAggregateInput
  _count: SeriesWatchlistCountOrderByAggregateInput
  _max: SeriesWatchlistMaxOrderByAggregateInput
  _min: SeriesWatchlistMinOrderByAggregateInput
  _sum: SeriesWatchlistSumOrderByAggregateInput
  id: SortOrder
  watchlistId: SortOrder
}

input SeriesWatchlistOrderByWithRelationAndSearchRelevanceInput {
  id: SortOrder
  series: WatchlistedSerieOrderByRelationAggregateInput
  watchlist: WatchlistOrderByWithRelationAndSearchRelevanceInput
  watchlistId: SortOrder
}

input SeriesWatchlistRelationFilter {
  is: SeriesWatchlistWhereInput
  isNot: SeriesWatchlistWhereInput
}

enum SeriesWatchlistScalarFieldEnum {
  id
  watchlistId
}

input SeriesWatchlistScalarWhereWithAggregatesInput {
  AND: [SeriesWatchlistScalarWhereWithAggregatesInput!]
  NOT: [SeriesWatchlistScalarWhereWithAggregatesInput!]
  OR: [SeriesWatchlistScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  watchlistId: IntWithAggregatesFilter
}

type SeriesWatchlistSumAggregate {
  id: Int
  watchlistId: Int
}

input SeriesWatchlistSumOrderByAggregateInput {
  id: SortOrder
  watchlistId: SortOrder
}

input SeriesWatchlistUpdateInput {
  id: IntFieldUpdateOperationsInput
  series: WatchlistedSerieUpdateManyWithoutWatchlistInput
  watchlist: WatchlistUpdateOneRequiredWithoutSeriesWatchlistInput
}

input SeriesWatchlistUpdateManyMutationInput {
  id: IntFieldUpdateOperationsInput
}

input SeriesWatchlistUpdateOneRequiredWithoutSeriesInput {
  connect: SeriesWatchlistWhereUniqueInput
  connectOrCreate: SeriesWatchlistCreateOrConnectWithoutSeriesInput
  create: SeriesWatchlistCreateWithoutSeriesInput
  update: SeriesWatchlistUpdateWithoutSeriesInput
  upsert: SeriesWatchlistUpsertWithoutSeriesInput
}

input SeriesWatchlistUpdateOneWithoutWatchlistInput {
  connect: SeriesWatchlistWhereUniqueInput
  connectOrCreate: SeriesWatchlistCreateOrConnectWithoutWatchlistInput
  create: SeriesWatchlistCreateWithoutWatchlistInput
  delete: Boolean
  disconnect: Boolean
  update: SeriesWatchlistUpdateWithoutWatchlistInput
  upsert: SeriesWatchlistUpsertWithoutWatchlistInput
}

input SeriesWatchlistUpdateWithoutSeriesInput {
  id: IntFieldUpdateOperationsInput
  watchlist: WatchlistUpdateOneRequiredWithoutSeriesWatchlistInput
}

input SeriesWatchlistUpdateWithoutWatchlistInput {
  id: IntFieldUpdateOperationsInput
  series: WatchlistedSerieUpdateManyWithoutWatchlistInput
}

input SeriesWatchlistUpsertWithoutSeriesInput {
  create: SeriesWatchlistCreateWithoutSeriesInput!
  update: SeriesWatchlistUpdateWithoutSeriesInput!
}

input SeriesWatchlistUpsertWithoutWatchlistInput {
  create: SeriesWatchlistCreateWithoutWatchlistInput!
  update: SeriesWatchlistUpdateWithoutWatchlistInput!
}

input SeriesWatchlistWhereInput {
  AND: [SeriesWatchlistWhereInput!]
  NOT: [SeriesWatchlistWhereInput!]
  OR: [SeriesWatchlistWhereInput!]
  id: IntFilter
  series: WatchlistedSerieListRelationFilter
  watchlist: WatchlistRelationFilter
  watchlistId: IntFilter
}

input SeriesWatchlistWhereUniqueInput {
  id: Int
  watchlistId: Int
}

type Session {
  accessToken: String!
  createdAt: DateTime!
  expires: DateTime!
  id: String!
  sessionToken: String!
  updatedAt: DateTime!
  user: User!
  userId: String!
}

type SessionCountAggregate {
  _all: Int!
  accessToken: Int!
  createdAt: Int!
  expires: Int!
  id: Int!
  sessionToken: Int!
  updatedAt: Int!
  userId: Int!
}

input SessionCountOrderByAggregateInput {
  accessToken: SortOrder
  createdAt: SortOrder
  expires: SortOrder
  id: SortOrder
  sessionToken: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input SessionCreateInput {
  accessToken: String!
  createdAt: DateTime
  expires: DateTime!
  id: String
  sessionToken: String!
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutSessionsInput!
}

input SessionCreateManyInput {
  accessToken: String!
  createdAt: DateTime
  expires: DateTime!
  id: String
  sessionToken: String!
  updatedAt: DateTime
  userId: String!
}

input SessionCreateManyUserInput {
  accessToken: String!
  createdAt: DateTime
  expires: DateTime!
  id: String
  sessionToken: String!
  updatedAt: DateTime
}

input SessionCreateManyUserInputEnvelope {
  data: [SessionCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input SessionCreateNestedManyWithoutUserInput {
  connect: [SessionWhereUniqueInput!]
  connectOrCreate: [SessionCreateOrConnectWithoutUserInput!]
  create: [SessionCreateWithoutUserInput!]
  createMany: SessionCreateManyUserInputEnvelope
}

input SessionCreateOrConnectWithoutUserInput {
  create: SessionCreateWithoutUserInput!
  where: SessionWhereUniqueInput!
}

input SessionCreateWithoutUserInput {
  accessToken: String!
  createdAt: DateTime
  expires: DateTime!
  id: String
  sessionToken: String!
  updatedAt: DateTime
}

type SessionGroupBy {
  _count: SessionCountAggregate
  _max: SessionMaxAggregate
  _min: SessionMinAggregate
  accessToken: String!
  createdAt: DateTime!
  expires: DateTime!
  id: String!
  sessionToken: String!
  updatedAt: DateTime!
  userId: String!
}

input SessionListRelationFilter {
  every: SessionWhereInput
  none: SessionWhereInput
  some: SessionWhereInput
}

type SessionMaxAggregate {
  accessToken: String
  createdAt: DateTime
  expires: DateTime
  id: String
  sessionToken: String
  updatedAt: DateTime
  userId: String
}

input SessionMaxOrderByAggregateInput {
  accessToken: SortOrder
  createdAt: SortOrder
  expires: SortOrder
  id: SortOrder
  sessionToken: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

type SessionMinAggregate {
  accessToken: String
  createdAt: DateTime
  expires: DateTime
  id: String
  sessionToken: String
  updatedAt: DateTime
  userId: String
}

input SessionMinOrderByAggregateInput {
  accessToken: SortOrder
  createdAt: SortOrder
  expires: SortOrder
  id: SortOrder
  sessionToken: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input SessionOrderByRelationAggregateInput {
  _count: SortOrder
}

enum SessionOrderByRelevanceFieldEnum {
  accessToken
  id
  sessionToken
  userId
}

input SessionOrderByRelevanceInput {
  fields: [SessionOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input SessionOrderByWithAggregationInput {
  _count: SessionCountOrderByAggregateInput
  _max: SessionMaxOrderByAggregateInput
  _min: SessionMinOrderByAggregateInput
  accessToken: SortOrder
  createdAt: SortOrder
  expires: SortOrder
  id: SortOrder
  sessionToken: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input SessionOrderByWithRelationAndSearchRelevanceInput {
  _relevance: SessionOrderByRelevanceInput
  accessToken: SortOrder
  createdAt: SortOrder
  expires: SortOrder
  id: SortOrder
  sessionToken: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationAndSearchRelevanceInput
  userId: SortOrder
}

enum SessionScalarFieldEnum {
  accessToken
  createdAt
  expires
  id
  sessionToken
  updatedAt
  userId
}

input SessionScalarWhereInput {
  AND: [SessionScalarWhereInput!]
  NOT: [SessionScalarWhereInput!]
  OR: [SessionScalarWhereInput!]
  accessToken: StringFilter
  createdAt: DateTimeFilter
  expires: DateTimeFilter
  id: StringFilter
  sessionToken: StringFilter
  updatedAt: DateTimeFilter
  userId: StringFilter
}

input SessionScalarWhereWithAggregatesInput {
  AND: [SessionScalarWhereWithAggregatesInput!]
  NOT: [SessionScalarWhereWithAggregatesInput!]
  OR: [SessionScalarWhereWithAggregatesInput!]
  accessToken: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  expires: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  sessionToken: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: StringWithAggregatesFilter
}

input SessionUpdateInput {
  accessToken: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  sessionToken: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutSessionsInput
}

input SessionUpdateManyMutationInput {
  accessToken: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  sessionToken: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SessionUpdateManyWithWhereWithoutUserInput {
  data: SessionUpdateManyMutationInput!
  where: SessionScalarWhereInput!
}

input SessionUpdateManyWithoutUserInput {
  connect: [SessionWhereUniqueInput!]
  connectOrCreate: [SessionCreateOrConnectWithoutUserInput!]
  create: [SessionCreateWithoutUserInput!]
  createMany: SessionCreateManyUserInputEnvelope
  delete: [SessionWhereUniqueInput!]
  deleteMany: [SessionScalarWhereInput!]
  disconnect: [SessionWhereUniqueInput!]
  set: [SessionWhereUniqueInput!]
  update: [SessionUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [SessionUpdateManyWithWhereWithoutUserInput!]
  upsert: [SessionUpsertWithWhereUniqueWithoutUserInput!]
}

input SessionUpdateWithWhereUniqueWithoutUserInput {
  data: SessionUpdateWithoutUserInput!
  where: SessionWhereUniqueInput!
}

input SessionUpdateWithoutUserInput {
  accessToken: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  sessionToken: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SessionUpsertWithWhereUniqueWithoutUserInput {
  create: SessionCreateWithoutUserInput!
  update: SessionUpdateWithoutUserInput!
  where: SessionWhereUniqueInput!
}

input SessionWhereInput {
  AND: [SessionWhereInput!]
  NOT: [SessionWhereInput!]
  OR: [SessionWhereInput!]
  accessToken: StringFilter
  createdAt: DateTimeFilter
  expires: DateTimeFilter
  id: StringFilter
  sessionToken: StringFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: StringFilter
}

input SessionWhereUniqueInput {
  accessToken: String
  id: String
  sessionToken: String
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  search: String
  startsWith: String
}

type User {
  _count: UserCount
  accounts(cursor: AccountWhereUniqueInput, distinct: [AccountScalarFieldEnum!], orderBy: [AccountOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: AccountWhereInput): [Account!]!
  createdAt: DateTime!
  email: String!
  emailVerified: DateTime
  firstName: String
  id: String!
  image: String
  lastName: String
  role: Role!
  sessions(cursor: SessionWhereUniqueInput, distinct: [SessionScalarFieldEnum!], orderBy: [SessionOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: SessionWhereInput): [Session!]!
  settings(cursor: AppSettingsWhereUniqueInput, distinct: [AppSettingsScalarFieldEnum!], orderBy: [AppSettingsOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: AppSettingsWhereInput): [AppSettings!]!
  updatedAt: DateTime!
  username: String
  watchlist(cursor: WatchlistWhereUniqueInput, distinct: [WatchlistScalarFieldEnum!], orderBy: [WatchlistOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: WatchlistWhereInput): [Watchlist!]!
}

type UserCount {
  accounts: Int!
  sessions: Int!
  settings: Int!
  watchlist: Int!
}

type UserCountAggregate {
  _all: Int!
  createdAt: Int!
  email: Int!
  emailVerified: Int!
  firstName: Int!
  id: Int!
  image: Int!
  lastName: Int!
  role: Int!
  updatedAt: Int!
  username: Int!
}

input UserCountOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  emailVerified: SortOrder
  firstName: SortOrder
  id: SortOrder
  image: SortOrder
  lastName: SortOrder
  role: SortOrder
  updatedAt: SortOrder
  username: SortOrder
}

input UserCreateInput {
  accounts: AccountCreateNestedManyWithoutUserInput
  createdAt: DateTime
  email: String!
  emailVerified: DateTime
  firstName: String
  id: String
  image: String
  lastName: String
  role: Role
  sessions: SessionCreateNestedManyWithoutUserInput
  settings: AppSettingsCreateNestedManyWithoutUserInput
  updatedAt: DateTime
  username: String
  watchlist: WatchlistCreateNestedManyWithoutUserInput
}

input UserCreateManyInput {
  createdAt: DateTime
  email: String!
  emailVerified: DateTime
  firstName: String
  id: String
  image: String
  lastName: String
  role: Role
  updatedAt: DateTime
  username: String
}

input UserCreateNestedOneWithoutAccountsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutAccountsInput
  create: UserCreateWithoutAccountsInput
}

input UserCreateNestedOneWithoutSessionsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutSessionsInput
  create: UserCreateWithoutSessionsInput
}

input UserCreateNestedOneWithoutSettingsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutSettingsInput
  create: UserCreateWithoutSettingsInput
}

input UserCreateNestedOneWithoutWatchlistInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutWatchlistInput
  create: UserCreateWithoutWatchlistInput
}

input UserCreateOrConnectWithoutAccountsInput {
  create: UserCreateWithoutAccountsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutSessionsInput {
  create: UserCreateWithoutSessionsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutSettingsInput {
  create: UserCreateWithoutSettingsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutWatchlistInput {
  create: UserCreateWithoutWatchlistInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutAccountsInput {
  createdAt: DateTime
  email: String!
  emailVerified: DateTime
  firstName: String
  id: String
  image: String
  lastName: String
  role: Role
  sessions: SessionCreateNestedManyWithoutUserInput
  settings: AppSettingsCreateNestedManyWithoutUserInput
  updatedAt: DateTime
  username: String
  watchlist: WatchlistCreateNestedManyWithoutUserInput
}

input UserCreateWithoutSessionsInput {
  accounts: AccountCreateNestedManyWithoutUserInput
  createdAt: DateTime
  email: String!
  emailVerified: DateTime
  firstName: String
  id: String
  image: String
  lastName: String
  role: Role
  settings: AppSettingsCreateNestedManyWithoutUserInput
  updatedAt: DateTime
  username: String
  watchlist: WatchlistCreateNestedManyWithoutUserInput
}

input UserCreateWithoutSettingsInput {
  accounts: AccountCreateNestedManyWithoutUserInput
  createdAt: DateTime
  email: String!
  emailVerified: DateTime
  firstName: String
  id: String
  image: String
  lastName: String
  role: Role
  sessions: SessionCreateNestedManyWithoutUserInput
  updatedAt: DateTime
  username: String
  watchlist: WatchlistCreateNestedManyWithoutUserInput
}

input UserCreateWithoutWatchlistInput {
  accounts: AccountCreateNestedManyWithoutUserInput
  createdAt: DateTime
  email: String!
  emailVerified: DateTime
  firstName: String
  id: String
  image: String
  lastName: String
  role: Role
  sessions: SessionCreateNestedManyWithoutUserInput
  settings: AppSettingsCreateNestedManyWithoutUserInput
  updatedAt: DateTime
  username: String
}

type UserGroupBy {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  createdAt: DateTime!
  email: String!
  emailVerified: DateTime
  firstName: String
  id: String!
  image: String
  lastName: String
  role: Role!
  updatedAt: DateTime!
  username: String
}

type UserMaxAggregate {
  createdAt: DateTime
  email: String
  emailVerified: DateTime
  firstName: String
  id: String
  image: String
  lastName: String
  role: Role
  updatedAt: DateTime
  username: String
}

input UserMaxOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  emailVerified: SortOrder
  firstName: SortOrder
  id: SortOrder
  image: SortOrder
  lastName: SortOrder
  role: SortOrder
  updatedAt: SortOrder
  username: SortOrder
}

type UserMinAggregate {
  createdAt: DateTime
  email: String
  emailVerified: DateTime
  firstName: String
  id: String
  image: String
  lastName: String
  role: Role
  updatedAt: DateTime
  username: String
}

input UserMinOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  emailVerified: SortOrder
  firstName: SortOrder
  id: SortOrder
  image: SortOrder
  lastName: SortOrder
  role: SortOrder
  updatedAt: SortOrder
  username: SortOrder
}

enum UserOrderByRelevanceFieldEnum {
  email
  firstName
  id
  image
  lastName
  username
}

input UserOrderByRelevanceInput {
  fields: [UserOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input UserOrderByWithAggregationInput {
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  createdAt: SortOrder
  email: SortOrder
  emailVerified: SortOrder
  firstName: SortOrder
  id: SortOrder
  image: SortOrder
  lastName: SortOrder
  role: SortOrder
  updatedAt: SortOrder
  username: SortOrder
}

input UserOrderByWithRelationAndSearchRelevanceInput {
  _relevance: UserOrderByRelevanceInput
  accounts: AccountOrderByRelationAggregateInput
  createdAt: SortOrder
  email: SortOrder
  emailVerified: SortOrder
  firstName: SortOrder
  id: SortOrder
  image: SortOrder
  lastName: SortOrder
  role: SortOrder
  sessions: SessionOrderByRelationAggregateInput
  settings: AppSettingsOrderByRelationAggregateInput
  updatedAt: SortOrder
  username: SortOrder
  watchlist: WatchlistOrderByRelationAggregateInput
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  createdAt
  email
  emailVerified
  firstName
  id
  image
  lastName
  role
  updatedAt
  username
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  email: StringWithAggregatesFilter
  emailVerified: DateTimeNullableWithAggregatesFilter
  firstName: StringNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  image: StringNullableWithAggregatesFilter
  lastName: StringNullableWithAggregatesFilter
  role: EnumRoleWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  username: StringNullableWithAggregatesFilter
}

input UserUpdateInput {
  accounts: AccountUpdateManyWithoutUserInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  lastName: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  sessions: SessionUpdateManyWithoutUserInput
  settings: AppSettingsUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
  watchlist: WatchlistUpdateManyWithoutUserInput
}

input UserUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  lastName: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutAccountsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutAccountsInput
  create: UserCreateWithoutAccountsInput
  update: UserUpdateWithoutAccountsInput
  upsert: UserUpsertWithoutAccountsInput
}

input UserUpdateOneRequiredWithoutSessionsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutSessionsInput
  create: UserCreateWithoutSessionsInput
  update: UserUpdateWithoutSessionsInput
  upsert: UserUpsertWithoutSessionsInput
}

input UserUpdateOneRequiredWithoutWatchlistInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutWatchlistInput
  create: UserCreateWithoutWatchlistInput
  update: UserUpdateWithoutWatchlistInput
  upsert: UserUpsertWithoutWatchlistInput
}

input UserUpdateOneWithoutSettingsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutSettingsInput
  create: UserCreateWithoutSettingsInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutSettingsInput
  upsert: UserUpsertWithoutSettingsInput
}

input UserUpdateWithoutAccountsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  lastName: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  sessions: SessionUpdateManyWithoutUserInput
  settings: AppSettingsUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
  watchlist: WatchlistUpdateManyWithoutUserInput
}

input UserUpdateWithoutSessionsInput {
  accounts: AccountUpdateManyWithoutUserInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  lastName: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  settings: AppSettingsUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
  watchlist: WatchlistUpdateManyWithoutUserInput
}

input UserUpdateWithoutSettingsInput {
  accounts: AccountUpdateManyWithoutUserInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  lastName: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  sessions: SessionUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
  watchlist: WatchlistUpdateManyWithoutUserInput
}

input UserUpdateWithoutWatchlistInput {
  accounts: AccountUpdateManyWithoutUserInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  lastName: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  sessions: SessionUpdateManyWithoutUserInput
  settings: AppSettingsUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
}

input UserUpsertWithoutAccountsInput {
  create: UserCreateWithoutAccountsInput!
  update: UserUpdateWithoutAccountsInput!
}

input UserUpsertWithoutSessionsInput {
  create: UserCreateWithoutSessionsInput!
  update: UserUpdateWithoutSessionsInput!
}

input UserUpsertWithoutSettingsInput {
  create: UserCreateWithoutSettingsInput!
  update: UserUpdateWithoutSettingsInput!
}

input UserUpsertWithoutWatchlistInput {
  create: UserCreateWithoutWatchlistInput!
  update: UserUpdateWithoutWatchlistInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  accounts: AccountListRelationFilter
  createdAt: DateTimeFilter
  email: StringFilter
  emailVerified: DateTimeNullableFilter
  firstName: StringNullableFilter
  id: StringFilter
  image: StringNullableFilter
  lastName: StringNullableFilter
  role: EnumRoleFilter
  sessions: SessionListRelationFilter
  settings: AppSettingsListRelationFilter
  updatedAt: DateTimeFilter
  username: StringNullableFilter
  watchlist: WatchlistListRelationFilter
}

input UserWhereUniqueInput {
  email: String
  id: String
  username: String
}

type VerificationRequest {
  createdAt: DateTime!
  expires: DateTime!
  id: String!
  identifier: String!
  token: String!
  updatedAt: DateTime!
}

type VerificationRequestCountAggregate {
  _all: Int!
  createdAt: Int!
  expires: Int!
  id: Int!
  identifier: Int!
  token: Int!
  updatedAt: Int!
}

input VerificationRequestCountOrderByAggregateInput {
  createdAt: SortOrder
  expires: SortOrder
  id: SortOrder
  identifier: SortOrder
  token: SortOrder
  updatedAt: SortOrder
}

input VerificationRequestCreateInput {
  createdAt: DateTime
  expires: DateTime!
  id: String
  identifier: String!
  token: String!
  updatedAt: DateTime
}

input VerificationRequestCreateManyInput {
  createdAt: DateTime
  expires: DateTime!
  id: String
  identifier: String!
  token: String!
  updatedAt: DateTime
}

type VerificationRequestGroupBy {
  _count: VerificationRequestCountAggregate
  _max: VerificationRequestMaxAggregate
  _min: VerificationRequestMinAggregate
  createdAt: DateTime!
  expires: DateTime!
  id: String!
  identifier: String!
  token: String!
  updatedAt: DateTime!
}

input VerificationRequestIdentifierTokenCompoundUniqueInput {
  identifier: String!
  token: String!
}

type VerificationRequestMaxAggregate {
  createdAt: DateTime
  expires: DateTime
  id: String
  identifier: String
  token: String
  updatedAt: DateTime
}

input VerificationRequestMaxOrderByAggregateInput {
  createdAt: SortOrder
  expires: SortOrder
  id: SortOrder
  identifier: SortOrder
  token: SortOrder
  updatedAt: SortOrder
}

type VerificationRequestMinAggregate {
  createdAt: DateTime
  expires: DateTime
  id: String
  identifier: String
  token: String
  updatedAt: DateTime
}

input VerificationRequestMinOrderByAggregateInput {
  createdAt: SortOrder
  expires: SortOrder
  id: SortOrder
  identifier: SortOrder
  token: SortOrder
  updatedAt: SortOrder
}

enum VerificationRequestOrderByRelevanceFieldEnum {
  id
  identifier
  token
}

input VerificationRequestOrderByRelevanceInput {
  fields: [VerificationRequestOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input VerificationRequestOrderByWithAggregationInput {
  _count: VerificationRequestCountOrderByAggregateInput
  _max: VerificationRequestMaxOrderByAggregateInput
  _min: VerificationRequestMinOrderByAggregateInput
  createdAt: SortOrder
  expires: SortOrder
  id: SortOrder
  identifier: SortOrder
  token: SortOrder
  updatedAt: SortOrder
}

input VerificationRequestOrderByWithRelationAndSearchRelevanceInput {
  _relevance: VerificationRequestOrderByRelevanceInput
  createdAt: SortOrder
  expires: SortOrder
  id: SortOrder
  identifier: SortOrder
  token: SortOrder
  updatedAt: SortOrder
}

enum VerificationRequestScalarFieldEnum {
  createdAt
  expires
  id
  identifier
  token
  updatedAt
}

input VerificationRequestScalarWhereWithAggregatesInput {
  AND: [VerificationRequestScalarWhereWithAggregatesInput!]
  NOT: [VerificationRequestScalarWhereWithAggregatesInput!]
  OR: [VerificationRequestScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  expires: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  identifier: StringWithAggregatesFilter
  token: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

input VerificationRequestUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  token: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input VerificationRequestUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  token: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input VerificationRequestWhereInput {
  AND: [VerificationRequestWhereInput!]
  NOT: [VerificationRequestWhereInput!]
  OR: [VerificationRequestWhereInput!]
  createdAt: DateTimeFilter
  expires: DateTimeFilter
  id: StringFilter
  identifier: StringFilter
  token: StringFilter
  updatedAt: DateTimeFilter
}

input VerificationRequestWhereUniqueInput {
  id: String
  identifier_token: VerificationRequestIdentifierTokenCompoundUniqueInput
  token: String
}

type Watchlist {
  createdAt: DateTime!
  default: Boolean!
  episodeWatchlist: EpisodesWatchlist
  id: Int!
  movieWatchlist: MoviesWatchlist
  name: String
  seriesWatchlist: SeriesWatchlist
  updatedAt: DateTime!
  user: User!
  userId: String!
}

type WatchlistAvgAggregate {
  id: Float
}

input WatchlistAvgOrderByAggregateInput {
  id: SortOrder
}

type WatchlistCountAggregate {
  _all: Int!
  createdAt: Int!
  default: Int!
  id: Int!
  name: Int!
  updatedAt: Int!
  userId: Int!
}

input WatchlistCountOrderByAggregateInput {
  createdAt: SortOrder
  default: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input WatchlistCreateInput {
  createdAt: DateTime
  default: Boolean!
  episodeWatchlist: EpisodesWatchlistCreateNestedOneWithoutWatchlistInput
  movieWatchlist: MoviesWatchlistCreateNestedOneWithoutWatchlistInput
  name: String
  seriesWatchlist: SeriesWatchlistCreateNestedOneWithoutWatchlistInput
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutWatchlistInput!
}

input WatchlistCreateManyInput {
  createdAt: DateTime
  default: Boolean!
  id: Int
  name: String
  updatedAt: DateTime
  userId: String!
}

input WatchlistCreateManyUserInput {
  createdAt: DateTime
  default: Boolean!
  id: Int
  name: String
  updatedAt: DateTime
}

input WatchlistCreateManyUserInputEnvelope {
  data: [WatchlistCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input WatchlistCreateNestedManyWithoutUserInput {
  connect: [WatchlistWhereUniqueInput!]
  connectOrCreate: [WatchlistCreateOrConnectWithoutUserInput!]
  create: [WatchlistCreateWithoutUserInput!]
  createMany: WatchlistCreateManyUserInputEnvelope
}

input WatchlistCreateNestedOneWithoutEpisodeWatchlistInput {
  connect: WatchlistWhereUniqueInput
  connectOrCreate: WatchlistCreateOrConnectWithoutEpisodeWatchlistInput
  create: WatchlistCreateWithoutEpisodeWatchlistInput
}

input WatchlistCreateNestedOneWithoutMovieWatchlistInput {
  connect: WatchlistWhereUniqueInput
  connectOrCreate: WatchlistCreateOrConnectWithoutMovieWatchlistInput
  create: WatchlistCreateWithoutMovieWatchlistInput
}

input WatchlistCreateNestedOneWithoutSeriesWatchlistInput {
  connect: WatchlistWhereUniqueInput
  connectOrCreate: WatchlistCreateOrConnectWithoutSeriesWatchlistInput
  create: WatchlistCreateWithoutSeriesWatchlistInput
}

input WatchlistCreateOrConnectWithoutEpisodeWatchlistInput {
  create: WatchlistCreateWithoutEpisodeWatchlistInput!
  where: WatchlistWhereUniqueInput!
}

input WatchlistCreateOrConnectWithoutMovieWatchlistInput {
  create: WatchlistCreateWithoutMovieWatchlistInput!
  where: WatchlistWhereUniqueInput!
}

input WatchlistCreateOrConnectWithoutSeriesWatchlistInput {
  create: WatchlistCreateWithoutSeriesWatchlistInput!
  where: WatchlistWhereUniqueInput!
}

input WatchlistCreateOrConnectWithoutUserInput {
  create: WatchlistCreateWithoutUserInput!
  where: WatchlistWhereUniqueInput!
}

input WatchlistCreateWithoutEpisodeWatchlistInput {
  createdAt: DateTime
  default: Boolean!
  movieWatchlist: MoviesWatchlistCreateNestedOneWithoutWatchlistInput
  name: String
  seriesWatchlist: SeriesWatchlistCreateNestedOneWithoutWatchlistInput
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutWatchlistInput!
}

input WatchlistCreateWithoutMovieWatchlistInput {
  createdAt: DateTime
  default: Boolean!
  episodeWatchlist: EpisodesWatchlistCreateNestedOneWithoutWatchlistInput
  name: String
  seriesWatchlist: SeriesWatchlistCreateNestedOneWithoutWatchlistInput
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutWatchlistInput!
}

input WatchlistCreateWithoutSeriesWatchlistInput {
  createdAt: DateTime
  default: Boolean!
  episodeWatchlist: EpisodesWatchlistCreateNestedOneWithoutWatchlistInput
  movieWatchlist: MoviesWatchlistCreateNestedOneWithoutWatchlistInput
  name: String
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutWatchlistInput!
}

input WatchlistCreateWithoutUserInput {
  createdAt: DateTime
  default: Boolean!
  episodeWatchlist: EpisodesWatchlistCreateNestedOneWithoutWatchlistInput
  movieWatchlist: MoviesWatchlistCreateNestedOneWithoutWatchlistInput
  name: String
  seriesWatchlist: SeriesWatchlistCreateNestedOneWithoutWatchlistInput
  updatedAt: DateTime
}

type WatchlistGroupBy {
  _avg: WatchlistAvgAggregate
  _count: WatchlistCountAggregate
  _max: WatchlistMaxAggregate
  _min: WatchlistMinAggregate
  _sum: WatchlistSumAggregate
  createdAt: DateTime!
  default: Boolean!
  id: Int!
  name: String
  updatedAt: DateTime!
  userId: String!
}

input WatchlistListRelationFilter {
  every: WatchlistWhereInput
  none: WatchlistWhereInput
  some: WatchlistWhereInput
}

type WatchlistMaxAggregate {
  createdAt: DateTime
  default: Boolean
  id: Int
  name: String
  updatedAt: DateTime
  userId: String
}

input WatchlistMaxOrderByAggregateInput {
  createdAt: SortOrder
  default: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

type WatchlistMinAggregate {
  createdAt: DateTime
  default: Boolean
  id: Int
  name: String
  updatedAt: DateTime
  userId: String
}

input WatchlistMinOrderByAggregateInput {
  createdAt: SortOrder
  default: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input WatchlistOrderByRelationAggregateInput {
  _count: SortOrder
}

enum WatchlistOrderByRelevanceFieldEnum {
  name
  userId
}

input WatchlistOrderByRelevanceInput {
  fields: [WatchlistOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input WatchlistOrderByWithAggregationInput {
  _avg: WatchlistAvgOrderByAggregateInput
  _count: WatchlistCountOrderByAggregateInput
  _max: WatchlistMaxOrderByAggregateInput
  _min: WatchlistMinOrderByAggregateInput
  _sum: WatchlistSumOrderByAggregateInput
  createdAt: SortOrder
  default: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input WatchlistOrderByWithRelationAndSearchRelevanceInput {
  _relevance: WatchlistOrderByRelevanceInput
  createdAt: SortOrder
  default: SortOrder
  episodeWatchlist: EpisodesWatchlistOrderByWithRelationAndSearchRelevanceInput
  id: SortOrder
  movieWatchlist: MoviesWatchlistOrderByWithRelationAndSearchRelevanceInput
  name: SortOrder
  seriesWatchlist: SeriesWatchlistOrderByWithRelationAndSearchRelevanceInput
  updatedAt: SortOrder
  user: UserOrderByWithRelationAndSearchRelevanceInput
  userId: SortOrder
}

input WatchlistRelationFilter {
  is: WatchlistWhereInput
  isNot: WatchlistWhereInput
}

enum WatchlistScalarFieldEnum {
  createdAt
  default
  id
  name
  updatedAt
  userId
}

input WatchlistScalarWhereInput {
  AND: [WatchlistScalarWhereInput!]
  NOT: [WatchlistScalarWhereInput!]
  OR: [WatchlistScalarWhereInput!]
  createdAt: DateTimeFilter
  default: BoolFilter
  id: IntFilter
  name: StringNullableFilter
  updatedAt: DateTimeFilter
  userId: StringFilter
}

input WatchlistScalarWhereWithAggregatesInput {
  AND: [WatchlistScalarWhereWithAggregatesInput!]
  NOT: [WatchlistScalarWhereWithAggregatesInput!]
  OR: [WatchlistScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  default: BoolWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringNullableWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: StringWithAggregatesFilter
}

type WatchlistSumAggregate {
  id: Int
}

input WatchlistSumOrderByAggregateInput {
  id: SortOrder
}

input WatchlistUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  default: BoolFieldUpdateOperationsInput
  episodeWatchlist: EpisodesWatchlistUpdateOneWithoutWatchlistInput
  movieWatchlist: MoviesWatchlistUpdateOneWithoutWatchlistInput
  name: NullableStringFieldUpdateOperationsInput
  seriesWatchlist: SeriesWatchlistUpdateOneWithoutWatchlistInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutWatchlistInput
}

input WatchlistUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  default: BoolFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input WatchlistUpdateManyWithWhereWithoutUserInput {
  data: WatchlistUpdateManyMutationInput!
  where: WatchlistScalarWhereInput!
}

input WatchlistUpdateManyWithoutUserInput {
  connect: [WatchlistWhereUniqueInput!]
  connectOrCreate: [WatchlistCreateOrConnectWithoutUserInput!]
  create: [WatchlistCreateWithoutUserInput!]
  createMany: WatchlistCreateManyUserInputEnvelope
  delete: [WatchlistWhereUniqueInput!]
  deleteMany: [WatchlistScalarWhereInput!]
  disconnect: [WatchlistWhereUniqueInput!]
  set: [WatchlistWhereUniqueInput!]
  update: [WatchlistUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [WatchlistUpdateManyWithWhereWithoutUserInput!]
  upsert: [WatchlistUpsertWithWhereUniqueWithoutUserInput!]
}

input WatchlistUpdateOneRequiredWithoutEpisodeWatchlistInput {
  connect: WatchlistWhereUniqueInput
  connectOrCreate: WatchlistCreateOrConnectWithoutEpisodeWatchlistInput
  create: WatchlistCreateWithoutEpisodeWatchlistInput
  update: WatchlistUpdateWithoutEpisodeWatchlistInput
  upsert: WatchlistUpsertWithoutEpisodeWatchlistInput
}

input WatchlistUpdateOneRequiredWithoutMovieWatchlistInput {
  connect: WatchlistWhereUniqueInput
  connectOrCreate: WatchlistCreateOrConnectWithoutMovieWatchlistInput
  create: WatchlistCreateWithoutMovieWatchlistInput
  update: WatchlistUpdateWithoutMovieWatchlistInput
  upsert: WatchlistUpsertWithoutMovieWatchlistInput
}

input WatchlistUpdateOneRequiredWithoutSeriesWatchlistInput {
  connect: WatchlistWhereUniqueInput
  connectOrCreate: WatchlistCreateOrConnectWithoutSeriesWatchlistInput
  create: WatchlistCreateWithoutSeriesWatchlistInput
  update: WatchlistUpdateWithoutSeriesWatchlistInput
  upsert: WatchlistUpsertWithoutSeriesWatchlistInput
}

input WatchlistUpdateWithWhereUniqueWithoutUserInput {
  data: WatchlistUpdateWithoutUserInput!
  where: WatchlistWhereUniqueInput!
}

input WatchlistUpdateWithoutEpisodeWatchlistInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  default: BoolFieldUpdateOperationsInput
  movieWatchlist: MoviesWatchlistUpdateOneWithoutWatchlistInput
  name: NullableStringFieldUpdateOperationsInput
  seriesWatchlist: SeriesWatchlistUpdateOneWithoutWatchlistInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutWatchlistInput
}

input WatchlistUpdateWithoutMovieWatchlistInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  default: BoolFieldUpdateOperationsInput
  episodeWatchlist: EpisodesWatchlistUpdateOneWithoutWatchlistInput
  name: NullableStringFieldUpdateOperationsInput
  seriesWatchlist: SeriesWatchlistUpdateOneWithoutWatchlistInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutWatchlistInput
}

input WatchlistUpdateWithoutSeriesWatchlistInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  default: BoolFieldUpdateOperationsInput
  episodeWatchlist: EpisodesWatchlistUpdateOneWithoutWatchlistInput
  movieWatchlist: MoviesWatchlistUpdateOneWithoutWatchlistInput
  name: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutWatchlistInput
}

input WatchlistUpdateWithoutUserInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  default: BoolFieldUpdateOperationsInput
  episodeWatchlist: EpisodesWatchlistUpdateOneWithoutWatchlistInput
  movieWatchlist: MoviesWatchlistUpdateOneWithoutWatchlistInput
  name: NullableStringFieldUpdateOperationsInput
  seriesWatchlist: SeriesWatchlistUpdateOneWithoutWatchlistInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input WatchlistUpsertWithWhereUniqueWithoutUserInput {
  create: WatchlistCreateWithoutUserInput!
  update: WatchlistUpdateWithoutUserInput!
  where: WatchlistWhereUniqueInput!
}

input WatchlistUpsertWithoutEpisodeWatchlistInput {
  create: WatchlistCreateWithoutEpisodeWatchlistInput!
  update: WatchlistUpdateWithoutEpisodeWatchlistInput!
}

input WatchlistUpsertWithoutMovieWatchlistInput {
  create: WatchlistCreateWithoutMovieWatchlistInput!
  update: WatchlistUpdateWithoutMovieWatchlistInput!
}

input WatchlistUpsertWithoutSeriesWatchlistInput {
  create: WatchlistCreateWithoutSeriesWatchlistInput!
  update: WatchlistUpdateWithoutSeriesWatchlistInput!
}

input WatchlistWhereInput {
  AND: [WatchlistWhereInput!]
  NOT: [WatchlistWhereInput!]
  OR: [WatchlistWhereInput!]
  createdAt: DateTimeFilter
  default: BoolFilter
  episodeWatchlist: EpisodesWatchlistRelationFilter
  id: IntFilter
  movieWatchlist: MoviesWatchlistRelationFilter
  name: StringNullableFilter
  seriesWatchlist: SeriesWatchlistRelationFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: StringFilter
}

input WatchlistWhereUniqueInput {
  id: Int
}

type WatchlistedEpisode {
  addedAt: DateTime!
  episode: Episode!
  episodeId: Int!
  seen: Boolean!
  seenAt: DateTime
  watchlist: EpisodesWatchlist!
  watchlistId: Int!
}

type WatchlistedEpisodeAvgAggregate {
  episodeId: Float
  watchlistId: Float
}

input WatchlistedEpisodeAvgOrderByAggregateInput {
  episodeId: SortOrder
  watchlistId: SortOrder
}

type WatchlistedEpisodeCountAggregate {
  _all: Int!
  addedAt: Int!
  episodeId: Int!
  seen: Int!
  seenAt: Int!
  watchlistId: Int!
}

input WatchlistedEpisodeCountOrderByAggregateInput {
  addedAt: SortOrder
  episodeId: SortOrder
  seen: SortOrder
  seenAt: SortOrder
  watchlistId: SortOrder
}

input WatchlistedEpisodeCreateInput {
  addedAt: DateTime
  episode: EpisodeCreateNestedOneWithoutWatchlistInput!
  seen: Boolean
  seenAt: DateTime
  watchlist: EpisodesWatchlistCreateNestedOneWithoutEpisodesInput!
}

input WatchlistedEpisodeCreateManyEpisodeInput {
  addedAt: DateTime
  seen: Boolean
  seenAt: DateTime
  watchlistId: Int!
}

input WatchlistedEpisodeCreateManyEpisodeInputEnvelope {
  data: [WatchlistedEpisodeCreateManyEpisodeInput!]!
  skipDuplicates: Boolean
}

input WatchlistedEpisodeCreateManyInput {
  addedAt: DateTime
  episodeId: Int!
  seen: Boolean
  seenAt: DateTime
  watchlistId: Int!
}

input WatchlistedEpisodeCreateManyWatchlistInput {
  addedAt: DateTime
  episodeId: Int!
  seen: Boolean
  seenAt: DateTime
}

input WatchlistedEpisodeCreateManyWatchlistInputEnvelope {
  data: [WatchlistedEpisodeCreateManyWatchlistInput!]!
  skipDuplicates: Boolean
}

input WatchlistedEpisodeCreateNestedManyWithoutEpisodeInput {
  connect: [WatchlistedEpisodeWhereUniqueInput!]
  connectOrCreate: [WatchlistedEpisodeCreateOrConnectWithoutEpisodeInput!]
  create: [WatchlistedEpisodeCreateWithoutEpisodeInput!]
  createMany: WatchlistedEpisodeCreateManyEpisodeInputEnvelope
}

input WatchlistedEpisodeCreateNestedManyWithoutWatchlistInput {
  connect: [WatchlistedEpisodeWhereUniqueInput!]
  connectOrCreate: [WatchlistedEpisodeCreateOrConnectWithoutWatchlistInput!]
  create: [WatchlistedEpisodeCreateWithoutWatchlistInput!]
  createMany: WatchlistedEpisodeCreateManyWatchlistInputEnvelope
}

input WatchlistedEpisodeCreateOrConnectWithoutEpisodeInput {
  create: WatchlistedEpisodeCreateWithoutEpisodeInput!
  where: WatchlistedEpisodeWhereUniqueInput!
}

input WatchlistedEpisodeCreateOrConnectWithoutWatchlistInput {
  create: WatchlistedEpisodeCreateWithoutWatchlistInput!
  where: WatchlistedEpisodeWhereUniqueInput!
}

input WatchlistedEpisodeCreateWithoutEpisodeInput {
  addedAt: DateTime
  seen: Boolean
  seenAt: DateTime
  watchlist: EpisodesWatchlistCreateNestedOneWithoutEpisodesInput!
}

input WatchlistedEpisodeCreateWithoutWatchlistInput {
  addedAt: DateTime
  episode: EpisodeCreateNestedOneWithoutWatchlistInput!
  seen: Boolean
  seenAt: DateTime
}

input WatchlistedEpisodeEpisodeIdWatchlistIdCompoundUniqueInput {
  episodeId: Int!
  watchlistId: Int!
}

type WatchlistedEpisodeGroupBy {
  _avg: WatchlistedEpisodeAvgAggregate
  _count: WatchlistedEpisodeCountAggregate
  _max: WatchlistedEpisodeMaxAggregate
  _min: WatchlistedEpisodeMinAggregate
  _sum: WatchlistedEpisodeSumAggregate
  addedAt: DateTime!
  episodeId: Int!
  seen: Boolean!
  seenAt: DateTime
  watchlistId: Int!
}

input WatchlistedEpisodeListRelationFilter {
  every: WatchlistedEpisodeWhereInput
  none: WatchlistedEpisodeWhereInput
  some: WatchlistedEpisodeWhereInput
}

type WatchlistedEpisodeMaxAggregate {
  addedAt: DateTime
  episodeId: Int
  seen: Boolean
  seenAt: DateTime
  watchlistId: Int
}

input WatchlistedEpisodeMaxOrderByAggregateInput {
  addedAt: SortOrder
  episodeId: SortOrder
  seen: SortOrder
  seenAt: SortOrder
  watchlistId: SortOrder
}

type WatchlistedEpisodeMinAggregate {
  addedAt: DateTime
  episodeId: Int
  seen: Boolean
  seenAt: DateTime
  watchlistId: Int
}

input WatchlistedEpisodeMinOrderByAggregateInput {
  addedAt: SortOrder
  episodeId: SortOrder
  seen: SortOrder
  seenAt: SortOrder
  watchlistId: SortOrder
}

input WatchlistedEpisodeOrderByRelationAggregateInput {
  _count: SortOrder
}

input WatchlistedEpisodeOrderByWithAggregationInput {
  _avg: WatchlistedEpisodeAvgOrderByAggregateInput
  _count: WatchlistedEpisodeCountOrderByAggregateInput
  _max: WatchlistedEpisodeMaxOrderByAggregateInput
  _min: WatchlistedEpisodeMinOrderByAggregateInput
  _sum: WatchlistedEpisodeSumOrderByAggregateInput
  addedAt: SortOrder
  episodeId: SortOrder
  seen: SortOrder
  seenAt: SortOrder
  watchlistId: SortOrder
}

input WatchlistedEpisodeOrderByWithRelationAndSearchRelevanceInput {
  addedAt: SortOrder
  episode: EpisodeOrderByWithRelationAndSearchRelevanceInput
  episodeId: SortOrder
  seen: SortOrder
  seenAt: SortOrder
  watchlist: EpisodesWatchlistOrderByWithRelationAndSearchRelevanceInput
  watchlistId: SortOrder
}

enum WatchlistedEpisodeScalarFieldEnum {
  addedAt
  episodeId
  seen
  seenAt
  watchlistId
}

input WatchlistedEpisodeScalarWhereInput {
  AND: [WatchlistedEpisodeScalarWhereInput!]
  NOT: [WatchlistedEpisodeScalarWhereInput!]
  OR: [WatchlistedEpisodeScalarWhereInput!]
  addedAt: DateTimeFilter
  episodeId: IntFilter
  seen: BoolFilter
  seenAt: DateTimeNullableFilter
  watchlistId: IntFilter
}

input WatchlistedEpisodeScalarWhereWithAggregatesInput {
  AND: [WatchlistedEpisodeScalarWhereWithAggregatesInput!]
  NOT: [WatchlistedEpisodeScalarWhereWithAggregatesInput!]
  OR: [WatchlistedEpisodeScalarWhereWithAggregatesInput!]
  addedAt: DateTimeWithAggregatesFilter
  episodeId: IntWithAggregatesFilter
  seen: BoolWithAggregatesFilter
  seenAt: DateTimeNullableWithAggregatesFilter
  watchlistId: IntWithAggregatesFilter
}

type WatchlistedEpisodeSumAggregate {
  episodeId: Int
  watchlistId: Int
}

input WatchlistedEpisodeSumOrderByAggregateInput {
  episodeId: SortOrder
  watchlistId: SortOrder
}

input WatchlistedEpisodeUpdateInput {
  addedAt: DateTimeFieldUpdateOperationsInput
  episode: EpisodeUpdateOneRequiredWithoutWatchlistInput
  seen: BoolFieldUpdateOperationsInput
  seenAt: NullableDateTimeFieldUpdateOperationsInput
  watchlist: EpisodesWatchlistUpdateOneRequiredWithoutEpisodesInput
}

input WatchlistedEpisodeUpdateManyMutationInput {
  addedAt: DateTimeFieldUpdateOperationsInput
  seen: BoolFieldUpdateOperationsInput
  seenAt: NullableDateTimeFieldUpdateOperationsInput
}

input WatchlistedEpisodeUpdateManyWithWhereWithoutEpisodeInput {
  data: WatchlistedEpisodeUpdateManyMutationInput!
  where: WatchlistedEpisodeScalarWhereInput!
}

input WatchlistedEpisodeUpdateManyWithWhereWithoutWatchlistInput {
  data: WatchlistedEpisodeUpdateManyMutationInput!
  where: WatchlistedEpisodeScalarWhereInput!
}

input WatchlistedEpisodeUpdateManyWithoutEpisodeInput {
  connect: [WatchlistedEpisodeWhereUniqueInput!]
  connectOrCreate: [WatchlistedEpisodeCreateOrConnectWithoutEpisodeInput!]
  create: [WatchlistedEpisodeCreateWithoutEpisodeInput!]
  createMany: WatchlistedEpisodeCreateManyEpisodeInputEnvelope
  delete: [WatchlistedEpisodeWhereUniqueInput!]
  deleteMany: [WatchlistedEpisodeScalarWhereInput!]
  disconnect: [WatchlistedEpisodeWhereUniqueInput!]
  set: [WatchlistedEpisodeWhereUniqueInput!]
  update: [WatchlistedEpisodeUpdateWithWhereUniqueWithoutEpisodeInput!]
  updateMany: [WatchlistedEpisodeUpdateManyWithWhereWithoutEpisodeInput!]
  upsert: [WatchlistedEpisodeUpsertWithWhereUniqueWithoutEpisodeInput!]
}

input WatchlistedEpisodeUpdateManyWithoutWatchlistInput {
  connect: [WatchlistedEpisodeWhereUniqueInput!]
  connectOrCreate: [WatchlistedEpisodeCreateOrConnectWithoutWatchlistInput!]
  create: [WatchlistedEpisodeCreateWithoutWatchlistInput!]
  createMany: WatchlistedEpisodeCreateManyWatchlistInputEnvelope
  delete: [WatchlistedEpisodeWhereUniqueInput!]
  deleteMany: [WatchlistedEpisodeScalarWhereInput!]
  disconnect: [WatchlistedEpisodeWhereUniqueInput!]
  set: [WatchlistedEpisodeWhereUniqueInput!]
  update: [WatchlistedEpisodeUpdateWithWhereUniqueWithoutWatchlistInput!]
  updateMany: [WatchlistedEpisodeUpdateManyWithWhereWithoutWatchlistInput!]
  upsert: [WatchlistedEpisodeUpsertWithWhereUniqueWithoutWatchlistInput!]
}

input WatchlistedEpisodeUpdateWithWhereUniqueWithoutEpisodeInput {
  data: WatchlistedEpisodeUpdateWithoutEpisodeInput!
  where: WatchlistedEpisodeWhereUniqueInput!
}

input WatchlistedEpisodeUpdateWithWhereUniqueWithoutWatchlistInput {
  data: WatchlistedEpisodeUpdateWithoutWatchlistInput!
  where: WatchlistedEpisodeWhereUniqueInput!
}

input WatchlistedEpisodeUpdateWithoutEpisodeInput {
  addedAt: DateTimeFieldUpdateOperationsInput
  seen: BoolFieldUpdateOperationsInput
  seenAt: NullableDateTimeFieldUpdateOperationsInput
  watchlist: EpisodesWatchlistUpdateOneRequiredWithoutEpisodesInput
}

input WatchlistedEpisodeUpdateWithoutWatchlistInput {
  addedAt: DateTimeFieldUpdateOperationsInput
  episode: EpisodeUpdateOneRequiredWithoutWatchlistInput
  seen: BoolFieldUpdateOperationsInput
  seenAt: NullableDateTimeFieldUpdateOperationsInput
}

input WatchlistedEpisodeUpsertWithWhereUniqueWithoutEpisodeInput {
  create: WatchlistedEpisodeCreateWithoutEpisodeInput!
  update: WatchlistedEpisodeUpdateWithoutEpisodeInput!
  where: WatchlistedEpisodeWhereUniqueInput!
}

input WatchlistedEpisodeUpsertWithWhereUniqueWithoutWatchlistInput {
  create: WatchlistedEpisodeCreateWithoutWatchlistInput!
  update: WatchlistedEpisodeUpdateWithoutWatchlistInput!
  where: WatchlistedEpisodeWhereUniqueInput!
}

input WatchlistedEpisodeWhereInput {
  AND: [WatchlistedEpisodeWhereInput!]
  NOT: [WatchlistedEpisodeWhereInput!]
  OR: [WatchlistedEpisodeWhereInput!]
  addedAt: DateTimeFilter
  episode: EpisodeRelationFilter
  episodeId: IntFilter
  seen: BoolFilter
  seenAt: DateTimeNullableFilter
  watchlist: EpisodesWatchlistRelationFilter
  watchlistId: IntFilter
}

input WatchlistedEpisodeWhereUniqueInput {
  episodeId_watchlistId: WatchlistedEpisodeEpisodeIdWatchlistIdCompoundUniqueInput
}

type WatchlistedMovie {
  addedAt: DateTime!
  movie: Movie!
  movieId: Int!
  seen: Boolean!
  seenAt: DateTime
  watchlist: MoviesWatchlist!
  watchlistId: Int!
}

type WatchlistedMovieAvgAggregate {
  movieId: Float
  watchlistId: Float
}

input WatchlistedMovieAvgOrderByAggregateInput {
  movieId: SortOrder
  watchlistId: SortOrder
}

type WatchlistedMovieCountAggregate {
  _all: Int!
  addedAt: Int!
  movieId: Int!
  seen: Int!
  seenAt: Int!
  watchlistId: Int!
}

input WatchlistedMovieCountOrderByAggregateInput {
  addedAt: SortOrder
  movieId: SortOrder
  seen: SortOrder
  seenAt: SortOrder
  watchlistId: SortOrder
}

input WatchlistedMovieCreateInput {
  addedAt: DateTime
  movie: MovieCreateNestedOneWithoutWatchlistInput!
  seen: Boolean
  seenAt: DateTime
  watchlist: MoviesWatchlistCreateNestedOneWithoutMoviesInput!
}

input WatchlistedMovieCreateManyInput {
  addedAt: DateTime
  movieId: Int!
  seen: Boolean
  seenAt: DateTime
  watchlistId: Int!
}

input WatchlistedMovieCreateManyMovieInput {
  addedAt: DateTime
  seen: Boolean
  seenAt: DateTime
  watchlistId: Int!
}

input WatchlistedMovieCreateManyMovieInputEnvelope {
  data: [WatchlistedMovieCreateManyMovieInput!]!
  skipDuplicates: Boolean
}

input WatchlistedMovieCreateManyWatchlistInput {
  addedAt: DateTime
  movieId: Int!
  seen: Boolean
  seenAt: DateTime
}

input WatchlistedMovieCreateManyWatchlistInputEnvelope {
  data: [WatchlistedMovieCreateManyWatchlistInput!]!
  skipDuplicates: Boolean
}

input WatchlistedMovieCreateNestedManyWithoutMovieInput {
  connect: [WatchlistedMovieWhereUniqueInput!]
  connectOrCreate: [WatchlistedMovieCreateOrConnectWithoutMovieInput!]
  create: [WatchlistedMovieCreateWithoutMovieInput!]
  createMany: WatchlistedMovieCreateManyMovieInputEnvelope
}

input WatchlistedMovieCreateNestedManyWithoutWatchlistInput {
  connect: [WatchlistedMovieWhereUniqueInput!]
  connectOrCreate: [WatchlistedMovieCreateOrConnectWithoutWatchlistInput!]
  create: [WatchlistedMovieCreateWithoutWatchlistInput!]
  createMany: WatchlistedMovieCreateManyWatchlistInputEnvelope
}

input WatchlistedMovieCreateOrConnectWithoutMovieInput {
  create: WatchlistedMovieCreateWithoutMovieInput!
  where: WatchlistedMovieWhereUniqueInput!
}

input WatchlistedMovieCreateOrConnectWithoutWatchlistInput {
  create: WatchlistedMovieCreateWithoutWatchlistInput!
  where: WatchlistedMovieWhereUniqueInput!
}

input WatchlistedMovieCreateWithoutMovieInput {
  addedAt: DateTime
  seen: Boolean
  seenAt: DateTime
  watchlist: MoviesWatchlistCreateNestedOneWithoutMoviesInput!
}

input WatchlistedMovieCreateWithoutWatchlistInput {
  addedAt: DateTime
  movie: MovieCreateNestedOneWithoutWatchlistInput!
  seen: Boolean
  seenAt: DateTime
}

type WatchlistedMovieGroupBy {
  _avg: WatchlistedMovieAvgAggregate
  _count: WatchlistedMovieCountAggregate
  _max: WatchlistedMovieMaxAggregate
  _min: WatchlistedMovieMinAggregate
  _sum: WatchlistedMovieSumAggregate
  addedAt: DateTime!
  movieId: Int!
  seen: Boolean!
  seenAt: DateTime
  watchlistId: Int!
}

input WatchlistedMovieListRelationFilter {
  every: WatchlistedMovieWhereInput
  none: WatchlistedMovieWhereInput
  some: WatchlistedMovieWhereInput
}

type WatchlistedMovieMaxAggregate {
  addedAt: DateTime
  movieId: Int
  seen: Boolean
  seenAt: DateTime
  watchlistId: Int
}

input WatchlistedMovieMaxOrderByAggregateInput {
  addedAt: SortOrder
  movieId: SortOrder
  seen: SortOrder
  seenAt: SortOrder
  watchlistId: SortOrder
}

type WatchlistedMovieMinAggregate {
  addedAt: DateTime
  movieId: Int
  seen: Boolean
  seenAt: DateTime
  watchlistId: Int
}

input WatchlistedMovieMinOrderByAggregateInput {
  addedAt: SortOrder
  movieId: SortOrder
  seen: SortOrder
  seenAt: SortOrder
  watchlistId: SortOrder
}

input WatchlistedMovieMovieIdWatchlistIdCompoundUniqueInput {
  movieId: Int!
  watchlistId: Int!
}

input WatchlistedMovieOrderByRelationAggregateInput {
  _count: SortOrder
}

input WatchlistedMovieOrderByWithAggregationInput {
  _avg: WatchlistedMovieAvgOrderByAggregateInput
  _count: WatchlistedMovieCountOrderByAggregateInput
  _max: WatchlistedMovieMaxOrderByAggregateInput
  _min: WatchlistedMovieMinOrderByAggregateInput
  _sum: WatchlistedMovieSumOrderByAggregateInput
  addedAt: SortOrder
  movieId: SortOrder
  seen: SortOrder
  seenAt: SortOrder
  watchlistId: SortOrder
}

input WatchlistedMovieOrderByWithRelationAndSearchRelevanceInput {
  addedAt: SortOrder
  movie: MovieOrderByWithRelationAndSearchRelevanceInput
  movieId: SortOrder
  seen: SortOrder
  seenAt: SortOrder
  watchlist: MoviesWatchlistOrderByWithRelationAndSearchRelevanceInput
  watchlistId: SortOrder
}

enum WatchlistedMovieScalarFieldEnum {
  addedAt
  movieId
  seen
  seenAt
  watchlistId
}

input WatchlistedMovieScalarWhereInput {
  AND: [WatchlistedMovieScalarWhereInput!]
  NOT: [WatchlistedMovieScalarWhereInput!]
  OR: [WatchlistedMovieScalarWhereInput!]
  addedAt: DateTimeFilter
  movieId: IntFilter
  seen: BoolFilter
  seenAt: DateTimeNullableFilter
  watchlistId: IntFilter
}

input WatchlistedMovieScalarWhereWithAggregatesInput {
  AND: [WatchlistedMovieScalarWhereWithAggregatesInput!]
  NOT: [WatchlistedMovieScalarWhereWithAggregatesInput!]
  OR: [WatchlistedMovieScalarWhereWithAggregatesInput!]
  addedAt: DateTimeWithAggregatesFilter
  movieId: IntWithAggregatesFilter
  seen: BoolWithAggregatesFilter
  seenAt: DateTimeNullableWithAggregatesFilter
  watchlistId: IntWithAggregatesFilter
}

type WatchlistedMovieSumAggregate {
  movieId: Int
  watchlistId: Int
}

input WatchlistedMovieSumOrderByAggregateInput {
  movieId: SortOrder
  watchlistId: SortOrder
}

input WatchlistedMovieUpdateInput {
  addedAt: DateTimeFieldUpdateOperationsInput
  movie: MovieUpdateOneRequiredWithoutWatchlistInput
  seen: BoolFieldUpdateOperationsInput
  seenAt: NullableDateTimeFieldUpdateOperationsInput
  watchlist: MoviesWatchlistUpdateOneRequiredWithoutMoviesInput
}

input WatchlistedMovieUpdateManyMutationInput {
  addedAt: DateTimeFieldUpdateOperationsInput
  seen: BoolFieldUpdateOperationsInput
  seenAt: NullableDateTimeFieldUpdateOperationsInput
}

input WatchlistedMovieUpdateManyWithWhereWithoutMovieInput {
  data: WatchlistedMovieUpdateManyMutationInput!
  where: WatchlistedMovieScalarWhereInput!
}

input WatchlistedMovieUpdateManyWithWhereWithoutWatchlistInput {
  data: WatchlistedMovieUpdateManyMutationInput!
  where: WatchlistedMovieScalarWhereInput!
}

input WatchlistedMovieUpdateManyWithoutMovieInput {
  connect: [WatchlistedMovieWhereUniqueInput!]
  connectOrCreate: [WatchlistedMovieCreateOrConnectWithoutMovieInput!]
  create: [WatchlistedMovieCreateWithoutMovieInput!]
  createMany: WatchlistedMovieCreateManyMovieInputEnvelope
  delete: [WatchlistedMovieWhereUniqueInput!]
  deleteMany: [WatchlistedMovieScalarWhereInput!]
  disconnect: [WatchlistedMovieWhereUniqueInput!]
  set: [WatchlistedMovieWhereUniqueInput!]
  update: [WatchlistedMovieUpdateWithWhereUniqueWithoutMovieInput!]
  updateMany: [WatchlistedMovieUpdateManyWithWhereWithoutMovieInput!]
  upsert: [WatchlistedMovieUpsertWithWhereUniqueWithoutMovieInput!]
}

input WatchlistedMovieUpdateManyWithoutWatchlistInput {
  connect: [WatchlistedMovieWhereUniqueInput!]
  connectOrCreate: [WatchlistedMovieCreateOrConnectWithoutWatchlistInput!]
  create: [WatchlistedMovieCreateWithoutWatchlistInput!]
  createMany: WatchlistedMovieCreateManyWatchlistInputEnvelope
  delete: [WatchlistedMovieWhereUniqueInput!]
  deleteMany: [WatchlistedMovieScalarWhereInput!]
  disconnect: [WatchlistedMovieWhereUniqueInput!]
  set: [WatchlistedMovieWhereUniqueInput!]
  update: [WatchlistedMovieUpdateWithWhereUniqueWithoutWatchlistInput!]
  updateMany: [WatchlistedMovieUpdateManyWithWhereWithoutWatchlistInput!]
  upsert: [WatchlistedMovieUpsertWithWhereUniqueWithoutWatchlistInput!]
}

input WatchlistedMovieUpdateWithWhereUniqueWithoutMovieInput {
  data: WatchlistedMovieUpdateWithoutMovieInput!
  where: WatchlistedMovieWhereUniqueInput!
}

input WatchlistedMovieUpdateWithWhereUniqueWithoutWatchlistInput {
  data: WatchlistedMovieUpdateWithoutWatchlistInput!
  where: WatchlistedMovieWhereUniqueInput!
}

input WatchlistedMovieUpdateWithoutMovieInput {
  addedAt: DateTimeFieldUpdateOperationsInput
  seen: BoolFieldUpdateOperationsInput
  seenAt: NullableDateTimeFieldUpdateOperationsInput
  watchlist: MoviesWatchlistUpdateOneRequiredWithoutMoviesInput
}

input WatchlistedMovieUpdateWithoutWatchlistInput {
  addedAt: DateTimeFieldUpdateOperationsInput
  movie: MovieUpdateOneRequiredWithoutWatchlistInput
  seen: BoolFieldUpdateOperationsInput
  seenAt: NullableDateTimeFieldUpdateOperationsInput
}

input WatchlistedMovieUpsertWithWhereUniqueWithoutMovieInput {
  create: WatchlistedMovieCreateWithoutMovieInput!
  update: WatchlistedMovieUpdateWithoutMovieInput!
  where: WatchlistedMovieWhereUniqueInput!
}

input WatchlistedMovieUpsertWithWhereUniqueWithoutWatchlistInput {
  create: WatchlistedMovieCreateWithoutWatchlistInput!
  update: WatchlistedMovieUpdateWithoutWatchlistInput!
  where: WatchlistedMovieWhereUniqueInput!
}

input WatchlistedMovieWhereInput {
  AND: [WatchlistedMovieWhereInput!]
  NOT: [WatchlistedMovieWhereInput!]
  OR: [WatchlistedMovieWhereInput!]
  addedAt: DateTimeFilter
  movie: MovieRelationFilter
  movieId: IntFilter
  seen: BoolFilter
  seenAt: DateTimeNullableFilter
  watchlist: MoviesWatchlistRelationFilter
  watchlistId: IntFilter
}

input WatchlistedMovieWhereUniqueInput {
  movieId_watchlistId: WatchlistedMovieMovieIdWatchlistIdCompoundUniqueInput
}

type WatchlistedSerie {
  addedAt: DateTime!
  seen: Boolean!
  seenAt: DateTime
  serie: Serie!
  serieId: Int!
  watchlist: SeriesWatchlist!
  watchlistId: Int!
}

type WatchlistedSerieAvgAggregate {
  serieId: Float
  watchlistId: Float
}

input WatchlistedSerieAvgOrderByAggregateInput {
  serieId: SortOrder
  watchlistId: SortOrder
}

type WatchlistedSerieCountAggregate {
  _all: Int!
  addedAt: Int!
  seen: Int!
  seenAt: Int!
  serieId: Int!
  watchlistId: Int!
}

input WatchlistedSerieCountOrderByAggregateInput {
  addedAt: SortOrder
  seen: SortOrder
  seenAt: SortOrder
  serieId: SortOrder
  watchlistId: SortOrder
}

input WatchlistedSerieCreateInput {
  addedAt: DateTime
  seen: Boolean
  seenAt: DateTime
  serie: SerieCreateNestedOneWithoutWatchlistInput!
  watchlist: SeriesWatchlistCreateNestedOneWithoutSeriesInput!
}

input WatchlistedSerieCreateManyInput {
  addedAt: DateTime
  seen: Boolean
  seenAt: DateTime
  serieId: Int!
  watchlistId: Int!
}

input WatchlistedSerieCreateManySerieInput {
  addedAt: DateTime
  seen: Boolean
  seenAt: DateTime
  watchlistId: Int!
}

input WatchlistedSerieCreateManySerieInputEnvelope {
  data: [WatchlistedSerieCreateManySerieInput!]!
  skipDuplicates: Boolean
}

input WatchlistedSerieCreateManyWatchlistInput {
  addedAt: DateTime
  seen: Boolean
  seenAt: DateTime
  serieId: Int!
}

input WatchlistedSerieCreateManyWatchlistInputEnvelope {
  data: [WatchlistedSerieCreateManyWatchlistInput!]!
  skipDuplicates: Boolean
}

input WatchlistedSerieCreateNestedManyWithoutSerieInput {
  connect: [WatchlistedSerieWhereUniqueInput!]
  connectOrCreate: [WatchlistedSerieCreateOrConnectWithoutSerieInput!]
  create: [WatchlistedSerieCreateWithoutSerieInput!]
  createMany: WatchlistedSerieCreateManySerieInputEnvelope
}

input WatchlistedSerieCreateNestedManyWithoutWatchlistInput {
  connect: [WatchlistedSerieWhereUniqueInput!]
  connectOrCreate: [WatchlistedSerieCreateOrConnectWithoutWatchlistInput!]
  create: [WatchlistedSerieCreateWithoutWatchlistInput!]
  createMany: WatchlistedSerieCreateManyWatchlistInputEnvelope
}

input WatchlistedSerieCreateOrConnectWithoutSerieInput {
  create: WatchlistedSerieCreateWithoutSerieInput!
  where: WatchlistedSerieWhereUniqueInput!
}

input WatchlistedSerieCreateOrConnectWithoutWatchlistInput {
  create: WatchlistedSerieCreateWithoutWatchlistInput!
  where: WatchlistedSerieWhereUniqueInput!
}

input WatchlistedSerieCreateWithoutSerieInput {
  addedAt: DateTime
  seen: Boolean
  seenAt: DateTime
  watchlist: SeriesWatchlistCreateNestedOneWithoutSeriesInput!
}

input WatchlistedSerieCreateWithoutWatchlistInput {
  addedAt: DateTime
  seen: Boolean
  seenAt: DateTime
  serie: SerieCreateNestedOneWithoutWatchlistInput!
}

type WatchlistedSerieGroupBy {
  _avg: WatchlistedSerieAvgAggregate
  _count: WatchlistedSerieCountAggregate
  _max: WatchlistedSerieMaxAggregate
  _min: WatchlistedSerieMinAggregate
  _sum: WatchlistedSerieSumAggregate
  addedAt: DateTime!
  seen: Boolean!
  seenAt: DateTime
  serieId: Int!
  watchlistId: Int!
}

input WatchlistedSerieListRelationFilter {
  every: WatchlistedSerieWhereInput
  none: WatchlistedSerieWhereInput
  some: WatchlistedSerieWhereInput
}

type WatchlistedSerieMaxAggregate {
  addedAt: DateTime
  seen: Boolean
  seenAt: DateTime
  serieId: Int
  watchlistId: Int
}

input WatchlistedSerieMaxOrderByAggregateInput {
  addedAt: SortOrder
  seen: SortOrder
  seenAt: SortOrder
  serieId: SortOrder
  watchlistId: SortOrder
}

type WatchlistedSerieMinAggregate {
  addedAt: DateTime
  seen: Boolean
  seenAt: DateTime
  serieId: Int
  watchlistId: Int
}

input WatchlistedSerieMinOrderByAggregateInput {
  addedAt: SortOrder
  seen: SortOrder
  seenAt: SortOrder
  serieId: SortOrder
  watchlistId: SortOrder
}

input WatchlistedSerieOrderByRelationAggregateInput {
  _count: SortOrder
}

input WatchlistedSerieOrderByWithAggregationInput {
  _avg: WatchlistedSerieAvgOrderByAggregateInput
  _count: WatchlistedSerieCountOrderByAggregateInput
  _max: WatchlistedSerieMaxOrderByAggregateInput
  _min: WatchlistedSerieMinOrderByAggregateInput
  _sum: WatchlistedSerieSumOrderByAggregateInput
  addedAt: SortOrder
  seen: SortOrder
  seenAt: SortOrder
  serieId: SortOrder
  watchlistId: SortOrder
}

input WatchlistedSerieOrderByWithRelationAndSearchRelevanceInput {
  addedAt: SortOrder
  seen: SortOrder
  seenAt: SortOrder
  serie: SerieOrderByWithRelationAndSearchRelevanceInput
  serieId: SortOrder
  watchlist: SeriesWatchlistOrderByWithRelationAndSearchRelevanceInput
  watchlistId: SortOrder
}

enum WatchlistedSerieScalarFieldEnum {
  addedAt
  seen
  seenAt
  serieId
  watchlistId
}

input WatchlistedSerieScalarWhereInput {
  AND: [WatchlistedSerieScalarWhereInput!]
  NOT: [WatchlistedSerieScalarWhereInput!]
  OR: [WatchlistedSerieScalarWhereInput!]
  addedAt: DateTimeFilter
  seen: BoolFilter
  seenAt: DateTimeNullableFilter
  serieId: IntFilter
  watchlistId: IntFilter
}

input WatchlistedSerieScalarWhereWithAggregatesInput {
  AND: [WatchlistedSerieScalarWhereWithAggregatesInput!]
  NOT: [WatchlistedSerieScalarWhereWithAggregatesInput!]
  OR: [WatchlistedSerieScalarWhereWithAggregatesInput!]
  addedAt: DateTimeWithAggregatesFilter
  seen: BoolWithAggregatesFilter
  seenAt: DateTimeNullableWithAggregatesFilter
  serieId: IntWithAggregatesFilter
  watchlistId: IntWithAggregatesFilter
}

input WatchlistedSerieSerieIdWatchlistIdCompoundUniqueInput {
  serieId: Int!
  watchlistId: Int!
}

type WatchlistedSerieSumAggregate {
  serieId: Int
  watchlistId: Int
}

input WatchlistedSerieSumOrderByAggregateInput {
  serieId: SortOrder
  watchlistId: SortOrder
}

input WatchlistedSerieUpdateInput {
  addedAt: DateTimeFieldUpdateOperationsInput
  seen: BoolFieldUpdateOperationsInput
  seenAt: NullableDateTimeFieldUpdateOperationsInput
  serie: SerieUpdateOneRequiredWithoutWatchlistInput
  watchlist: SeriesWatchlistUpdateOneRequiredWithoutSeriesInput
}

input WatchlistedSerieUpdateManyMutationInput {
  addedAt: DateTimeFieldUpdateOperationsInput
  seen: BoolFieldUpdateOperationsInput
  seenAt: NullableDateTimeFieldUpdateOperationsInput
}

input WatchlistedSerieUpdateManyWithWhereWithoutSerieInput {
  data: WatchlistedSerieUpdateManyMutationInput!
  where: WatchlistedSerieScalarWhereInput!
}

input WatchlistedSerieUpdateManyWithWhereWithoutWatchlistInput {
  data: WatchlistedSerieUpdateManyMutationInput!
  where: WatchlistedSerieScalarWhereInput!
}

input WatchlistedSerieUpdateManyWithoutSerieInput {
  connect: [WatchlistedSerieWhereUniqueInput!]
  connectOrCreate: [WatchlistedSerieCreateOrConnectWithoutSerieInput!]
  create: [WatchlistedSerieCreateWithoutSerieInput!]
  createMany: WatchlistedSerieCreateManySerieInputEnvelope
  delete: [WatchlistedSerieWhereUniqueInput!]
  deleteMany: [WatchlistedSerieScalarWhereInput!]
  disconnect: [WatchlistedSerieWhereUniqueInput!]
  set: [WatchlistedSerieWhereUniqueInput!]
  update: [WatchlistedSerieUpdateWithWhereUniqueWithoutSerieInput!]
  updateMany: [WatchlistedSerieUpdateManyWithWhereWithoutSerieInput!]
  upsert: [WatchlistedSerieUpsertWithWhereUniqueWithoutSerieInput!]
}

input WatchlistedSerieUpdateManyWithoutWatchlistInput {
  connect: [WatchlistedSerieWhereUniqueInput!]
  connectOrCreate: [WatchlistedSerieCreateOrConnectWithoutWatchlistInput!]
  create: [WatchlistedSerieCreateWithoutWatchlistInput!]
  createMany: WatchlistedSerieCreateManyWatchlistInputEnvelope
  delete: [WatchlistedSerieWhereUniqueInput!]
  deleteMany: [WatchlistedSerieScalarWhereInput!]
  disconnect: [WatchlistedSerieWhereUniqueInput!]
  set: [WatchlistedSerieWhereUniqueInput!]
  update: [WatchlistedSerieUpdateWithWhereUniqueWithoutWatchlistInput!]
  updateMany: [WatchlistedSerieUpdateManyWithWhereWithoutWatchlistInput!]
  upsert: [WatchlistedSerieUpsertWithWhereUniqueWithoutWatchlistInput!]
}

input WatchlistedSerieUpdateWithWhereUniqueWithoutSerieInput {
  data: WatchlistedSerieUpdateWithoutSerieInput!
  where: WatchlistedSerieWhereUniqueInput!
}

input WatchlistedSerieUpdateWithWhereUniqueWithoutWatchlistInput {
  data: WatchlistedSerieUpdateWithoutWatchlistInput!
  where: WatchlistedSerieWhereUniqueInput!
}

input WatchlistedSerieUpdateWithoutSerieInput {
  addedAt: DateTimeFieldUpdateOperationsInput
  seen: BoolFieldUpdateOperationsInput
  seenAt: NullableDateTimeFieldUpdateOperationsInput
  watchlist: SeriesWatchlistUpdateOneRequiredWithoutSeriesInput
}

input WatchlistedSerieUpdateWithoutWatchlistInput {
  addedAt: DateTimeFieldUpdateOperationsInput
  seen: BoolFieldUpdateOperationsInput
  seenAt: NullableDateTimeFieldUpdateOperationsInput
  serie: SerieUpdateOneRequiredWithoutWatchlistInput
}

input WatchlistedSerieUpsertWithWhereUniqueWithoutSerieInput {
  create: WatchlistedSerieCreateWithoutSerieInput!
  update: WatchlistedSerieUpdateWithoutSerieInput!
  where: WatchlistedSerieWhereUniqueInput!
}

input WatchlistedSerieUpsertWithWhereUniqueWithoutWatchlistInput {
  create: WatchlistedSerieCreateWithoutWatchlistInput!
  update: WatchlistedSerieUpdateWithoutWatchlistInput!
  where: WatchlistedSerieWhereUniqueInput!
}

input WatchlistedSerieWhereInput {
  AND: [WatchlistedSerieWhereInput!]
  NOT: [WatchlistedSerieWhereInput!]
  OR: [WatchlistedSerieWhereInput!]
  addedAt: DateTimeFilter
  seen: BoolFilter
  seenAt: DateTimeNullableFilter
  serie: SerieRelationFilter
  serieId: IntFilter
  watchlist: SeriesWatchlistRelationFilter
  watchlistId: IntFilter
}

input WatchlistedSerieWhereUniqueInput {
  serieId_watchlistId: WatchlistedSerieSerieIdWatchlistIdCompoundUniqueInput
}
