# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type Account {
  access_token: String
  expires_at: Int
  id: String!
  id_token: String
  oauth_token: String
  oauth_token_secret: String
  provider: String!
  providerAccountId: String!
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String!
  user: User!
  userId: String!
}

type AccountAvgAggregate {
  expires_at: Float
}

input AccountAvgOrderByAggregateInput {
  expires_at: SortOrder
}

type AccountCountAggregate {
  _all: Int!
  access_token: Int!
  expires_at: Int!
  id: Int!
  id_token: Int!
  oauth_token: Int!
  oauth_token_secret: Int!
  provider: Int!
  providerAccountId: Int!
  refresh_token: Int!
  scope: Int!
  session_state: Int!
  token_type: Int!
  type: Int!
  userId: Int!
}

input AccountCountOrderByAggregateInput {
  access_token: SortOrder
  expires_at: SortOrder
  id: SortOrder
  id_token: SortOrder
  oauth_token: SortOrder
  oauth_token_secret: SortOrder
  provider: SortOrder
  providerAccountId: SortOrder
  refresh_token: SortOrder
  scope: SortOrder
  session_state: SortOrder
  token_type: SortOrder
  type: SortOrder
  userId: SortOrder
}

input AccountCreateInput {
  access_token: String
  expires_at: Int
  id: String
  id_token: String
  oauth_token: String
  oauth_token_secret: String
  provider: String!
  providerAccountId: String!
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String!
  user: UserCreateNestedOneWithoutAccountsInput!
}

input AccountCreateManyInput {
  access_token: String
  expires_at: Int
  id: String
  id_token: String
  oauth_token: String
  oauth_token_secret: String
  provider: String!
  providerAccountId: String!
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String!
  userId: String!
}

input AccountCreateManyUserInput {
  access_token: String
  expires_at: Int
  id: String
  id_token: String
  oauth_token: String
  oauth_token_secret: String
  provider: String!
  providerAccountId: String!
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String!
}

input AccountCreateManyUserInputEnvelope {
  data: [AccountCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input AccountCreateNestedManyWithoutUserInput {
  connect: [AccountWhereUniqueInput!]
  connectOrCreate: [AccountCreateOrConnectWithoutUserInput!]
  create: [AccountCreateWithoutUserInput!]
  createMany: AccountCreateManyUserInputEnvelope
}

input AccountCreateOrConnectWithoutUserInput {
  create: AccountCreateWithoutUserInput!
  where: AccountWhereUniqueInput!
}

input AccountCreateWithoutUserInput {
  access_token: String
  expires_at: Int
  id: String
  id_token: String
  oauth_token: String
  oauth_token_secret: String
  provider: String!
  providerAccountId: String!
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String!
}

type AccountGroupBy {
  _avg: AccountAvgAggregate
  _count: AccountCountAggregate
  _max: AccountMaxAggregate
  _min: AccountMinAggregate
  _sum: AccountSumAggregate
  access_token: String
  expires_at: Int
  id: String!
  id_token: String
  oauth_token: String
  oauth_token_secret: String
  provider: String!
  providerAccountId: String!
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String!
  userId: String!
}

input AccountListRelationFilter {
  every: AccountWhereInput
  none: AccountWhereInput
  some: AccountWhereInput
}

type AccountMaxAggregate {
  access_token: String
  expires_at: Int
  id: String
  id_token: String
  oauth_token: String
  oauth_token_secret: String
  provider: String
  providerAccountId: String
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String
  userId: String
}

input AccountMaxOrderByAggregateInput {
  access_token: SortOrder
  expires_at: SortOrder
  id: SortOrder
  id_token: SortOrder
  oauth_token: SortOrder
  oauth_token_secret: SortOrder
  provider: SortOrder
  providerAccountId: SortOrder
  refresh_token: SortOrder
  scope: SortOrder
  session_state: SortOrder
  token_type: SortOrder
  type: SortOrder
  userId: SortOrder
}

type AccountMinAggregate {
  access_token: String
  expires_at: Int
  id: String
  id_token: String
  oauth_token: String
  oauth_token_secret: String
  provider: String
  providerAccountId: String
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String
  userId: String
}

input AccountMinOrderByAggregateInput {
  access_token: SortOrder
  expires_at: SortOrder
  id: SortOrder
  id_token: SortOrder
  oauth_token: SortOrder
  oauth_token_secret: SortOrder
  provider: SortOrder
  providerAccountId: SortOrder
  refresh_token: SortOrder
  scope: SortOrder
  session_state: SortOrder
  token_type: SortOrder
  type: SortOrder
  userId: SortOrder
}

input AccountOrderByRelationAggregateInput {
  _count: SortOrder
}

enum AccountOrderByRelevanceFieldEnum {
  access_token
  id
  id_token
  oauth_token
  oauth_token_secret
  provider
  providerAccountId
  refresh_token
  scope
  session_state
  token_type
  type
  userId
}

input AccountOrderByRelevanceInput {
  fields: [AccountOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input AccountOrderByWithAggregationInput {
  _avg: AccountAvgOrderByAggregateInput
  _count: AccountCountOrderByAggregateInput
  _max: AccountMaxOrderByAggregateInput
  _min: AccountMinOrderByAggregateInput
  _sum: AccountSumOrderByAggregateInput
  access_token: SortOrder
  expires_at: SortOrder
  id: SortOrder
  id_token: SortOrder
  oauth_token: SortOrder
  oauth_token_secret: SortOrder
  provider: SortOrder
  providerAccountId: SortOrder
  refresh_token: SortOrder
  scope: SortOrder
  session_state: SortOrder
  token_type: SortOrder
  type: SortOrder
  userId: SortOrder
}

input AccountOrderByWithRelationAndSearchRelevanceInput {
  _relevance: AccountOrderByRelevanceInput
  access_token: SortOrder
  expires_at: SortOrder
  id: SortOrder
  id_token: SortOrder
  oauth_token: SortOrder
  oauth_token_secret: SortOrder
  provider: SortOrder
  providerAccountId: SortOrder
  refresh_token: SortOrder
  scope: SortOrder
  session_state: SortOrder
  token_type: SortOrder
  type: SortOrder
  user: UserOrderByWithRelationAndSearchRelevanceInput
  userId: SortOrder
}

input AccountProviderProviderAccountIdCompoundUniqueInput {
  provider: String!
  providerAccountId: String!
}

enum AccountScalarFieldEnum {
  access_token
  expires_at
  id
  id_token
  oauth_token
  oauth_token_secret
  provider
  providerAccountId
  refresh_token
  scope
  session_state
  token_type
  type
  userId
}

input AccountScalarWhereInput {
  AND: [AccountScalarWhereInput!]
  NOT: [AccountScalarWhereInput!]
  OR: [AccountScalarWhereInput!]
  access_token: StringNullableFilter
  expires_at: IntNullableFilter
  id: StringFilter
  id_token: StringNullableFilter
  oauth_token: StringNullableFilter
  oauth_token_secret: StringNullableFilter
  provider: StringFilter
  providerAccountId: StringFilter
  refresh_token: StringNullableFilter
  scope: StringNullableFilter
  session_state: StringNullableFilter
  token_type: StringNullableFilter
  type: StringFilter
  userId: StringFilter
}

input AccountScalarWhereWithAggregatesInput {
  AND: [AccountScalarWhereWithAggregatesInput!]
  NOT: [AccountScalarWhereWithAggregatesInput!]
  OR: [AccountScalarWhereWithAggregatesInput!]
  access_token: StringNullableWithAggregatesFilter
  expires_at: IntNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  id_token: StringNullableWithAggregatesFilter
  oauth_token: StringNullableWithAggregatesFilter
  oauth_token_secret: StringNullableWithAggregatesFilter
  provider: StringWithAggregatesFilter
  providerAccountId: StringWithAggregatesFilter
  refresh_token: StringNullableWithAggregatesFilter
  scope: StringNullableWithAggregatesFilter
  session_state: StringNullableWithAggregatesFilter
  token_type: StringNullableWithAggregatesFilter
  type: StringWithAggregatesFilter
  userId: StringWithAggregatesFilter
}

type AccountSumAggregate {
  expires_at: Int
}

input AccountSumOrderByAggregateInput {
  expires_at: SortOrder
}

input AccountUpdateInput {
  access_token: NullableStringFieldUpdateOperationsInput
  expires_at: NullableIntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  id_token: NullableStringFieldUpdateOperationsInput
  oauth_token: NullableStringFieldUpdateOperationsInput
  oauth_token_secret: NullableStringFieldUpdateOperationsInput
  provider: StringFieldUpdateOperationsInput
  providerAccountId: StringFieldUpdateOperationsInput
  refresh_token: NullableStringFieldUpdateOperationsInput
  scope: NullableStringFieldUpdateOperationsInput
  session_state: NullableStringFieldUpdateOperationsInput
  token_type: NullableStringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutAccountsInput
}

input AccountUpdateManyMutationInput {
  access_token: NullableStringFieldUpdateOperationsInput
  expires_at: NullableIntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  id_token: NullableStringFieldUpdateOperationsInput
  oauth_token: NullableStringFieldUpdateOperationsInput
  oauth_token_secret: NullableStringFieldUpdateOperationsInput
  provider: StringFieldUpdateOperationsInput
  providerAccountId: StringFieldUpdateOperationsInput
  refresh_token: NullableStringFieldUpdateOperationsInput
  scope: NullableStringFieldUpdateOperationsInput
  session_state: NullableStringFieldUpdateOperationsInput
  token_type: NullableStringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
}

input AccountUpdateManyWithWhereWithoutUserInput {
  data: AccountUpdateManyMutationInput!
  where: AccountScalarWhereInput!
}

input AccountUpdateManyWithoutUserInput {
  connect: [AccountWhereUniqueInput!]
  connectOrCreate: [AccountCreateOrConnectWithoutUserInput!]
  create: [AccountCreateWithoutUserInput!]
  createMany: AccountCreateManyUserInputEnvelope
  delete: [AccountWhereUniqueInput!]
  deleteMany: [AccountScalarWhereInput!]
  disconnect: [AccountWhereUniqueInput!]
  set: [AccountWhereUniqueInput!]
  update: [AccountUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [AccountUpdateManyWithWhereWithoutUserInput!]
  upsert: [AccountUpsertWithWhereUniqueWithoutUserInput!]
}

input AccountUpdateWithWhereUniqueWithoutUserInput {
  data: AccountUpdateWithoutUserInput!
  where: AccountWhereUniqueInput!
}

input AccountUpdateWithoutUserInput {
  access_token: NullableStringFieldUpdateOperationsInput
  expires_at: NullableIntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  id_token: NullableStringFieldUpdateOperationsInput
  oauth_token: NullableStringFieldUpdateOperationsInput
  oauth_token_secret: NullableStringFieldUpdateOperationsInput
  provider: StringFieldUpdateOperationsInput
  providerAccountId: StringFieldUpdateOperationsInput
  refresh_token: NullableStringFieldUpdateOperationsInput
  scope: NullableStringFieldUpdateOperationsInput
  session_state: NullableStringFieldUpdateOperationsInput
  token_type: NullableStringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
}

input AccountUpsertWithWhereUniqueWithoutUserInput {
  create: AccountCreateWithoutUserInput!
  update: AccountUpdateWithoutUserInput!
  where: AccountWhereUniqueInput!
}

input AccountWhereInput {
  AND: [AccountWhereInput!]
  NOT: [AccountWhereInput!]
  OR: [AccountWhereInput!]
  access_token: StringNullableFilter
  expires_at: IntNullableFilter
  id: StringFilter
  id_token: StringNullableFilter
  oauth_token: StringNullableFilter
  oauth_token_secret: StringNullableFilter
  provider: StringFilter
  providerAccountId: StringFilter
  refresh_token: StringNullableFilter
  scope: StringNullableFilter
  session_state: StringNullableFilter
  token_type: StringNullableFilter
  type: StringFilter
  user: UserRelationFilter
  userId: StringFilter
}

input AccountWhereUniqueInput {
  id: String
  provider_providerAccountId: AccountProviderProviderAccountIdCompoundUniqueInput
}

type Actor {
  _count: ActorCount
  createdAt: DateTime!
  id: Int!
  movies(cursor: MovieWhereUniqueInput, distinct: [MovieScalarFieldEnum!], orderBy: [MovieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: MovieWhereInput): [Movie!]!
  name: String!
  series: Serie
  seriesId: Int
  updatedAt: DateTime!
}

type ActorAvgAggregate {
  id: Float
  seriesId: Float
}

input ActorAvgOrderByAggregateInput {
  id: SortOrder
  seriesId: SortOrder
}

type ActorCount {
  movies: Int!
}

type ActorCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  name: Int!
  seriesId: Int!
  updatedAt: Int!
}

input ActorCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  seriesId: SortOrder
  updatedAt: SortOrder
}

input ActorCreateInput {
  createdAt: DateTime
  movies: MovieCreateNestedManyWithoutActorsInput
  name: String!
  series: SerieCreateNestedOneWithoutActorsInput
  updatedAt: DateTime
}

input ActorCreateManyInput {
  createdAt: DateTime
  id: Int
  name: String!
  seriesId: Int
  updatedAt: DateTime
}

input ActorCreateManySeriesInput {
  createdAt: DateTime
  id: Int
  name: String!
  updatedAt: DateTime
}

input ActorCreateManySeriesInputEnvelope {
  data: [ActorCreateManySeriesInput!]!
  skipDuplicates: Boolean
}

input ActorCreateNestedManyWithoutMoviesInput {
  connect: [ActorWhereUniqueInput!]
  connectOrCreate: [ActorCreateOrConnectWithoutMoviesInput!]
  create: [ActorCreateWithoutMoviesInput!]
}

input ActorCreateNestedManyWithoutSeriesInput {
  connect: [ActorWhereUniqueInput!]
  connectOrCreate: [ActorCreateOrConnectWithoutSeriesInput!]
  create: [ActorCreateWithoutSeriesInput!]
  createMany: ActorCreateManySeriesInputEnvelope
}

input ActorCreateOrConnectWithoutMoviesInput {
  create: ActorCreateWithoutMoviesInput!
  where: ActorWhereUniqueInput!
}

input ActorCreateOrConnectWithoutSeriesInput {
  create: ActorCreateWithoutSeriesInput!
  where: ActorWhereUniqueInput!
}

input ActorCreateWithoutMoviesInput {
  createdAt: DateTime
  name: String!
  series: SerieCreateNestedOneWithoutActorsInput
  updatedAt: DateTime
}

input ActorCreateWithoutSeriesInput {
  createdAt: DateTime
  movies: MovieCreateNestedManyWithoutActorsInput
  name: String!
  updatedAt: DateTime
}

type ActorGroupBy {
  _avg: ActorAvgAggregate
  _count: ActorCountAggregate
  _max: ActorMaxAggregate
  _min: ActorMinAggregate
  _sum: ActorSumAggregate
  createdAt: DateTime!
  id: Int!
  name: String!
  seriesId: Int
  updatedAt: DateTime!
}

input ActorListRelationFilter {
  every: ActorWhereInput
  none: ActorWhereInput
  some: ActorWhereInput
}

type ActorMaxAggregate {
  createdAt: DateTime
  id: Int
  name: String
  seriesId: Int
  updatedAt: DateTime
}

input ActorMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  seriesId: SortOrder
  updatedAt: SortOrder
}

type ActorMinAggregate {
  createdAt: DateTime
  id: Int
  name: String
  seriesId: Int
  updatedAt: DateTime
}

input ActorMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  seriesId: SortOrder
  updatedAt: SortOrder
}

input ActorOrderByRelationAggregateInput {
  _count: SortOrder
}

enum ActorOrderByRelevanceFieldEnum {
  name
}

input ActorOrderByRelevanceInput {
  fields: [ActorOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input ActorOrderByWithAggregationInput {
  _avg: ActorAvgOrderByAggregateInput
  _count: ActorCountOrderByAggregateInput
  _max: ActorMaxOrderByAggregateInput
  _min: ActorMinOrderByAggregateInput
  _sum: ActorSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  seriesId: SortOrder
  updatedAt: SortOrder
}

input ActorOrderByWithRelationAndSearchRelevanceInput {
  _relevance: ActorOrderByRelevanceInput
  createdAt: SortOrder
  id: SortOrder
  movies: MovieOrderByRelationAggregateInput
  name: SortOrder
  series: SerieOrderByWithRelationAndSearchRelevanceInput
  seriesId: SortOrder
  updatedAt: SortOrder
}

enum ActorScalarFieldEnum {
  createdAt
  id
  name
  seriesId
  updatedAt
}

input ActorScalarWhereInput {
  AND: [ActorScalarWhereInput!]
  NOT: [ActorScalarWhereInput!]
  OR: [ActorScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  seriesId: IntNullableFilter
  updatedAt: DateTimeFilter
}

input ActorScalarWhereWithAggregatesInput {
  AND: [ActorScalarWhereWithAggregatesInput!]
  NOT: [ActorScalarWhereWithAggregatesInput!]
  OR: [ActorScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  seriesId: IntNullableWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type ActorSumAggregate {
  id: Int
  seriesId: Int
}

input ActorSumOrderByAggregateInput {
  id: SortOrder
  seriesId: SortOrder
}

input ActorUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  movies: MovieUpdateManyWithoutActorsInput
  name: StringFieldUpdateOperationsInput
  series: SerieUpdateOneWithoutActorsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ActorUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ActorUpdateManyWithWhereWithoutMoviesInput {
  data: ActorUpdateManyMutationInput!
  where: ActorScalarWhereInput!
}

input ActorUpdateManyWithWhereWithoutSeriesInput {
  data: ActorUpdateManyMutationInput!
  where: ActorScalarWhereInput!
}

input ActorUpdateManyWithoutMoviesInput {
  connect: [ActorWhereUniqueInput!]
  connectOrCreate: [ActorCreateOrConnectWithoutMoviesInput!]
  create: [ActorCreateWithoutMoviesInput!]
  delete: [ActorWhereUniqueInput!]
  deleteMany: [ActorScalarWhereInput!]
  disconnect: [ActorWhereUniqueInput!]
  set: [ActorWhereUniqueInput!]
  update: [ActorUpdateWithWhereUniqueWithoutMoviesInput!]
  updateMany: [ActorUpdateManyWithWhereWithoutMoviesInput!]
  upsert: [ActorUpsertWithWhereUniqueWithoutMoviesInput!]
}

input ActorUpdateManyWithoutSeriesInput {
  connect: [ActorWhereUniqueInput!]
  connectOrCreate: [ActorCreateOrConnectWithoutSeriesInput!]
  create: [ActorCreateWithoutSeriesInput!]
  createMany: ActorCreateManySeriesInputEnvelope
  delete: [ActorWhereUniqueInput!]
  deleteMany: [ActorScalarWhereInput!]
  disconnect: [ActorWhereUniqueInput!]
  set: [ActorWhereUniqueInput!]
  update: [ActorUpdateWithWhereUniqueWithoutSeriesInput!]
  updateMany: [ActorUpdateManyWithWhereWithoutSeriesInput!]
  upsert: [ActorUpsertWithWhereUniqueWithoutSeriesInput!]
}

input ActorUpdateWithWhereUniqueWithoutMoviesInput {
  data: ActorUpdateWithoutMoviesInput!
  where: ActorWhereUniqueInput!
}

input ActorUpdateWithWhereUniqueWithoutSeriesInput {
  data: ActorUpdateWithoutSeriesInput!
  where: ActorWhereUniqueInput!
}

input ActorUpdateWithoutMoviesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  series: SerieUpdateOneWithoutActorsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ActorUpdateWithoutSeriesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  movies: MovieUpdateManyWithoutActorsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ActorUpsertWithWhereUniqueWithoutMoviesInput {
  create: ActorCreateWithoutMoviesInput!
  update: ActorUpdateWithoutMoviesInput!
  where: ActorWhereUniqueInput!
}

input ActorUpsertWithWhereUniqueWithoutSeriesInput {
  create: ActorCreateWithoutSeriesInput!
  update: ActorUpdateWithoutSeriesInput!
  where: ActorWhereUniqueInput!
}

input ActorWhereInput {
  AND: [ActorWhereInput!]
  NOT: [ActorWhereInput!]
  OR: [ActorWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  movies: MovieListRelationFilter
  name: StringFilter
  series: SerieRelationFilter
  seriesId: IntNullableFilter
  updatedAt: DateTimeFilter
}

input ActorWhereUniqueInput {
  id: Int
}

type AffectedRowsOutput {
  count: Int!
}

type AggregateAccount {
  _avg: AccountAvgAggregate
  _count: AccountCountAggregate
  _max: AccountMaxAggregate
  _min: AccountMinAggregate
  _sum: AccountSumAggregate
}

type AggregateActor {
  _avg: ActorAvgAggregate
  _count: ActorCountAggregate
  _max: ActorMaxAggregate
  _min: ActorMinAggregate
  _sum: ActorSumAggregate
}

type AggregateDirector {
  _avg: DirectorAvgAggregate
  _count: DirectorCountAggregate
  _max: DirectorMaxAggregate
  _min: DirectorMinAggregate
  _sum: DirectorSumAggregate
}

type AggregateEpisode {
  _avg: EpisodeAvgAggregate
  _count: EpisodeCountAggregate
  _max: EpisodeMaxAggregate
  _min: EpisodeMinAggregate
  _sum: EpisodeSumAggregate
}

type AggregateGenre {
  _avg: GenreAvgAggregate
  _count: GenreCountAggregate
  _max: GenreMaxAggregate
  _min: GenreMinAggregate
  _sum: GenreSumAggregate
}

type AggregateLanguage {
  _avg: LanguageAvgAggregate
  _count: LanguageCountAggregate
  _max: LanguageMaxAggregate
  _min: LanguageMinAggregate
  _sum: LanguageSumAggregate
}

type AggregateMovie {
  _avg: MovieAvgAggregate
  _count: MovieCountAggregate
  _max: MovieMaxAggregate
  _min: MovieMinAggregate
  _sum: MovieSumAggregate
}

type AggregateSeason {
  _avg: SeasonAvgAggregate
  _count: SeasonCountAggregate
  _max: SeasonMaxAggregate
  _min: SeasonMinAggregate
  _sum: SeasonSumAggregate
}

type AggregateSerie {
  _avg: SerieAvgAggregate
  _count: SerieCountAggregate
  _max: SerieMaxAggregate
  _min: SerieMinAggregate
  _sum: SerieSumAggregate
}

type AggregateSession {
  _count: SessionCountAggregate
  _max: SessionMaxAggregate
  _min: SessionMinAggregate
}

type AggregateUser {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
}

type AggregateVerificationRequest {
  _count: VerificationRequestCountAggregate
  _max: VerificationRequestMaxAggregate
  _min: VerificationRequestMinAggregate
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input DateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

type Director {
  _count: DirectorCount
  createdAt: DateTime!
  id: Int!
  movies(cursor: MovieWhereUniqueInput, distinct: [MovieScalarFieldEnum!], orderBy: [MovieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: MovieWhereInput): [Movie!]!
  name: String!
  series: Serie
  seriesId: Int
  updatedAt: DateTime!
}

type DirectorAvgAggregate {
  id: Float
  seriesId: Float
}

input DirectorAvgOrderByAggregateInput {
  id: SortOrder
  seriesId: SortOrder
}

type DirectorCount {
  movies: Int!
}

type DirectorCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  name: Int!
  seriesId: Int!
  updatedAt: Int!
}

input DirectorCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  seriesId: SortOrder
  updatedAt: SortOrder
}

input DirectorCreateInput {
  createdAt: DateTime
  movies: MovieCreateNestedManyWithoutDirectorsInput
  name: String!
  series: SerieCreateNestedOneWithoutDirectorsInput
  updatedAt: DateTime
}

input DirectorCreateManyInput {
  createdAt: DateTime
  id: Int
  name: String!
  seriesId: Int
  updatedAt: DateTime
}

input DirectorCreateManySeriesInput {
  createdAt: DateTime
  id: Int
  name: String!
  updatedAt: DateTime
}

input DirectorCreateManySeriesInputEnvelope {
  data: [DirectorCreateManySeriesInput!]!
  skipDuplicates: Boolean
}

input DirectorCreateNestedManyWithoutMoviesInput {
  connect: [DirectorWhereUniqueInput!]
  connectOrCreate: [DirectorCreateOrConnectWithoutMoviesInput!]
  create: [DirectorCreateWithoutMoviesInput!]
}

input DirectorCreateNestedManyWithoutSeriesInput {
  connect: [DirectorWhereUniqueInput!]
  connectOrCreate: [DirectorCreateOrConnectWithoutSeriesInput!]
  create: [DirectorCreateWithoutSeriesInput!]
  createMany: DirectorCreateManySeriesInputEnvelope
}

input DirectorCreateOrConnectWithoutMoviesInput {
  create: DirectorCreateWithoutMoviesInput!
  where: DirectorWhereUniqueInput!
}

input DirectorCreateOrConnectWithoutSeriesInput {
  create: DirectorCreateWithoutSeriesInput!
  where: DirectorWhereUniqueInput!
}

input DirectorCreateWithoutMoviesInput {
  createdAt: DateTime
  name: String!
  series: SerieCreateNestedOneWithoutDirectorsInput
  updatedAt: DateTime
}

input DirectorCreateWithoutSeriesInput {
  createdAt: DateTime
  movies: MovieCreateNestedManyWithoutDirectorsInput
  name: String!
  updatedAt: DateTime
}

type DirectorGroupBy {
  _avg: DirectorAvgAggregate
  _count: DirectorCountAggregate
  _max: DirectorMaxAggregate
  _min: DirectorMinAggregate
  _sum: DirectorSumAggregate
  createdAt: DateTime!
  id: Int!
  name: String!
  seriesId: Int
  updatedAt: DateTime!
}

input DirectorListRelationFilter {
  every: DirectorWhereInput
  none: DirectorWhereInput
  some: DirectorWhereInput
}

type DirectorMaxAggregate {
  createdAt: DateTime
  id: Int
  name: String
  seriesId: Int
  updatedAt: DateTime
}

input DirectorMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  seriesId: SortOrder
  updatedAt: SortOrder
}

type DirectorMinAggregate {
  createdAt: DateTime
  id: Int
  name: String
  seriesId: Int
  updatedAt: DateTime
}

input DirectorMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  seriesId: SortOrder
  updatedAt: SortOrder
}

input DirectorOrderByRelationAggregateInput {
  _count: SortOrder
}

enum DirectorOrderByRelevanceFieldEnum {
  name
}

input DirectorOrderByRelevanceInput {
  fields: [DirectorOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input DirectorOrderByWithAggregationInput {
  _avg: DirectorAvgOrderByAggregateInput
  _count: DirectorCountOrderByAggregateInput
  _max: DirectorMaxOrderByAggregateInput
  _min: DirectorMinOrderByAggregateInput
  _sum: DirectorSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  seriesId: SortOrder
  updatedAt: SortOrder
}

input DirectorOrderByWithRelationAndSearchRelevanceInput {
  _relevance: DirectorOrderByRelevanceInput
  createdAt: SortOrder
  id: SortOrder
  movies: MovieOrderByRelationAggregateInput
  name: SortOrder
  series: SerieOrderByWithRelationAndSearchRelevanceInput
  seriesId: SortOrder
  updatedAt: SortOrder
}

enum DirectorScalarFieldEnum {
  createdAt
  id
  name
  seriesId
  updatedAt
}

input DirectorScalarWhereInput {
  AND: [DirectorScalarWhereInput!]
  NOT: [DirectorScalarWhereInput!]
  OR: [DirectorScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  seriesId: IntNullableFilter
  updatedAt: DateTimeFilter
}

input DirectorScalarWhereWithAggregatesInput {
  AND: [DirectorScalarWhereWithAggregatesInput!]
  NOT: [DirectorScalarWhereWithAggregatesInput!]
  OR: [DirectorScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  seriesId: IntNullableWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type DirectorSumAggregate {
  id: Int
  seriesId: Int
}

input DirectorSumOrderByAggregateInput {
  id: SortOrder
  seriesId: SortOrder
}

input DirectorUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  movies: MovieUpdateManyWithoutDirectorsInput
  name: StringFieldUpdateOperationsInput
  series: SerieUpdateOneWithoutDirectorsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input DirectorUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input DirectorUpdateManyWithWhereWithoutMoviesInput {
  data: DirectorUpdateManyMutationInput!
  where: DirectorScalarWhereInput!
}

input DirectorUpdateManyWithWhereWithoutSeriesInput {
  data: DirectorUpdateManyMutationInput!
  where: DirectorScalarWhereInput!
}

input DirectorUpdateManyWithoutMoviesInput {
  connect: [DirectorWhereUniqueInput!]
  connectOrCreate: [DirectorCreateOrConnectWithoutMoviesInput!]
  create: [DirectorCreateWithoutMoviesInput!]
  delete: [DirectorWhereUniqueInput!]
  deleteMany: [DirectorScalarWhereInput!]
  disconnect: [DirectorWhereUniqueInput!]
  set: [DirectorWhereUniqueInput!]
  update: [DirectorUpdateWithWhereUniqueWithoutMoviesInput!]
  updateMany: [DirectorUpdateManyWithWhereWithoutMoviesInput!]
  upsert: [DirectorUpsertWithWhereUniqueWithoutMoviesInput!]
}

input DirectorUpdateManyWithoutSeriesInput {
  connect: [DirectorWhereUniqueInput!]
  connectOrCreate: [DirectorCreateOrConnectWithoutSeriesInput!]
  create: [DirectorCreateWithoutSeriesInput!]
  createMany: DirectorCreateManySeriesInputEnvelope
  delete: [DirectorWhereUniqueInput!]
  deleteMany: [DirectorScalarWhereInput!]
  disconnect: [DirectorWhereUniqueInput!]
  set: [DirectorWhereUniqueInput!]
  update: [DirectorUpdateWithWhereUniqueWithoutSeriesInput!]
  updateMany: [DirectorUpdateManyWithWhereWithoutSeriesInput!]
  upsert: [DirectorUpsertWithWhereUniqueWithoutSeriesInput!]
}

input DirectorUpdateWithWhereUniqueWithoutMoviesInput {
  data: DirectorUpdateWithoutMoviesInput!
  where: DirectorWhereUniqueInput!
}

input DirectorUpdateWithWhereUniqueWithoutSeriesInput {
  data: DirectorUpdateWithoutSeriesInput!
  where: DirectorWhereUniqueInput!
}

input DirectorUpdateWithoutMoviesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  series: SerieUpdateOneWithoutDirectorsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input DirectorUpdateWithoutSeriesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  movies: MovieUpdateManyWithoutDirectorsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input DirectorUpsertWithWhereUniqueWithoutMoviesInput {
  create: DirectorCreateWithoutMoviesInput!
  update: DirectorUpdateWithoutMoviesInput!
  where: DirectorWhereUniqueInput!
}

input DirectorUpsertWithWhereUniqueWithoutSeriesInput {
  create: DirectorCreateWithoutSeriesInput!
  update: DirectorUpdateWithoutSeriesInput!
  where: DirectorWhereUniqueInput!
}

input DirectorWhereInput {
  AND: [DirectorWhereInput!]
  NOT: [DirectorWhereInput!]
  OR: [DirectorWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  movies: MovieListRelationFilter
  name: StringFilter
  series: SerieRelationFilter
  seriesId: IntNullableFilter
  updatedAt: DateTimeFilter
}

input DirectorWhereUniqueInput {
  id: Int
}

input EnumRoleFieldUpdateOperationsInput {
  set: Role
}

input EnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input EnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

type Episode {
  id: Int!
  imdbID: String!
  imdbRating: Float!
  plot: String!
  poster: String!
  runtime: Int!
  season: Season!
  seasonId: Int!
  title: String!
}

type EpisodeAvgAggregate {
  id: Float
  imdbRating: Float
  runtime: Float
  seasonId: Float
}

input EpisodeAvgOrderByAggregateInput {
  id: SortOrder
  imdbRating: SortOrder
  runtime: SortOrder
  seasonId: SortOrder
}

type EpisodeCountAggregate {
  _all: Int!
  id: Int!
  imdbID: Int!
  imdbRating: Int!
  plot: Int!
  poster: Int!
  runtime: Int!
  seasonId: Int!
  title: Int!
}

input EpisodeCountOrderByAggregateInput {
  id: SortOrder
  imdbID: SortOrder
  imdbRating: SortOrder
  plot: SortOrder
  poster: SortOrder
  runtime: SortOrder
  seasonId: SortOrder
  title: SortOrder
}

input EpisodeCreateInput {
  imdbID: String!
  imdbRating: Float!
  plot: String!
  poster: String!
  runtime: Int!
  season: SeasonCreateNestedOneWithoutEpisodeIdsInput!
  title: String!
}

input EpisodeCreateManyInput {
  id: Int
  imdbID: String!
  imdbRating: Float!
  plot: String!
  poster: String!
  runtime: Int!
  seasonId: Int!
  title: String!
}

input EpisodeCreateManySeasonInput {
  id: Int
  imdbID: String!
  imdbRating: Float!
  plot: String!
  poster: String!
  runtime: Int!
  title: String!
}

input EpisodeCreateManySeasonInputEnvelope {
  data: [EpisodeCreateManySeasonInput!]!
  skipDuplicates: Boolean
}

input EpisodeCreateNestedManyWithoutSeasonInput {
  connect: [EpisodeWhereUniqueInput!]
  connectOrCreate: [EpisodeCreateOrConnectWithoutSeasonInput!]
  create: [EpisodeCreateWithoutSeasonInput!]
  createMany: EpisodeCreateManySeasonInputEnvelope
}

input EpisodeCreateOrConnectWithoutSeasonInput {
  create: EpisodeCreateWithoutSeasonInput!
  where: EpisodeWhereUniqueInput!
}

input EpisodeCreateWithoutSeasonInput {
  imdbID: String!
  imdbRating: Float!
  plot: String!
  poster: String!
  runtime: Int!
  title: String!
}

type EpisodeGroupBy {
  _avg: EpisodeAvgAggregate
  _count: EpisodeCountAggregate
  _max: EpisodeMaxAggregate
  _min: EpisodeMinAggregate
  _sum: EpisodeSumAggregate
  id: Int!
  imdbID: String!
  imdbRating: Float!
  plot: String!
  poster: String!
  runtime: Int!
  seasonId: Int!
  title: String!
}

input EpisodeListRelationFilter {
  every: EpisodeWhereInput
  none: EpisodeWhereInput
  some: EpisodeWhereInput
}

type EpisodeMaxAggregate {
  id: Int
  imdbID: String
  imdbRating: Float
  plot: String
  poster: String
  runtime: Int
  seasonId: Int
  title: String
}

input EpisodeMaxOrderByAggregateInput {
  id: SortOrder
  imdbID: SortOrder
  imdbRating: SortOrder
  plot: SortOrder
  poster: SortOrder
  runtime: SortOrder
  seasonId: SortOrder
  title: SortOrder
}

type EpisodeMinAggregate {
  id: Int
  imdbID: String
  imdbRating: Float
  plot: String
  poster: String
  runtime: Int
  seasonId: Int
  title: String
}

input EpisodeMinOrderByAggregateInput {
  id: SortOrder
  imdbID: SortOrder
  imdbRating: SortOrder
  plot: SortOrder
  poster: SortOrder
  runtime: SortOrder
  seasonId: SortOrder
  title: SortOrder
}

input EpisodeOrderByRelationAggregateInput {
  _count: SortOrder
}

enum EpisodeOrderByRelevanceFieldEnum {
  imdbID
  plot
  poster
  title
}

input EpisodeOrderByRelevanceInput {
  fields: [EpisodeOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input EpisodeOrderByWithAggregationInput {
  _avg: EpisodeAvgOrderByAggregateInput
  _count: EpisodeCountOrderByAggregateInput
  _max: EpisodeMaxOrderByAggregateInput
  _min: EpisodeMinOrderByAggregateInput
  _sum: EpisodeSumOrderByAggregateInput
  id: SortOrder
  imdbID: SortOrder
  imdbRating: SortOrder
  plot: SortOrder
  poster: SortOrder
  runtime: SortOrder
  seasonId: SortOrder
  title: SortOrder
}

input EpisodeOrderByWithRelationAndSearchRelevanceInput {
  _relevance: EpisodeOrderByRelevanceInput
  id: SortOrder
  imdbID: SortOrder
  imdbRating: SortOrder
  plot: SortOrder
  poster: SortOrder
  runtime: SortOrder
  season: SeasonOrderByWithRelationAndSearchRelevanceInput
  seasonId: SortOrder
  title: SortOrder
}

enum EpisodeScalarFieldEnum {
  id
  imdbID
  imdbRating
  plot
  poster
  runtime
  seasonId
  title
}

input EpisodeScalarWhereInput {
  AND: [EpisodeScalarWhereInput!]
  NOT: [EpisodeScalarWhereInput!]
  OR: [EpisodeScalarWhereInput!]
  id: IntFilter
  imdbID: StringFilter
  imdbRating: FloatFilter
  plot: StringFilter
  poster: StringFilter
  runtime: IntFilter
  seasonId: IntFilter
  title: StringFilter
}

input EpisodeScalarWhereWithAggregatesInput {
  AND: [EpisodeScalarWhereWithAggregatesInput!]
  NOT: [EpisodeScalarWhereWithAggregatesInput!]
  OR: [EpisodeScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  imdbID: StringWithAggregatesFilter
  imdbRating: FloatWithAggregatesFilter
  plot: StringWithAggregatesFilter
  poster: StringWithAggregatesFilter
  runtime: IntWithAggregatesFilter
  seasonId: IntWithAggregatesFilter
  title: StringWithAggregatesFilter
}

type EpisodeSumAggregate {
  id: Int
  imdbRating: Float
  runtime: Int
  seasonId: Int
}

input EpisodeSumOrderByAggregateInput {
  id: SortOrder
  imdbRating: SortOrder
  runtime: SortOrder
  seasonId: SortOrder
}

input EpisodeUpdateInput {
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  season: SeasonUpdateOneRequiredWithoutEpisodeIdsInput
  title: StringFieldUpdateOperationsInput
}

input EpisodeUpdateManyMutationInput {
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input EpisodeUpdateManyWithWhereWithoutSeasonInput {
  data: EpisodeUpdateManyMutationInput!
  where: EpisodeScalarWhereInput!
}

input EpisodeUpdateManyWithoutSeasonInput {
  connect: [EpisodeWhereUniqueInput!]
  connectOrCreate: [EpisodeCreateOrConnectWithoutSeasonInput!]
  create: [EpisodeCreateWithoutSeasonInput!]
  createMany: EpisodeCreateManySeasonInputEnvelope
  delete: [EpisodeWhereUniqueInput!]
  deleteMany: [EpisodeScalarWhereInput!]
  disconnect: [EpisodeWhereUniqueInput!]
  set: [EpisodeWhereUniqueInput!]
  update: [EpisodeUpdateWithWhereUniqueWithoutSeasonInput!]
  updateMany: [EpisodeUpdateManyWithWhereWithoutSeasonInput!]
  upsert: [EpisodeUpsertWithWhereUniqueWithoutSeasonInput!]
}

input EpisodeUpdateWithWhereUniqueWithoutSeasonInput {
  data: EpisodeUpdateWithoutSeasonInput!
  where: EpisodeWhereUniqueInput!
}

input EpisodeUpdateWithoutSeasonInput {
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input EpisodeUpsertWithWhereUniqueWithoutSeasonInput {
  create: EpisodeCreateWithoutSeasonInput!
  update: EpisodeUpdateWithoutSeasonInput!
  where: EpisodeWhereUniqueInput!
}

input EpisodeWhereInput {
  AND: [EpisodeWhereInput!]
  NOT: [EpisodeWhereInput!]
  OR: [EpisodeWhereInput!]
  id: IntFilter
  imdbID: StringFilter
  imdbRating: FloatFilter
  plot: StringFilter
  poster: StringFilter
  runtime: IntFilter
  season: SeasonRelationFilter
  seasonId: IntFilter
  title: StringFilter
}

input EpisodeWhereUniqueInput {
  id: Int
  imdbID: String
}

input FloatFieldUpdateOperationsInput {
  decrement: Float
  divide: Float
  increment: Float
  multiply: Float
  set: Float
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input FloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float!]
}

type Genre {
  _count: GenreCount
  createdAt: DateTime!
  id: Int!
  movies(cursor: MovieWhereUniqueInput, distinct: [MovieScalarFieldEnum!], orderBy: [MovieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: MovieWhereInput): [Movie!]!
  name: String!
  series(cursor: SerieWhereUniqueInput, distinct: [SerieScalarFieldEnum!], orderBy: [SerieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: SerieWhereInput): [Serie!]!
  updatedAt: DateTime!
}

type GenreAvgAggregate {
  id: Float
}

input GenreAvgOrderByAggregateInput {
  id: SortOrder
}

type GenreCount {
  movies: Int!
  series: Int!
}

type GenreCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  name: Int!
  updatedAt: Int!
}

input GenreCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input GenreCreateInput {
  createdAt: DateTime
  movies: MovieCreateNestedManyWithoutGenresInput
  name: String!
  series: SerieCreateNestedManyWithoutGenresInput
  updatedAt: DateTime
}

input GenreCreateManyInput {
  createdAt: DateTime
  id: Int
  name: String!
  updatedAt: DateTime
}

input GenreCreateNestedManyWithoutMoviesInput {
  connect: [GenreWhereUniqueInput!]
  connectOrCreate: [GenreCreateOrConnectWithoutMoviesInput!]
  create: [GenreCreateWithoutMoviesInput!]
}

input GenreCreateNestedManyWithoutSeriesInput {
  connect: [GenreWhereUniqueInput!]
  connectOrCreate: [GenreCreateOrConnectWithoutSeriesInput!]
  create: [GenreCreateWithoutSeriesInput!]
}

input GenreCreateOrConnectWithoutMoviesInput {
  create: GenreCreateWithoutMoviesInput!
  where: GenreWhereUniqueInput!
}

input GenreCreateOrConnectWithoutSeriesInput {
  create: GenreCreateWithoutSeriesInput!
  where: GenreWhereUniqueInput!
}

input GenreCreateWithoutMoviesInput {
  createdAt: DateTime
  name: String!
  series: SerieCreateNestedManyWithoutGenresInput
  updatedAt: DateTime
}

input GenreCreateWithoutSeriesInput {
  createdAt: DateTime
  movies: MovieCreateNestedManyWithoutGenresInput
  name: String!
  updatedAt: DateTime
}

type GenreGroupBy {
  _avg: GenreAvgAggregate
  _count: GenreCountAggregate
  _max: GenreMaxAggregate
  _min: GenreMinAggregate
  _sum: GenreSumAggregate
  createdAt: DateTime!
  id: Int!
  name: String!
  updatedAt: DateTime!
}

input GenreListRelationFilter {
  every: GenreWhereInput
  none: GenreWhereInput
  some: GenreWhereInput
}

type GenreMaxAggregate {
  createdAt: DateTime
  id: Int
  name: String
  updatedAt: DateTime
}

input GenreMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

type GenreMinAggregate {
  createdAt: DateTime
  id: Int
  name: String
  updatedAt: DateTime
}

input GenreMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input GenreOrderByRelationAggregateInput {
  _count: SortOrder
}

enum GenreOrderByRelevanceFieldEnum {
  name
}

input GenreOrderByRelevanceInput {
  fields: [GenreOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input GenreOrderByWithAggregationInput {
  _avg: GenreAvgOrderByAggregateInput
  _count: GenreCountOrderByAggregateInput
  _max: GenreMaxOrderByAggregateInput
  _min: GenreMinOrderByAggregateInput
  _sum: GenreSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input GenreOrderByWithRelationAndSearchRelevanceInput {
  _relevance: GenreOrderByRelevanceInput
  createdAt: SortOrder
  id: SortOrder
  movies: MovieOrderByRelationAggregateInput
  name: SortOrder
  series: SerieOrderByRelationAggregateInput
  updatedAt: SortOrder
}

enum GenreScalarFieldEnum {
  createdAt
  id
  name
  updatedAt
}

input GenreScalarWhereInput {
  AND: [GenreScalarWhereInput!]
  NOT: [GenreScalarWhereInput!]
  OR: [GenreScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  updatedAt: DateTimeFilter
}

input GenreScalarWhereWithAggregatesInput {
  AND: [GenreScalarWhereWithAggregatesInput!]
  NOT: [GenreScalarWhereWithAggregatesInput!]
  OR: [GenreScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type GenreSumAggregate {
  id: Int
}

input GenreSumOrderByAggregateInput {
  id: SortOrder
}

input GenreUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  movies: MovieUpdateManyWithoutGenresInput
  name: StringFieldUpdateOperationsInput
  series: SerieUpdateManyWithoutGenresInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input GenreUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input GenreUpdateManyWithWhereWithoutMoviesInput {
  data: GenreUpdateManyMutationInput!
  where: GenreScalarWhereInput!
}

input GenreUpdateManyWithWhereWithoutSeriesInput {
  data: GenreUpdateManyMutationInput!
  where: GenreScalarWhereInput!
}

input GenreUpdateManyWithoutMoviesInput {
  connect: [GenreWhereUniqueInput!]
  connectOrCreate: [GenreCreateOrConnectWithoutMoviesInput!]
  create: [GenreCreateWithoutMoviesInput!]
  delete: [GenreWhereUniqueInput!]
  deleteMany: [GenreScalarWhereInput!]
  disconnect: [GenreWhereUniqueInput!]
  set: [GenreWhereUniqueInput!]
  update: [GenreUpdateWithWhereUniqueWithoutMoviesInput!]
  updateMany: [GenreUpdateManyWithWhereWithoutMoviesInput!]
  upsert: [GenreUpsertWithWhereUniqueWithoutMoviesInput!]
}

input GenreUpdateManyWithoutSeriesInput {
  connect: [GenreWhereUniqueInput!]
  connectOrCreate: [GenreCreateOrConnectWithoutSeriesInput!]
  create: [GenreCreateWithoutSeriesInput!]
  delete: [GenreWhereUniqueInput!]
  deleteMany: [GenreScalarWhereInput!]
  disconnect: [GenreWhereUniqueInput!]
  set: [GenreWhereUniqueInput!]
  update: [GenreUpdateWithWhereUniqueWithoutSeriesInput!]
  updateMany: [GenreUpdateManyWithWhereWithoutSeriesInput!]
  upsert: [GenreUpsertWithWhereUniqueWithoutSeriesInput!]
}

input GenreUpdateWithWhereUniqueWithoutMoviesInput {
  data: GenreUpdateWithoutMoviesInput!
  where: GenreWhereUniqueInput!
}

input GenreUpdateWithWhereUniqueWithoutSeriesInput {
  data: GenreUpdateWithoutSeriesInput!
  where: GenreWhereUniqueInput!
}

input GenreUpdateWithoutMoviesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  series: SerieUpdateManyWithoutGenresInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input GenreUpdateWithoutSeriesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  movies: MovieUpdateManyWithoutGenresInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input GenreUpsertWithWhereUniqueWithoutMoviesInput {
  create: GenreCreateWithoutMoviesInput!
  update: GenreUpdateWithoutMoviesInput!
  where: GenreWhereUniqueInput!
}

input GenreUpsertWithWhereUniqueWithoutSeriesInput {
  create: GenreCreateWithoutSeriesInput!
  update: GenreUpdateWithoutSeriesInput!
  where: GenreWhereUniqueInput!
}

input GenreWhereInput {
  AND: [GenreWhereInput!]
  NOT: [GenreWhereInput!]
  OR: [GenreWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  movies: MovieListRelationFilter
  name: StringFilter
  series: SerieListRelationFilter
  updatedAt: DateTimeFilter
}

input GenreWhereUniqueInput {
  id: Int
  name: String
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Language {
  _count: LanguageCount
  createdAt: DateTime!
  id: Int!
  movies(cursor: MovieWhereUniqueInput, distinct: [MovieScalarFieldEnum!], orderBy: [MovieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: MovieWhereInput): [Movie!]!
  name: String!
  series(cursor: SerieWhereUniqueInput, distinct: [SerieScalarFieldEnum!], orderBy: [SerieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: SerieWhereInput): [Serie!]!
  seriesId: Int
  updatedAt: DateTime!
}

type LanguageAvgAggregate {
  id: Float
  seriesId: Float
}

input LanguageAvgOrderByAggregateInput {
  id: SortOrder
  seriesId: SortOrder
}

type LanguageCount {
  movies: Int!
  series: Int!
}

type LanguageCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  name: Int!
  seriesId: Int!
  updatedAt: Int!
}

input LanguageCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  seriesId: SortOrder
  updatedAt: SortOrder
}

input LanguageCreateInput {
  createdAt: DateTime
  movies: MovieCreateNestedManyWithoutLanguagesInput
  name: String!
  series: SerieCreateNestedManyWithoutLanguagesInput
  seriesId: Int
  updatedAt: DateTime
}

input LanguageCreateManyInput {
  createdAt: DateTime
  id: Int
  name: String!
  seriesId: Int
  updatedAt: DateTime
}

input LanguageCreateNestedManyWithoutMoviesInput {
  connect: [LanguageWhereUniqueInput!]
  connectOrCreate: [LanguageCreateOrConnectWithoutMoviesInput!]
  create: [LanguageCreateWithoutMoviesInput!]
}

input LanguageCreateNestedManyWithoutSeriesInput {
  connect: [LanguageWhereUniqueInput!]
  connectOrCreate: [LanguageCreateOrConnectWithoutSeriesInput!]
  create: [LanguageCreateWithoutSeriesInput!]
}

input LanguageCreateOrConnectWithoutMoviesInput {
  create: LanguageCreateWithoutMoviesInput!
  where: LanguageWhereUniqueInput!
}

input LanguageCreateOrConnectWithoutSeriesInput {
  create: LanguageCreateWithoutSeriesInput!
  where: LanguageWhereUniqueInput!
}

input LanguageCreateWithoutMoviesInput {
  createdAt: DateTime
  name: String!
  series: SerieCreateNestedManyWithoutLanguagesInput
  seriesId: Int
  updatedAt: DateTime
}

input LanguageCreateWithoutSeriesInput {
  createdAt: DateTime
  movies: MovieCreateNestedManyWithoutLanguagesInput
  name: String!
  seriesId: Int
  updatedAt: DateTime
}

type LanguageGroupBy {
  _avg: LanguageAvgAggregate
  _count: LanguageCountAggregate
  _max: LanguageMaxAggregate
  _min: LanguageMinAggregate
  _sum: LanguageSumAggregate
  createdAt: DateTime!
  id: Int!
  name: String!
  seriesId: Int
  updatedAt: DateTime!
}

input LanguageListRelationFilter {
  every: LanguageWhereInput
  none: LanguageWhereInput
  some: LanguageWhereInput
}

type LanguageMaxAggregate {
  createdAt: DateTime
  id: Int
  name: String
  seriesId: Int
  updatedAt: DateTime
}

input LanguageMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  seriesId: SortOrder
  updatedAt: SortOrder
}

type LanguageMinAggregate {
  createdAt: DateTime
  id: Int
  name: String
  seriesId: Int
  updatedAt: DateTime
}

input LanguageMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  seriesId: SortOrder
  updatedAt: SortOrder
}

input LanguageOrderByRelationAggregateInput {
  _count: SortOrder
}

enum LanguageOrderByRelevanceFieldEnum {
  name
}

input LanguageOrderByRelevanceInput {
  fields: [LanguageOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input LanguageOrderByWithAggregationInput {
  _avg: LanguageAvgOrderByAggregateInput
  _count: LanguageCountOrderByAggregateInput
  _max: LanguageMaxOrderByAggregateInput
  _min: LanguageMinOrderByAggregateInput
  _sum: LanguageSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  seriesId: SortOrder
  updatedAt: SortOrder
}

input LanguageOrderByWithRelationAndSearchRelevanceInput {
  _relevance: LanguageOrderByRelevanceInput
  createdAt: SortOrder
  id: SortOrder
  movies: MovieOrderByRelationAggregateInput
  name: SortOrder
  series: SerieOrderByRelationAggregateInput
  seriesId: SortOrder
  updatedAt: SortOrder
}

enum LanguageScalarFieldEnum {
  createdAt
  id
  name
  seriesId
  updatedAt
}

input LanguageScalarWhereInput {
  AND: [LanguageScalarWhereInput!]
  NOT: [LanguageScalarWhereInput!]
  OR: [LanguageScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  seriesId: IntNullableFilter
  updatedAt: DateTimeFilter
}

input LanguageScalarWhereWithAggregatesInput {
  AND: [LanguageScalarWhereWithAggregatesInput!]
  NOT: [LanguageScalarWhereWithAggregatesInput!]
  OR: [LanguageScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  seriesId: IntNullableWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type LanguageSumAggregate {
  id: Int
  seriesId: Int
}

input LanguageSumOrderByAggregateInput {
  id: SortOrder
  seriesId: SortOrder
}

input LanguageUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  movies: MovieUpdateManyWithoutLanguagesInput
  name: StringFieldUpdateOperationsInput
  series: SerieUpdateManyWithoutLanguagesInput
  seriesId: NullableIntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input LanguageUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  seriesId: NullableIntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input LanguageUpdateManyWithWhereWithoutMoviesInput {
  data: LanguageUpdateManyMutationInput!
  where: LanguageScalarWhereInput!
}

input LanguageUpdateManyWithWhereWithoutSeriesInput {
  data: LanguageUpdateManyMutationInput!
  where: LanguageScalarWhereInput!
}

input LanguageUpdateManyWithoutMoviesInput {
  connect: [LanguageWhereUniqueInput!]
  connectOrCreate: [LanguageCreateOrConnectWithoutMoviesInput!]
  create: [LanguageCreateWithoutMoviesInput!]
  delete: [LanguageWhereUniqueInput!]
  deleteMany: [LanguageScalarWhereInput!]
  disconnect: [LanguageWhereUniqueInput!]
  set: [LanguageWhereUniqueInput!]
  update: [LanguageUpdateWithWhereUniqueWithoutMoviesInput!]
  updateMany: [LanguageUpdateManyWithWhereWithoutMoviesInput!]
  upsert: [LanguageUpsertWithWhereUniqueWithoutMoviesInput!]
}

input LanguageUpdateManyWithoutSeriesInput {
  connect: [LanguageWhereUniqueInput!]
  connectOrCreate: [LanguageCreateOrConnectWithoutSeriesInput!]
  create: [LanguageCreateWithoutSeriesInput!]
  delete: [LanguageWhereUniqueInput!]
  deleteMany: [LanguageScalarWhereInput!]
  disconnect: [LanguageWhereUniqueInput!]
  set: [LanguageWhereUniqueInput!]
  update: [LanguageUpdateWithWhereUniqueWithoutSeriesInput!]
  updateMany: [LanguageUpdateManyWithWhereWithoutSeriesInput!]
  upsert: [LanguageUpsertWithWhereUniqueWithoutSeriesInput!]
}

input LanguageUpdateWithWhereUniqueWithoutMoviesInput {
  data: LanguageUpdateWithoutMoviesInput!
  where: LanguageWhereUniqueInput!
}

input LanguageUpdateWithWhereUniqueWithoutSeriesInput {
  data: LanguageUpdateWithoutSeriesInput!
  where: LanguageWhereUniqueInput!
}

input LanguageUpdateWithoutMoviesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  series: SerieUpdateManyWithoutLanguagesInput
  seriesId: NullableIntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input LanguageUpdateWithoutSeriesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  movies: MovieUpdateManyWithoutLanguagesInput
  name: StringFieldUpdateOperationsInput
  seriesId: NullableIntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input LanguageUpsertWithWhereUniqueWithoutMoviesInput {
  create: LanguageCreateWithoutMoviesInput!
  update: LanguageUpdateWithoutMoviesInput!
  where: LanguageWhereUniqueInput!
}

input LanguageUpsertWithWhereUniqueWithoutSeriesInput {
  create: LanguageCreateWithoutSeriesInput!
  update: LanguageUpdateWithoutSeriesInput!
  where: LanguageWhereUniqueInput!
}

input LanguageWhereInput {
  AND: [LanguageWhereInput!]
  NOT: [LanguageWhereInput!]
  OR: [LanguageWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  movies: MovieListRelationFilter
  name: StringFilter
  series: SerieListRelationFilter
  seriesId: IntNullableFilter
  updatedAt: DateTimeFilter
}

input LanguageWhereUniqueInput {
  id: Int
  name: String
}

type Movie {
  _count: MovieCount
  actors(cursor: ActorWhereUniqueInput, distinct: [ActorScalarFieldEnum!], orderBy: [ActorOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: ActorWhereInput): [Actor!]!
  createdAt: DateTime!
  directors(cursor: DirectorWhereUniqueInput, distinct: [DirectorScalarFieldEnum!], orderBy: [DirectorOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: DirectorWhereInput): [Director!]!
  genres(cursor: GenreWhereUniqueInput, distinct: [GenreScalarFieldEnum!], orderBy: [GenreOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: GenreWhereInput): [Genre!]!
  id: Int!
  imdbID: String!
  imdbRating: Float!
  languages(cursor: LanguageWhereUniqueInput, distinct: [LanguageScalarFieldEnum!], orderBy: [LanguageOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: LanguageWhereInput): [Language!]!
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  title: String!
  updatedAt: DateTime!
  year: Int!
}

type MovieAvgAggregate {
  id: Float
  imdbRating: Float
  runtime: Float
  year: Float
}

input MovieAvgOrderByAggregateInput {
  id: SortOrder
  imdbRating: SortOrder
  runtime: SortOrder
  year: SortOrder
}

type MovieCount {
  actors: Int!
  directors: Int!
  genres: Int!
  languages: Int!
}

type MovieCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  imdbID: Int!
  imdbRating: Int!
  plot: Int!
  poster: Int!
  rating: Int!
  release: Int!
  runtime: Int!
  title: Int!
  updatedAt: Int!
  year: Int!
}

input MovieCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  imdbID: SortOrder
  imdbRating: SortOrder
  plot: SortOrder
  poster: SortOrder
  rating: SortOrder
  release: SortOrder
  runtime: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  year: SortOrder
}

input MovieCreateInput {
  actors: ActorCreateNestedManyWithoutMoviesInput
  createdAt: DateTime
  directors: DirectorCreateNestedManyWithoutMoviesInput
  genres: GenreCreateNestedManyWithoutMoviesInput
  imdbID: String!
  imdbRating: Float!
  languages: LanguageCreateNestedManyWithoutMoviesInput
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  title: String!
  updatedAt: DateTime
  year: Int!
}

input MovieCreateManyInput {
  createdAt: DateTime
  id: Int
  imdbID: String!
  imdbRating: Float!
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  title: String!
  updatedAt: DateTime
  year: Int!
}

input MovieCreateNestedManyWithoutActorsInput {
  connect: [MovieWhereUniqueInput!]
  connectOrCreate: [MovieCreateOrConnectWithoutActorsInput!]
  create: [MovieCreateWithoutActorsInput!]
}

input MovieCreateNestedManyWithoutDirectorsInput {
  connect: [MovieWhereUniqueInput!]
  connectOrCreate: [MovieCreateOrConnectWithoutDirectorsInput!]
  create: [MovieCreateWithoutDirectorsInput!]
}

input MovieCreateNestedManyWithoutGenresInput {
  connect: [MovieWhereUniqueInput!]
  connectOrCreate: [MovieCreateOrConnectWithoutGenresInput!]
  create: [MovieCreateWithoutGenresInput!]
}

input MovieCreateNestedManyWithoutLanguagesInput {
  connect: [MovieWhereUniqueInput!]
  connectOrCreate: [MovieCreateOrConnectWithoutLanguagesInput!]
  create: [MovieCreateWithoutLanguagesInput!]
}

input MovieCreateOrConnectWithoutActorsInput {
  create: MovieCreateWithoutActorsInput!
  where: MovieWhereUniqueInput!
}

input MovieCreateOrConnectWithoutDirectorsInput {
  create: MovieCreateWithoutDirectorsInput!
  where: MovieWhereUniqueInput!
}

input MovieCreateOrConnectWithoutGenresInput {
  create: MovieCreateWithoutGenresInput!
  where: MovieWhereUniqueInput!
}

input MovieCreateOrConnectWithoutLanguagesInput {
  create: MovieCreateWithoutLanguagesInput!
  where: MovieWhereUniqueInput!
}

input MovieCreateWithoutActorsInput {
  createdAt: DateTime
  directors: DirectorCreateNestedManyWithoutMoviesInput
  genres: GenreCreateNestedManyWithoutMoviesInput
  imdbID: String!
  imdbRating: Float!
  languages: LanguageCreateNestedManyWithoutMoviesInput
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  title: String!
  updatedAt: DateTime
  year: Int!
}

input MovieCreateWithoutDirectorsInput {
  actors: ActorCreateNestedManyWithoutMoviesInput
  createdAt: DateTime
  genres: GenreCreateNestedManyWithoutMoviesInput
  imdbID: String!
  imdbRating: Float!
  languages: LanguageCreateNestedManyWithoutMoviesInput
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  title: String!
  updatedAt: DateTime
  year: Int!
}

input MovieCreateWithoutGenresInput {
  actors: ActorCreateNestedManyWithoutMoviesInput
  createdAt: DateTime
  directors: DirectorCreateNestedManyWithoutMoviesInput
  imdbID: String!
  imdbRating: Float!
  languages: LanguageCreateNestedManyWithoutMoviesInput
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  title: String!
  updatedAt: DateTime
  year: Int!
}

input MovieCreateWithoutLanguagesInput {
  actors: ActorCreateNestedManyWithoutMoviesInput
  createdAt: DateTime
  directors: DirectorCreateNestedManyWithoutMoviesInput
  genres: GenreCreateNestedManyWithoutMoviesInput
  imdbID: String!
  imdbRating: Float!
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  title: String!
  updatedAt: DateTime
  year: Int!
}

type MovieGroupBy {
  _avg: MovieAvgAggregate
  _count: MovieCountAggregate
  _max: MovieMaxAggregate
  _min: MovieMinAggregate
  _sum: MovieSumAggregate
  createdAt: DateTime!
  id: Int!
  imdbID: String!
  imdbRating: Float!
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  title: String!
  updatedAt: DateTime!
  year: Int!
}

input MovieListRelationFilter {
  every: MovieWhereInput
  none: MovieWhereInput
  some: MovieWhereInput
}

type MovieMaxAggregate {
  createdAt: DateTime
  id: Int
  imdbID: String
  imdbRating: Float
  plot: String
  poster: String
  rating: String
  release: DateTime
  runtime: Int
  title: String
  updatedAt: DateTime
  year: Int
}

input MovieMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  imdbID: SortOrder
  imdbRating: SortOrder
  plot: SortOrder
  poster: SortOrder
  rating: SortOrder
  release: SortOrder
  runtime: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  year: SortOrder
}

type MovieMinAggregate {
  createdAt: DateTime
  id: Int
  imdbID: String
  imdbRating: Float
  plot: String
  poster: String
  rating: String
  release: DateTime
  runtime: Int
  title: String
  updatedAt: DateTime
  year: Int
}

input MovieMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  imdbID: SortOrder
  imdbRating: SortOrder
  plot: SortOrder
  poster: SortOrder
  rating: SortOrder
  release: SortOrder
  runtime: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  year: SortOrder
}

input MovieOrderByRelationAggregateInput {
  _count: SortOrder
}

enum MovieOrderByRelevanceFieldEnum {
  imdbID
  plot
  poster
  rating
  title
}

input MovieOrderByRelevanceInput {
  fields: [MovieOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input MovieOrderByWithAggregationInput {
  _avg: MovieAvgOrderByAggregateInput
  _count: MovieCountOrderByAggregateInput
  _max: MovieMaxOrderByAggregateInput
  _min: MovieMinOrderByAggregateInput
  _sum: MovieSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  imdbID: SortOrder
  imdbRating: SortOrder
  plot: SortOrder
  poster: SortOrder
  rating: SortOrder
  release: SortOrder
  runtime: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  year: SortOrder
}

input MovieOrderByWithRelationAndSearchRelevanceInput {
  _relevance: MovieOrderByRelevanceInput
  actors: ActorOrderByRelationAggregateInput
  createdAt: SortOrder
  directors: DirectorOrderByRelationAggregateInput
  genres: GenreOrderByRelationAggregateInput
  id: SortOrder
  imdbID: SortOrder
  imdbRating: SortOrder
  languages: LanguageOrderByRelationAggregateInput
  plot: SortOrder
  poster: SortOrder
  rating: SortOrder
  release: SortOrder
  runtime: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  year: SortOrder
}

enum MovieScalarFieldEnum {
  createdAt
  id
  imdbID
  imdbRating
  plot
  poster
  rating
  release
  runtime
  title
  updatedAt
  year
}

input MovieScalarWhereInput {
  AND: [MovieScalarWhereInput!]
  NOT: [MovieScalarWhereInput!]
  OR: [MovieScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  imdbID: StringFilter
  imdbRating: FloatFilter
  plot: StringFilter
  poster: StringFilter
  rating: StringFilter
  release: DateTimeFilter
  runtime: IntFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  year: IntFilter
}

input MovieScalarWhereWithAggregatesInput {
  AND: [MovieScalarWhereWithAggregatesInput!]
  NOT: [MovieScalarWhereWithAggregatesInput!]
  OR: [MovieScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  imdbID: StringWithAggregatesFilter
  imdbRating: FloatWithAggregatesFilter
  plot: StringWithAggregatesFilter
  poster: StringWithAggregatesFilter
  rating: StringWithAggregatesFilter
  release: DateTimeWithAggregatesFilter
  runtime: IntWithAggregatesFilter
  title: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  year: IntWithAggregatesFilter
}

type MovieSumAggregate {
  id: Int
  imdbRating: Float
  runtime: Int
  year: Int
}

input MovieSumOrderByAggregateInput {
  id: SortOrder
  imdbRating: SortOrder
  runtime: SortOrder
  year: SortOrder
}

input MovieUpdateInput {
  actors: ActorUpdateManyWithoutMoviesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  directors: DirectorUpdateManyWithoutMoviesInput
  genres: GenreUpdateManyWithoutMoviesInput
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  languages: LanguageUpdateManyWithoutMoviesInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  rating: StringFieldUpdateOperationsInput
  release: DateTimeFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  year: IntFieldUpdateOperationsInput
}

input MovieUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  rating: StringFieldUpdateOperationsInput
  release: DateTimeFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  year: IntFieldUpdateOperationsInput
}

input MovieUpdateManyWithWhereWithoutActorsInput {
  data: MovieUpdateManyMutationInput!
  where: MovieScalarWhereInput!
}

input MovieUpdateManyWithWhereWithoutDirectorsInput {
  data: MovieUpdateManyMutationInput!
  where: MovieScalarWhereInput!
}

input MovieUpdateManyWithWhereWithoutGenresInput {
  data: MovieUpdateManyMutationInput!
  where: MovieScalarWhereInput!
}

input MovieUpdateManyWithWhereWithoutLanguagesInput {
  data: MovieUpdateManyMutationInput!
  where: MovieScalarWhereInput!
}

input MovieUpdateManyWithoutActorsInput {
  connect: [MovieWhereUniqueInput!]
  connectOrCreate: [MovieCreateOrConnectWithoutActorsInput!]
  create: [MovieCreateWithoutActorsInput!]
  delete: [MovieWhereUniqueInput!]
  deleteMany: [MovieScalarWhereInput!]
  disconnect: [MovieWhereUniqueInput!]
  set: [MovieWhereUniqueInput!]
  update: [MovieUpdateWithWhereUniqueWithoutActorsInput!]
  updateMany: [MovieUpdateManyWithWhereWithoutActorsInput!]
  upsert: [MovieUpsertWithWhereUniqueWithoutActorsInput!]
}

input MovieUpdateManyWithoutDirectorsInput {
  connect: [MovieWhereUniqueInput!]
  connectOrCreate: [MovieCreateOrConnectWithoutDirectorsInput!]
  create: [MovieCreateWithoutDirectorsInput!]
  delete: [MovieWhereUniqueInput!]
  deleteMany: [MovieScalarWhereInput!]
  disconnect: [MovieWhereUniqueInput!]
  set: [MovieWhereUniqueInput!]
  update: [MovieUpdateWithWhereUniqueWithoutDirectorsInput!]
  updateMany: [MovieUpdateManyWithWhereWithoutDirectorsInput!]
  upsert: [MovieUpsertWithWhereUniqueWithoutDirectorsInput!]
}

input MovieUpdateManyWithoutGenresInput {
  connect: [MovieWhereUniqueInput!]
  connectOrCreate: [MovieCreateOrConnectWithoutGenresInput!]
  create: [MovieCreateWithoutGenresInput!]
  delete: [MovieWhereUniqueInput!]
  deleteMany: [MovieScalarWhereInput!]
  disconnect: [MovieWhereUniqueInput!]
  set: [MovieWhereUniqueInput!]
  update: [MovieUpdateWithWhereUniqueWithoutGenresInput!]
  updateMany: [MovieUpdateManyWithWhereWithoutGenresInput!]
  upsert: [MovieUpsertWithWhereUniqueWithoutGenresInput!]
}

input MovieUpdateManyWithoutLanguagesInput {
  connect: [MovieWhereUniqueInput!]
  connectOrCreate: [MovieCreateOrConnectWithoutLanguagesInput!]
  create: [MovieCreateWithoutLanguagesInput!]
  delete: [MovieWhereUniqueInput!]
  deleteMany: [MovieScalarWhereInput!]
  disconnect: [MovieWhereUniqueInput!]
  set: [MovieWhereUniqueInput!]
  update: [MovieUpdateWithWhereUniqueWithoutLanguagesInput!]
  updateMany: [MovieUpdateManyWithWhereWithoutLanguagesInput!]
  upsert: [MovieUpsertWithWhereUniqueWithoutLanguagesInput!]
}

input MovieUpdateWithWhereUniqueWithoutActorsInput {
  data: MovieUpdateWithoutActorsInput!
  where: MovieWhereUniqueInput!
}

input MovieUpdateWithWhereUniqueWithoutDirectorsInput {
  data: MovieUpdateWithoutDirectorsInput!
  where: MovieWhereUniqueInput!
}

input MovieUpdateWithWhereUniqueWithoutGenresInput {
  data: MovieUpdateWithoutGenresInput!
  where: MovieWhereUniqueInput!
}

input MovieUpdateWithWhereUniqueWithoutLanguagesInput {
  data: MovieUpdateWithoutLanguagesInput!
  where: MovieWhereUniqueInput!
}

input MovieUpdateWithoutActorsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  directors: DirectorUpdateManyWithoutMoviesInput
  genres: GenreUpdateManyWithoutMoviesInput
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  languages: LanguageUpdateManyWithoutMoviesInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  rating: StringFieldUpdateOperationsInput
  release: DateTimeFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  year: IntFieldUpdateOperationsInput
}

input MovieUpdateWithoutDirectorsInput {
  actors: ActorUpdateManyWithoutMoviesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  genres: GenreUpdateManyWithoutMoviesInput
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  languages: LanguageUpdateManyWithoutMoviesInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  rating: StringFieldUpdateOperationsInput
  release: DateTimeFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  year: IntFieldUpdateOperationsInput
}

input MovieUpdateWithoutGenresInput {
  actors: ActorUpdateManyWithoutMoviesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  directors: DirectorUpdateManyWithoutMoviesInput
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  languages: LanguageUpdateManyWithoutMoviesInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  rating: StringFieldUpdateOperationsInput
  release: DateTimeFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  year: IntFieldUpdateOperationsInput
}

input MovieUpdateWithoutLanguagesInput {
  actors: ActorUpdateManyWithoutMoviesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  directors: DirectorUpdateManyWithoutMoviesInput
  genres: GenreUpdateManyWithoutMoviesInput
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  rating: StringFieldUpdateOperationsInput
  release: DateTimeFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  year: IntFieldUpdateOperationsInput
}

input MovieUpsertWithWhereUniqueWithoutActorsInput {
  create: MovieCreateWithoutActorsInput!
  update: MovieUpdateWithoutActorsInput!
  where: MovieWhereUniqueInput!
}

input MovieUpsertWithWhereUniqueWithoutDirectorsInput {
  create: MovieCreateWithoutDirectorsInput!
  update: MovieUpdateWithoutDirectorsInput!
  where: MovieWhereUniqueInput!
}

input MovieUpsertWithWhereUniqueWithoutGenresInput {
  create: MovieCreateWithoutGenresInput!
  update: MovieUpdateWithoutGenresInput!
  where: MovieWhereUniqueInput!
}

input MovieUpsertWithWhereUniqueWithoutLanguagesInput {
  create: MovieCreateWithoutLanguagesInput!
  update: MovieUpdateWithoutLanguagesInput!
  where: MovieWhereUniqueInput!
}

input MovieWhereInput {
  AND: [MovieWhereInput!]
  NOT: [MovieWhereInput!]
  OR: [MovieWhereInput!]
  actors: ActorListRelationFilter
  createdAt: DateTimeFilter
  directors: DirectorListRelationFilter
  genres: GenreListRelationFilter
  id: IntFilter
  imdbID: StringFilter
  imdbRating: FloatFilter
  languages: LanguageListRelationFilter
  plot: StringFilter
  poster: StringFilter
  rating: StringFilter
  release: DateTimeFilter
  runtime: IntFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  year: IntFilter
}

input MovieWhereUniqueInput {
  id: Int
  imdbID: String
}

type Mutation {
  createAccount(data: AccountCreateInput!): Account!
  createActor(data: ActorCreateInput!): Actor!
  createDirector(data: DirectorCreateInput!): Director!
  createEpisode(data: EpisodeCreateInput!): Episode!
  createGenre(data: GenreCreateInput!): Genre!
  createLanguage(data: LanguageCreateInput!): Language!
  createManyAccount(data: [AccountCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyActor(data: [ActorCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyDirector(data: [DirectorCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyEpisode(data: [EpisodeCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyGenre(data: [GenreCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyLanguage(data: [LanguageCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyMovie(data: [MovieCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManySeason(data: [SeasonCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManySerie(data: [SerieCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManySession(data: [SessionCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyVerificationRequest(data: [VerificationRequestCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createMovie(data: MovieCreateInput!): Movie!
  createSeason(data: SeasonCreateInput!): Season!
  createSerie(data: SerieCreateInput!): Serie!
  createSession(data: SessionCreateInput!): Session!
  createUser(data: UserCreateInput!): User!
  createVerificationRequest(data: VerificationRequestCreateInput!): VerificationRequest!
  deleteAccount(where: AccountWhereUniqueInput!): Account
  deleteActor(where: ActorWhereUniqueInput!): Actor
  deleteDirector(where: DirectorWhereUniqueInput!): Director
  deleteEpisode(where: EpisodeWhereUniqueInput!): Episode
  deleteGenre(where: GenreWhereUniqueInput!): Genre
  deleteLanguage(where: LanguageWhereUniqueInput!): Language
  deleteManyAccount(where: AccountWhereInput): AffectedRowsOutput!
  deleteManyActor(where: ActorWhereInput): AffectedRowsOutput!
  deleteManyDirector(where: DirectorWhereInput): AffectedRowsOutput!
  deleteManyEpisode(where: EpisodeWhereInput): AffectedRowsOutput!
  deleteManyGenre(where: GenreWhereInput): AffectedRowsOutput!
  deleteManyLanguage(where: LanguageWhereInput): AffectedRowsOutput!
  deleteManyMovie(where: MovieWhereInput): AffectedRowsOutput!
  deleteManySeason(where: SeasonWhereInput): AffectedRowsOutput!
  deleteManySerie(where: SerieWhereInput): AffectedRowsOutput!
  deleteManySession(where: SessionWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteManyVerificationRequest(where: VerificationRequestWhereInput): AffectedRowsOutput!
  deleteMovie(where: MovieWhereUniqueInput!): Movie
  deleteSeason(where: SeasonWhereUniqueInput!): Season
  deleteSerie(where: SerieWhereUniqueInput!): Serie
  deleteSession(where: SessionWhereUniqueInput!): Session
  deleteUser(where: UserWhereUniqueInput!): User
  deleteVerificationRequest(where: VerificationRequestWhereUniqueInput!): VerificationRequest
  updateAccount(data: AccountUpdateInput!, where: AccountWhereUniqueInput!): Account
  updateActor(data: ActorUpdateInput!, where: ActorWhereUniqueInput!): Actor
  updateDirector(data: DirectorUpdateInput!, where: DirectorWhereUniqueInput!): Director
  updateEpisode(data: EpisodeUpdateInput!, where: EpisodeWhereUniqueInput!): Episode
  updateGenre(data: GenreUpdateInput!, where: GenreWhereUniqueInput!): Genre
  updateLanguage(data: LanguageUpdateInput!, where: LanguageWhereUniqueInput!): Language
  updateManyAccount(data: AccountUpdateManyMutationInput!, where: AccountWhereInput): AffectedRowsOutput!
  updateManyActor(data: ActorUpdateManyMutationInput!, where: ActorWhereInput): AffectedRowsOutput!
  updateManyDirector(data: DirectorUpdateManyMutationInput!, where: DirectorWhereInput): AffectedRowsOutput!
  updateManyEpisode(data: EpisodeUpdateManyMutationInput!, where: EpisodeWhereInput): AffectedRowsOutput!
  updateManyGenre(data: GenreUpdateManyMutationInput!, where: GenreWhereInput): AffectedRowsOutput!
  updateManyLanguage(data: LanguageUpdateManyMutationInput!, where: LanguageWhereInput): AffectedRowsOutput!
  updateManyMovie(data: MovieUpdateManyMutationInput!, where: MovieWhereInput): AffectedRowsOutput!
  updateManySeason(data: SeasonUpdateManyMutationInput!, where: SeasonWhereInput): AffectedRowsOutput!
  updateManySerie(data: SerieUpdateManyMutationInput!, where: SerieWhereInput): AffectedRowsOutput!
  updateManySession(data: SessionUpdateManyMutationInput!, where: SessionWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateManyVerificationRequest(data: VerificationRequestUpdateManyMutationInput!, where: VerificationRequestWhereInput): AffectedRowsOutput!
  updateMovie(data: MovieUpdateInput!, where: MovieWhereUniqueInput!): Movie
  updateSeason(data: SeasonUpdateInput!, where: SeasonWhereUniqueInput!): Season
  updateSerie(data: SerieUpdateInput!, where: SerieWhereUniqueInput!): Serie
  updateSession(data: SessionUpdateInput!, where: SessionWhereUniqueInput!): Session
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateVerificationRequest(data: VerificationRequestUpdateInput!, where: VerificationRequestWhereUniqueInput!): VerificationRequest
  upsertAccount(create: AccountCreateInput!, update: AccountUpdateInput!, where: AccountWhereUniqueInput!): Account!
  upsertActor(create: ActorCreateInput!, update: ActorUpdateInput!, where: ActorWhereUniqueInput!): Actor!
  upsertDirector(create: DirectorCreateInput!, update: DirectorUpdateInput!, where: DirectorWhereUniqueInput!): Director!
  upsertEpisode(create: EpisodeCreateInput!, update: EpisodeUpdateInput!, where: EpisodeWhereUniqueInput!): Episode!
  upsertGenre(create: GenreCreateInput!, update: GenreUpdateInput!, where: GenreWhereUniqueInput!): Genre!
  upsertLanguage(create: LanguageCreateInput!, update: LanguageUpdateInput!, where: LanguageWhereUniqueInput!): Language!
  upsertMovie(create: MovieCreateInput!, update: MovieUpdateInput!, where: MovieWhereUniqueInput!): Movie!
  upsertSeason(create: SeasonCreateInput!, update: SeasonUpdateInput!, where: SeasonWhereUniqueInput!): Season!
  upsertSerie(create: SerieCreateInput!, update: SerieUpdateInput!, where: SerieWhereUniqueInput!): Serie!
  upsertSession(create: SessionCreateInput!, update: SessionUpdateInput!, where: SessionWhereUniqueInput!): Session!
  upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
  upsertVerificationRequest(create: VerificationRequestCreateInput!, update: VerificationRequestUpdateInput!, where: VerificationRequestWhereUniqueInput!): VerificationRequest!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedEnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input NestedEnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedFloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input NullableIntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  account(where: AccountWhereUniqueInput!): Account
  accounts(cursor: AccountWhereUniqueInput, distinct: [AccountScalarFieldEnum!], orderBy: [AccountOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: AccountWhereInput): [Account!]!
  actor(where: ActorWhereUniqueInput!): Actor
  actors(cursor: ActorWhereUniqueInput, distinct: [ActorScalarFieldEnum!], orderBy: [ActorOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: ActorWhereInput): [Actor!]!
  aggregateAccount(cursor: AccountWhereUniqueInput, orderBy: [AccountOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: AccountWhereInput): AggregateAccount!
  aggregateActor(cursor: ActorWhereUniqueInput, orderBy: [ActorOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: ActorWhereInput): AggregateActor!
  aggregateDirector(cursor: DirectorWhereUniqueInput, orderBy: [DirectorOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: DirectorWhereInput): AggregateDirector!
  aggregateEpisode(cursor: EpisodeWhereUniqueInput, orderBy: [EpisodeOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: EpisodeWhereInput): AggregateEpisode!
  aggregateGenre(cursor: GenreWhereUniqueInput, orderBy: [GenreOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: GenreWhereInput): AggregateGenre!
  aggregateLanguage(cursor: LanguageWhereUniqueInput, orderBy: [LanguageOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: LanguageWhereInput): AggregateLanguage!
  aggregateMovie(cursor: MovieWhereUniqueInput, orderBy: [MovieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: MovieWhereInput): AggregateMovie!
  aggregateSeason(cursor: SeasonWhereUniqueInput, orderBy: [SeasonOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: SeasonWhereInput): AggregateSeason!
  aggregateSerie(cursor: SerieWhereUniqueInput, orderBy: [SerieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: SerieWhereInput): AggregateSerie!
  aggregateSession(cursor: SessionWhereUniqueInput, orderBy: [SessionOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: SessionWhereInput): AggregateSession!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  aggregateVerificationRequest(cursor: VerificationRequestWhereUniqueInput, orderBy: [VerificationRequestOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: VerificationRequestWhereInput): AggregateVerificationRequest!
  director(where: DirectorWhereUniqueInput!): Director
  directors(cursor: DirectorWhereUniqueInput, distinct: [DirectorScalarFieldEnum!], orderBy: [DirectorOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: DirectorWhereInput): [Director!]!
  episode(where: EpisodeWhereUniqueInput!): Episode
  episodes(cursor: EpisodeWhereUniqueInput, distinct: [EpisodeScalarFieldEnum!], orderBy: [EpisodeOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: EpisodeWhereInput): [Episode!]!
  findFirstAccount(cursor: AccountWhereUniqueInput, distinct: [AccountScalarFieldEnum!], orderBy: [AccountOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: AccountWhereInput): Account
  findFirstActor(cursor: ActorWhereUniqueInput, distinct: [ActorScalarFieldEnum!], orderBy: [ActorOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: ActorWhereInput): Actor
  findFirstDirector(cursor: DirectorWhereUniqueInput, distinct: [DirectorScalarFieldEnum!], orderBy: [DirectorOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: DirectorWhereInput): Director
  findFirstEpisode(cursor: EpisodeWhereUniqueInput, distinct: [EpisodeScalarFieldEnum!], orderBy: [EpisodeOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: EpisodeWhereInput): Episode
  findFirstGenre(cursor: GenreWhereUniqueInput, distinct: [GenreScalarFieldEnum!], orderBy: [GenreOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: GenreWhereInput): Genre
  findFirstLanguage(cursor: LanguageWhereUniqueInput, distinct: [LanguageScalarFieldEnum!], orderBy: [LanguageOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: LanguageWhereInput): Language
  findFirstMovie(cursor: MovieWhereUniqueInput, distinct: [MovieScalarFieldEnum!], orderBy: [MovieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: MovieWhereInput): Movie
  findFirstSeason(cursor: SeasonWhereUniqueInput, distinct: [SeasonScalarFieldEnum!], orderBy: [SeasonOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: SeasonWhereInput): Season
  findFirstSerie(cursor: SerieWhereUniqueInput, distinct: [SerieScalarFieldEnum!], orderBy: [SerieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: SerieWhereInput): Serie
  findFirstSession(cursor: SessionWhereUniqueInput, distinct: [SessionScalarFieldEnum!], orderBy: [SessionOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: SessionWhereInput): Session
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: UserWhereInput): User
  findFirstVerificationRequest(cursor: VerificationRequestWhereUniqueInput, distinct: [VerificationRequestScalarFieldEnum!], orderBy: [VerificationRequestOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: VerificationRequestWhereInput): VerificationRequest
  genre(where: GenreWhereUniqueInput!): Genre
  genres(cursor: GenreWhereUniqueInput, distinct: [GenreScalarFieldEnum!], orderBy: [GenreOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: GenreWhereInput): [Genre!]!
  groupByAccount(by: [AccountScalarFieldEnum!]!, having: AccountScalarWhereWithAggregatesInput, orderBy: [AccountOrderByWithAggregationInput!], skip: Int, take: Int, where: AccountWhereInput): [AccountGroupBy!]!
  groupByActor(by: [ActorScalarFieldEnum!]!, having: ActorScalarWhereWithAggregatesInput, orderBy: [ActorOrderByWithAggregationInput!], skip: Int, take: Int, where: ActorWhereInput): [ActorGroupBy!]!
  groupByDirector(by: [DirectorScalarFieldEnum!]!, having: DirectorScalarWhereWithAggregatesInput, orderBy: [DirectorOrderByWithAggregationInput!], skip: Int, take: Int, where: DirectorWhereInput): [DirectorGroupBy!]!
  groupByEpisode(by: [EpisodeScalarFieldEnum!]!, having: EpisodeScalarWhereWithAggregatesInput, orderBy: [EpisodeOrderByWithAggregationInput!], skip: Int, take: Int, where: EpisodeWhereInput): [EpisodeGroupBy!]!
  groupByGenre(by: [GenreScalarFieldEnum!]!, having: GenreScalarWhereWithAggregatesInput, orderBy: [GenreOrderByWithAggregationInput!], skip: Int, take: Int, where: GenreWhereInput): [GenreGroupBy!]!
  groupByLanguage(by: [LanguageScalarFieldEnum!]!, having: LanguageScalarWhereWithAggregatesInput, orderBy: [LanguageOrderByWithAggregationInput!], skip: Int, take: Int, where: LanguageWhereInput): [LanguageGroupBy!]!
  groupByMovie(by: [MovieScalarFieldEnum!]!, having: MovieScalarWhereWithAggregatesInput, orderBy: [MovieOrderByWithAggregationInput!], skip: Int, take: Int, where: MovieWhereInput): [MovieGroupBy!]!
  groupBySeason(by: [SeasonScalarFieldEnum!]!, having: SeasonScalarWhereWithAggregatesInput, orderBy: [SeasonOrderByWithAggregationInput!], skip: Int, take: Int, where: SeasonWhereInput): [SeasonGroupBy!]!
  groupBySerie(by: [SerieScalarFieldEnum!]!, having: SerieScalarWhereWithAggregatesInput, orderBy: [SerieOrderByWithAggregationInput!], skip: Int, take: Int, where: SerieWhereInput): [SerieGroupBy!]!
  groupBySession(by: [SessionScalarFieldEnum!]!, having: SessionScalarWhereWithAggregatesInput, orderBy: [SessionOrderByWithAggregationInput!], skip: Int, take: Int, where: SessionWhereInput): [SessionGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  groupByVerificationRequest(by: [VerificationRequestScalarFieldEnum!]!, having: VerificationRequestScalarWhereWithAggregatesInput, orderBy: [VerificationRequestOrderByWithAggregationInput!], skip: Int, take: Int, where: VerificationRequestWhereInput): [VerificationRequestGroupBy!]!
  language(where: LanguageWhereUniqueInput!): Language
  languages(cursor: LanguageWhereUniqueInput, distinct: [LanguageScalarFieldEnum!], orderBy: [LanguageOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: LanguageWhereInput): [Language!]!
  movie(where: MovieWhereUniqueInput!): Movie
  movies(cursor: MovieWhereUniqueInput, distinct: [MovieScalarFieldEnum!], orderBy: [MovieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: MovieWhereInput): [Movie!]!
  season(where: SeasonWhereUniqueInput!): Season
  seasons(cursor: SeasonWhereUniqueInput, distinct: [SeasonScalarFieldEnum!], orderBy: [SeasonOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: SeasonWhereInput): [Season!]!
  serie(where: SerieWhereUniqueInput!): Serie
  series(cursor: SerieWhereUniqueInput, distinct: [SerieScalarFieldEnum!], orderBy: [SerieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: SerieWhereInput): [Serie!]!
  session(where: SessionWhereUniqueInput!): Session
  sessions(cursor: SessionWhereUniqueInput, distinct: [SessionScalarFieldEnum!], orderBy: [SessionOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: SessionWhereInput): [Session!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
  verificationRequest(where: VerificationRequestWhereUniqueInput!): VerificationRequest
  verificationRequests(cursor: VerificationRequestWhereUniqueInput, distinct: [VerificationRequestScalarFieldEnum!], orderBy: [VerificationRequestOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: VerificationRequestWhereInput): [VerificationRequest!]!
}

enum QueryMode {
  default
  insensitive
}

enum Role {
  ADMIN
  USER
}

type Season {
  _count: SeasonCount
  createdAt: DateTime!
  episodeIds(cursor: EpisodeWhereUniqueInput, distinct: [EpisodeScalarFieldEnum!], orderBy: [EpisodeOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: EpisodeWhereInput): [Episode!]!
  episodes: Int!
  id: Int!
  index: Int!
  launchDate: DateTime!
  series: Serie!
  seriesId: Int!
  title: String!
  updatedAt: DateTime!
}

type SeasonAvgAggregate {
  episodes: Float
  id: Float
  index: Float
  seriesId: Float
}

input SeasonAvgOrderByAggregateInput {
  episodes: SortOrder
  id: SortOrder
  index: SortOrder
  seriesId: SortOrder
}

type SeasonCount {
  episodeIds: Int!
}

type SeasonCountAggregate {
  _all: Int!
  createdAt: Int!
  episodes: Int!
  id: Int!
  index: Int!
  launchDate: Int!
  seriesId: Int!
  title: Int!
  updatedAt: Int!
}

input SeasonCountOrderByAggregateInput {
  createdAt: SortOrder
  episodes: SortOrder
  id: SortOrder
  index: SortOrder
  launchDate: SortOrder
  seriesId: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input SeasonCreateInput {
  createdAt: DateTime
  episodeIds: EpisodeCreateNestedManyWithoutSeasonInput
  episodes: Int!
  index: Int!
  launchDate: DateTime
  series: SerieCreateNestedOneWithoutSeasonsInput!
  title: String!
  updatedAt: DateTime
}

input SeasonCreateManyInput {
  createdAt: DateTime
  episodes: Int!
  id: Int
  index: Int!
  launchDate: DateTime
  seriesId: Int!
  title: String!
  updatedAt: DateTime
}

input SeasonCreateManySeriesInput {
  createdAt: DateTime
  episodes: Int!
  id: Int
  index: Int!
  launchDate: DateTime
  title: String!
  updatedAt: DateTime
}

input SeasonCreateManySeriesInputEnvelope {
  data: [SeasonCreateManySeriesInput!]!
  skipDuplicates: Boolean
}

input SeasonCreateNestedManyWithoutSeriesInput {
  connect: [SeasonWhereUniqueInput!]
  connectOrCreate: [SeasonCreateOrConnectWithoutSeriesInput!]
  create: [SeasonCreateWithoutSeriesInput!]
  createMany: SeasonCreateManySeriesInputEnvelope
}

input SeasonCreateNestedOneWithoutEpisodeIdsInput {
  connect: SeasonWhereUniqueInput
  connectOrCreate: SeasonCreateOrConnectWithoutEpisodeIdsInput
  create: SeasonCreateWithoutEpisodeIdsInput
}

input SeasonCreateOrConnectWithoutEpisodeIdsInput {
  create: SeasonCreateWithoutEpisodeIdsInput!
  where: SeasonWhereUniqueInput!
}

input SeasonCreateOrConnectWithoutSeriesInput {
  create: SeasonCreateWithoutSeriesInput!
  where: SeasonWhereUniqueInput!
}

input SeasonCreateWithoutEpisodeIdsInput {
  createdAt: DateTime
  episodes: Int!
  index: Int!
  launchDate: DateTime
  series: SerieCreateNestedOneWithoutSeasonsInput!
  title: String!
  updatedAt: DateTime
}

input SeasonCreateWithoutSeriesInput {
  createdAt: DateTime
  episodeIds: EpisodeCreateNestedManyWithoutSeasonInput
  episodes: Int!
  index: Int!
  launchDate: DateTime
  title: String!
  updatedAt: DateTime
}

type SeasonGroupBy {
  _avg: SeasonAvgAggregate
  _count: SeasonCountAggregate
  _max: SeasonMaxAggregate
  _min: SeasonMinAggregate
  _sum: SeasonSumAggregate
  createdAt: DateTime!
  episodes: Int!
  id: Int!
  index: Int!
  launchDate: DateTime!
  seriesId: Int!
  title: String!
  updatedAt: DateTime!
}

input SeasonListRelationFilter {
  every: SeasonWhereInput
  none: SeasonWhereInput
  some: SeasonWhereInput
}

type SeasonMaxAggregate {
  createdAt: DateTime
  episodes: Int
  id: Int
  index: Int
  launchDate: DateTime
  seriesId: Int
  title: String
  updatedAt: DateTime
}

input SeasonMaxOrderByAggregateInput {
  createdAt: SortOrder
  episodes: SortOrder
  id: SortOrder
  index: SortOrder
  launchDate: SortOrder
  seriesId: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

type SeasonMinAggregate {
  createdAt: DateTime
  episodes: Int
  id: Int
  index: Int
  launchDate: DateTime
  seriesId: Int
  title: String
  updatedAt: DateTime
}

input SeasonMinOrderByAggregateInput {
  createdAt: SortOrder
  episodes: SortOrder
  id: SortOrder
  index: SortOrder
  launchDate: SortOrder
  seriesId: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input SeasonOrderByRelationAggregateInput {
  _count: SortOrder
}

enum SeasonOrderByRelevanceFieldEnum {
  title
}

input SeasonOrderByRelevanceInput {
  fields: [SeasonOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input SeasonOrderByWithAggregationInput {
  _avg: SeasonAvgOrderByAggregateInput
  _count: SeasonCountOrderByAggregateInput
  _max: SeasonMaxOrderByAggregateInput
  _min: SeasonMinOrderByAggregateInput
  _sum: SeasonSumOrderByAggregateInput
  createdAt: SortOrder
  episodes: SortOrder
  id: SortOrder
  index: SortOrder
  launchDate: SortOrder
  seriesId: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input SeasonOrderByWithRelationAndSearchRelevanceInput {
  _relevance: SeasonOrderByRelevanceInput
  createdAt: SortOrder
  episodeIds: EpisodeOrderByRelationAggregateInput
  episodes: SortOrder
  id: SortOrder
  index: SortOrder
  launchDate: SortOrder
  series: SerieOrderByWithRelationAndSearchRelevanceInput
  seriesId: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input SeasonRelationFilter {
  is: SeasonWhereInput
  isNot: SeasonWhereInput
}

enum SeasonScalarFieldEnum {
  createdAt
  episodes
  id
  index
  launchDate
  seriesId
  title
  updatedAt
}

input SeasonScalarWhereInput {
  AND: [SeasonScalarWhereInput!]
  NOT: [SeasonScalarWhereInput!]
  OR: [SeasonScalarWhereInput!]
  createdAt: DateTimeFilter
  episodes: IntFilter
  id: IntFilter
  index: IntFilter
  launchDate: DateTimeFilter
  seriesId: IntFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input SeasonScalarWhereWithAggregatesInput {
  AND: [SeasonScalarWhereWithAggregatesInput!]
  NOT: [SeasonScalarWhereWithAggregatesInput!]
  OR: [SeasonScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  episodes: IntWithAggregatesFilter
  id: IntWithAggregatesFilter
  index: IntWithAggregatesFilter
  launchDate: DateTimeWithAggregatesFilter
  seriesId: IntWithAggregatesFilter
  title: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type SeasonSumAggregate {
  episodes: Int
  id: Int
  index: Int
  seriesId: Int
}

input SeasonSumOrderByAggregateInput {
  episodes: SortOrder
  id: SortOrder
  index: SortOrder
  seriesId: SortOrder
}

input SeasonUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  episodeIds: EpisodeUpdateManyWithoutSeasonInput
  episodes: IntFieldUpdateOperationsInput
  index: IntFieldUpdateOperationsInput
  launchDate: DateTimeFieldUpdateOperationsInput
  series: SerieUpdateOneRequiredWithoutSeasonsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SeasonUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  episodes: IntFieldUpdateOperationsInput
  index: IntFieldUpdateOperationsInput
  launchDate: DateTimeFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SeasonUpdateManyWithWhereWithoutSeriesInput {
  data: SeasonUpdateManyMutationInput!
  where: SeasonScalarWhereInput!
}

input SeasonUpdateManyWithoutSeriesInput {
  connect: [SeasonWhereUniqueInput!]
  connectOrCreate: [SeasonCreateOrConnectWithoutSeriesInput!]
  create: [SeasonCreateWithoutSeriesInput!]
  createMany: SeasonCreateManySeriesInputEnvelope
  delete: [SeasonWhereUniqueInput!]
  deleteMany: [SeasonScalarWhereInput!]
  disconnect: [SeasonWhereUniqueInput!]
  set: [SeasonWhereUniqueInput!]
  update: [SeasonUpdateWithWhereUniqueWithoutSeriesInput!]
  updateMany: [SeasonUpdateManyWithWhereWithoutSeriesInput!]
  upsert: [SeasonUpsertWithWhereUniqueWithoutSeriesInput!]
}

input SeasonUpdateOneRequiredWithoutEpisodeIdsInput {
  connect: SeasonWhereUniqueInput
  connectOrCreate: SeasonCreateOrConnectWithoutEpisodeIdsInput
  create: SeasonCreateWithoutEpisodeIdsInput
  update: SeasonUpdateWithoutEpisodeIdsInput
  upsert: SeasonUpsertWithoutEpisodeIdsInput
}

input SeasonUpdateWithWhereUniqueWithoutSeriesInput {
  data: SeasonUpdateWithoutSeriesInput!
  where: SeasonWhereUniqueInput!
}

input SeasonUpdateWithoutEpisodeIdsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  episodes: IntFieldUpdateOperationsInput
  index: IntFieldUpdateOperationsInput
  launchDate: DateTimeFieldUpdateOperationsInput
  series: SerieUpdateOneRequiredWithoutSeasonsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SeasonUpdateWithoutSeriesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  episodeIds: EpisodeUpdateManyWithoutSeasonInput
  episodes: IntFieldUpdateOperationsInput
  index: IntFieldUpdateOperationsInput
  launchDate: DateTimeFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SeasonUpsertWithWhereUniqueWithoutSeriesInput {
  create: SeasonCreateWithoutSeriesInput!
  update: SeasonUpdateWithoutSeriesInput!
  where: SeasonWhereUniqueInput!
}

input SeasonUpsertWithoutEpisodeIdsInput {
  create: SeasonCreateWithoutEpisodeIdsInput!
  update: SeasonUpdateWithoutEpisodeIdsInput!
}

input SeasonWhereInput {
  AND: [SeasonWhereInput!]
  NOT: [SeasonWhereInput!]
  OR: [SeasonWhereInput!]
  createdAt: DateTimeFilter
  episodeIds: EpisodeListRelationFilter
  episodes: IntFilter
  id: IntFilter
  index: IntFilter
  launchDate: DateTimeFilter
  series: SerieRelationFilter
  seriesId: IntFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input SeasonWhereUniqueInput {
  id: Int
}

type Serie {
  _count: SerieCount
  actors(cursor: ActorWhereUniqueInput, distinct: [ActorScalarFieldEnum!], orderBy: [ActorOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: ActorWhereInput): [Actor!]!
  createdAt: DateTime!
  directors(cursor: DirectorWhereUniqueInput, distinct: [DirectorScalarFieldEnum!], orderBy: [DirectorOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: DirectorWhereInput): [Director!]!
  genres(cursor: GenreWhereUniqueInput, distinct: [GenreScalarFieldEnum!], orderBy: [GenreOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: GenreWhereInput): [Genre!]!
  id: Int!
  imdbID: String!
  imdbRating: Float!
  languages(cursor: LanguageWhereUniqueInput, distinct: [LanguageScalarFieldEnum!], orderBy: [LanguageOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: LanguageWhereInput): [Language!]!
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  seasons(cursor: SeasonWhereUniqueInput, distinct: [SeasonScalarFieldEnum!], orderBy: [SeasonOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: SeasonWhereInput): [Season!]!
  title: String!
  totalSeasons: Int!
  updatedAt: DateTime!
  year: Int!
}

type SerieAvgAggregate {
  id: Float
  imdbRating: Float
  runtime: Float
  totalSeasons: Float
  year: Float
}

input SerieAvgOrderByAggregateInput {
  id: SortOrder
  imdbRating: SortOrder
  runtime: SortOrder
  totalSeasons: SortOrder
  year: SortOrder
}

type SerieCount {
  actors: Int!
  directors: Int!
  genres: Int!
  languages: Int!
  seasons: Int!
}

type SerieCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  imdbID: Int!
  imdbRating: Int!
  plot: Int!
  poster: Int!
  rating: Int!
  release: Int!
  runtime: Int!
  title: Int!
  totalSeasons: Int!
  updatedAt: Int!
  year: Int!
}

input SerieCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  imdbID: SortOrder
  imdbRating: SortOrder
  plot: SortOrder
  poster: SortOrder
  rating: SortOrder
  release: SortOrder
  runtime: SortOrder
  title: SortOrder
  totalSeasons: SortOrder
  updatedAt: SortOrder
  year: SortOrder
}

input SerieCreateInput {
  actors: ActorCreateNestedManyWithoutSeriesInput
  createdAt: DateTime
  directors: DirectorCreateNestedManyWithoutSeriesInput
  genres: GenreCreateNestedManyWithoutSeriesInput
  imdbID: String!
  imdbRating: Float!
  languages: LanguageCreateNestedManyWithoutSeriesInput
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  seasons: SeasonCreateNestedManyWithoutSeriesInput
  title: String!
  totalSeasons: Int!
  updatedAt: DateTime
  year: Int!
}

input SerieCreateManyInput {
  createdAt: DateTime
  id: Int
  imdbID: String!
  imdbRating: Float!
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  title: String!
  totalSeasons: Int!
  updatedAt: DateTime
  year: Int!
}

input SerieCreateNestedManyWithoutGenresInput {
  connect: [SerieWhereUniqueInput!]
  connectOrCreate: [SerieCreateOrConnectWithoutGenresInput!]
  create: [SerieCreateWithoutGenresInput!]
}

input SerieCreateNestedManyWithoutLanguagesInput {
  connect: [SerieWhereUniqueInput!]
  connectOrCreate: [SerieCreateOrConnectWithoutLanguagesInput!]
  create: [SerieCreateWithoutLanguagesInput!]
}

input SerieCreateNestedOneWithoutActorsInput {
  connect: SerieWhereUniqueInput
  connectOrCreate: SerieCreateOrConnectWithoutActorsInput
  create: SerieCreateWithoutActorsInput
}

input SerieCreateNestedOneWithoutDirectorsInput {
  connect: SerieWhereUniqueInput
  connectOrCreate: SerieCreateOrConnectWithoutDirectorsInput
  create: SerieCreateWithoutDirectorsInput
}

input SerieCreateNestedOneWithoutSeasonsInput {
  connect: SerieWhereUniqueInput
  connectOrCreate: SerieCreateOrConnectWithoutSeasonsInput
  create: SerieCreateWithoutSeasonsInput
}

input SerieCreateOrConnectWithoutActorsInput {
  create: SerieCreateWithoutActorsInput!
  where: SerieWhereUniqueInput!
}

input SerieCreateOrConnectWithoutDirectorsInput {
  create: SerieCreateWithoutDirectorsInput!
  where: SerieWhereUniqueInput!
}

input SerieCreateOrConnectWithoutGenresInput {
  create: SerieCreateWithoutGenresInput!
  where: SerieWhereUniqueInput!
}

input SerieCreateOrConnectWithoutLanguagesInput {
  create: SerieCreateWithoutLanguagesInput!
  where: SerieWhereUniqueInput!
}

input SerieCreateOrConnectWithoutSeasonsInput {
  create: SerieCreateWithoutSeasonsInput!
  where: SerieWhereUniqueInput!
}

input SerieCreateWithoutActorsInput {
  createdAt: DateTime
  directors: DirectorCreateNestedManyWithoutSeriesInput
  genres: GenreCreateNestedManyWithoutSeriesInput
  imdbID: String!
  imdbRating: Float!
  languages: LanguageCreateNestedManyWithoutSeriesInput
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  seasons: SeasonCreateNestedManyWithoutSeriesInput
  title: String!
  totalSeasons: Int!
  updatedAt: DateTime
  year: Int!
}

input SerieCreateWithoutDirectorsInput {
  actors: ActorCreateNestedManyWithoutSeriesInput
  createdAt: DateTime
  genres: GenreCreateNestedManyWithoutSeriesInput
  imdbID: String!
  imdbRating: Float!
  languages: LanguageCreateNestedManyWithoutSeriesInput
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  seasons: SeasonCreateNestedManyWithoutSeriesInput
  title: String!
  totalSeasons: Int!
  updatedAt: DateTime
  year: Int!
}

input SerieCreateWithoutGenresInput {
  actors: ActorCreateNestedManyWithoutSeriesInput
  createdAt: DateTime
  directors: DirectorCreateNestedManyWithoutSeriesInput
  imdbID: String!
  imdbRating: Float!
  languages: LanguageCreateNestedManyWithoutSeriesInput
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  seasons: SeasonCreateNestedManyWithoutSeriesInput
  title: String!
  totalSeasons: Int!
  updatedAt: DateTime
  year: Int!
}

input SerieCreateWithoutLanguagesInput {
  actors: ActorCreateNestedManyWithoutSeriesInput
  createdAt: DateTime
  directors: DirectorCreateNestedManyWithoutSeriesInput
  genres: GenreCreateNestedManyWithoutSeriesInput
  imdbID: String!
  imdbRating: Float!
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  seasons: SeasonCreateNestedManyWithoutSeriesInput
  title: String!
  totalSeasons: Int!
  updatedAt: DateTime
  year: Int!
}

input SerieCreateWithoutSeasonsInput {
  actors: ActorCreateNestedManyWithoutSeriesInput
  createdAt: DateTime
  directors: DirectorCreateNestedManyWithoutSeriesInput
  genres: GenreCreateNestedManyWithoutSeriesInput
  imdbID: String!
  imdbRating: Float!
  languages: LanguageCreateNestedManyWithoutSeriesInput
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  title: String!
  totalSeasons: Int!
  updatedAt: DateTime
  year: Int!
}

type SerieGroupBy {
  _avg: SerieAvgAggregate
  _count: SerieCountAggregate
  _max: SerieMaxAggregate
  _min: SerieMinAggregate
  _sum: SerieSumAggregate
  createdAt: DateTime!
  id: Int!
  imdbID: String!
  imdbRating: Float!
  plot: String!
  poster: String!
  rating: String!
  release: DateTime!
  runtime: Int!
  title: String!
  totalSeasons: Int!
  updatedAt: DateTime!
  year: Int!
}

input SerieListRelationFilter {
  every: SerieWhereInput
  none: SerieWhereInput
  some: SerieWhereInput
}

type SerieMaxAggregate {
  createdAt: DateTime
  id: Int
  imdbID: String
  imdbRating: Float
  plot: String
  poster: String
  rating: String
  release: DateTime
  runtime: Int
  title: String
  totalSeasons: Int
  updatedAt: DateTime
  year: Int
}

input SerieMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  imdbID: SortOrder
  imdbRating: SortOrder
  plot: SortOrder
  poster: SortOrder
  rating: SortOrder
  release: SortOrder
  runtime: SortOrder
  title: SortOrder
  totalSeasons: SortOrder
  updatedAt: SortOrder
  year: SortOrder
}

type SerieMinAggregate {
  createdAt: DateTime
  id: Int
  imdbID: String
  imdbRating: Float
  plot: String
  poster: String
  rating: String
  release: DateTime
  runtime: Int
  title: String
  totalSeasons: Int
  updatedAt: DateTime
  year: Int
}

input SerieMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  imdbID: SortOrder
  imdbRating: SortOrder
  plot: SortOrder
  poster: SortOrder
  rating: SortOrder
  release: SortOrder
  runtime: SortOrder
  title: SortOrder
  totalSeasons: SortOrder
  updatedAt: SortOrder
  year: SortOrder
}

input SerieOrderByRelationAggregateInput {
  _count: SortOrder
}

enum SerieOrderByRelevanceFieldEnum {
  imdbID
  plot
  poster
  rating
  title
}

input SerieOrderByRelevanceInput {
  fields: [SerieOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input SerieOrderByWithAggregationInput {
  _avg: SerieAvgOrderByAggregateInput
  _count: SerieCountOrderByAggregateInput
  _max: SerieMaxOrderByAggregateInput
  _min: SerieMinOrderByAggregateInput
  _sum: SerieSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  imdbID: SortOrder
  imdbRating: SortOrder
  plot: SortOrder
  poster: SortOrder
  rating: SortOrder
  release: SortOrder
  runtime: SortOrder
  title: SortOrder
  totalSeasons: SortOrder
  updatedAt: SortOrder
  year: SortOrder
}

input SerieOrderByWithRelationAndSearchRelevanceInput {
  _relevance: SerieOrderByRelevanceInput
  actors: ActorOrderByRelationAggregateInput
  createdAt: SortOrder
  directors: DirectorOrderByRelationAggregateInput
  genres: GenreOrderByRelationAggregateInput
  id: SortOrder
  imdbID: SortOrder
  imdbRating: SortOrder
  languages: LanguageOrderByRelationAggregateInput
  plot: SortOrder
  poster: SortOrder
  rating: SortOrder
  release: SortOrder
  runtime: SortOrder
  seasons: SeasonOrderByRelationAggregateInput
  title: SortOrder
  totalSeasons: SortOrder
  updatedAt: SortOrder
  year: SortOrder
}

input SerieRelationFilter {
  is: SerieWhereInput
  isNot: SerieWhereInput
}

enum SerieScalarFieldEnum {
  createdAt
  id
  imdbID
  imdbRating
  plot
  poster
  rating
  release
  runtime
  title
  totalSeasons
  updatedAt
  year
}

input SerieScalarWhereInput {
  AND: [SerieScalarWhereInput!]
  NOT: [SerieScalarWhereInput!]
  OR: [SerieScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  imdbID: StringFilter
  imdbRating: FloatFilter
  plot: StringFilter
  poster: StringFilter
  rating: StringFilter
  release: DateTimeFilter
  runtime: IntFilter
  title: StringFilter
  totalSeasons: IntFilter
  updatedAt: DateTimeFilter
  year: IntFilter
}

input SerieScalarWhereWithAggregatesInput {
  AND: [SerieScalarWhereWithAggregatesInput!]
  NOT: [SerieScalarWhereWithAggregatesInput!]
  OR: [SerieScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  imdbID: StringWithAggregatesFilter
  imdbRating: FloatWithAggregatesFilter
  plot: StringWithAggregatesFilter
  poster: StringWithAggregatesFilter
  rating: StringWithAggregatesFilter
  release: DateTimeWithAggregatesFilter
  runtime: IntWithAggregatesFilter
  title: StringWithAggregatesFilter
  totalSeasons: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  year: IntWithAggregatesFilter
}

type SerieSumAggregate {
  id: Int
  imdbRating: Float
  runtime: Int
  totalSeasons: Int
  year: Int
}

input SerieSumOrderByAggregateInput {
  id: SortOrder
  imdbRating: SortOrder
  runtime: SortOrder
  totalSeasons: SortOrder
  year: SortOrder
}

input SerieUpdateInput {
  actors: ActorUpdateManyWithoutSeriesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  directors: DirectorUpdateManyWithoutSeriesInput
  genres: GenreUpdateManyWithoutSeriesInput
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  languages: LanguageUpdateManyWithoutSeriesInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  rating: StringFieldUpdateOperationsInput
  release: DateTimeFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  seasons: SeasonUpdateManyWithoutSeriesInput
  title: StringFieldUpdateOperationsInput
  totalSeasons: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  year: IntFieldUpdateOperationsInput
}

input SerieUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  rating: StringFieldUpdateOperationsInput
  release: DateTimeFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  totalSeasons: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  year: IntFieldUpdateOperationsInput
}

input SerieUpdateManyWithWhereWithoutGenresInput {
  data: SerieUpdateManyMutationInput!
  where: SerieScalarWhereInput!
}

input SerieUpdateManyWithWhereWithoutLanguagesInput {
  data: SerieUpdateManyMutationInput!
  where: SerieScalarWhereInput!
}

input SerieUpdateManyWithoutGenresInput {
  connect: [SerieWhereUniqueInput!]
  connectOrCreate: [SerieCreateOrConnectWithoutGenresInput!]
  create: [SerieCreateWithoutGenresInput!]
  delete: [SerieWhereUniqueInput!]
  deleteMany: [SerieScalarWhereInput!]
  disconnect: [SerieWhereUniqueInput!]
  set: [SerieWhereUniqueInput!]
  update: [SerieUpdateWithWhereUniqueWithoutGenresInput!]
  updateMany: [SerieUpdateManyWithWhereWithoutGenresInput!]
  upsert: [SerieUpsertWithWhereUniqueWithoutGenresInput!]
}

input SerieUpdateManyWithoutLanguagesInput {
  connect: [SerieWhereUniqueInput!]
  connectOrCreate: [SerieCreateOrConnectWithoutLanguagesInput!]
  create: [SerieCreateWithoutLanguagesInput!]
  delete: [SerieWhereUniqueInput!]
  deleteMany: [SerieScalarWhereInput!]
  disconnect: [SerieWhereUniqueInput!]
  set: [SerieWhereUniqueInput!]
  update: [SerieUpdateWithWhereUniqueWithoutLanguagesInput!]
  updateMany: [SerieUpdateManyWithWhereWithoutLanguagesInput!]
  upsert: [SerieUpsertWithWhereUniqueWithoutLanguagesInput!]
}

input SerieUpdateOneRequiredWithoutSeasonsInput {
  connect: SerieWhereUniqueInput
  connectOrCreate: SerieCreateOrConnectWithoutSeasonsInput
  create: SerieCreateWithoutSeasonsInput
  update: SerieUpdateWithoutSeasonsInput
  upsert: SerieUpsertWithoutSeasonsInput
}

input SerieUpdateOneWithoutActorsInput {
  connect: SerieWhereUniqueInput
  connectOrCreate: SerieCreateOrConnectWithoutActorsInput
  create: SerieCreateWithoutActorsInput
  delete: Boolean
  disconnect: Boolean
  update: SerieUpdateWithoutActorsInput
  upsert: SerieUpsertWithoutActorsInput
}

input SerieUpdateOneWithoutDirectorsInput {
  connect: SerieWhereUniqueInput
  connectOrCreate: SerieCreateOrConnectWithoutDirectorsInput
  create: SerieCreateWithoutDirectorsInput
  delete: Boolean
  disconnect: Boolean
  update: SerieUpdateWithoutDirectorsInput
  upsert: SerieUpsertWithoutDirectorsInput
}

input SerieUpdateWithWhereUniqueWithoutGenresInput {
  data: SerieUpdateWithoutGenresInput!
  where: SerieWhereUniqueInput!
}

input SerieUpdateWithWhereUniqueWithoutLanguagesInput {
  data: SerieUpdateWithoutLanguagesInput!
  where: SerieWhereUniqueInput!
}

input SerieUpdateWithoutActorsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  directors: DirectorUpdateManyWithoutSeriesInput
  genres: GenreUpdateManyWithoutSeriesInput
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  languages: LanguageUpdateManyWithoutSeriesInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  rating: StringFieldUpdateOperationsInput
  release: DateTimeFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  seasons: SeasonUpdateManyWithoutSeriesInput
  title: StringFieldUpdateOperationsInput
  totalSeasons: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  year: IntFieldUpdateOperationsInput
}

input SerieUpdateWithoutDirectorsInput {
  actors: ActorUpdateManyWithoutSeriesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  genres: GenreUpdateManyWithoutSeriesInput
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  languages: LanguageUpdateManyWithoutSeriesInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  rating: StringFieldUpdateOperationsInput
  release: DateTimeFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  seasons: SeasonUpdateManyWithoutSeriesInput
  title: StringFieldUpdateOperationsInput
  totalSeasons: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  year: IntFieldUpdateOperationsInput
}

input SerieUpdateWithoutGenresInput {
  actors: ActorUpdateManyWithoutSeriesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  directors: DirectorUpdateManyWithoutSeriesInput
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  languages: LanguageUpdateManyWithoutSeriesInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  rating: StringFieldUpdateOperationsInput
  release: DateTimeFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  seasons: SeasonUpdateManyWithoutSeriesInput
  title: StringFieldUpdateOperationsInput
  totalSeasons: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  year: IntFieldUpdateOperationsInput
}

input SerieUpdateWithoutLanguagesInput {
  actors: ActorUpdateManyWithoutSeriesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  directors: DirectorUpdateManyWithoutSeriesInput
  genres: GenreUpdateManyWithoutSeriesInput
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  rating: StringFieldUpdateOperationsInput
  release: DateTimeFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  seasons: SeasonUpdateManyWithoutSeriesInput
  title: StringFieldUpdateOperationsInput
  totalSeasons: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  year: IntFieldUpdateOperationsInput
}

input SerieUpdateWithoutSeasonsInput {
  actors: ActorUpdateManyWithoutSeriesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  directors: DirectorUpdateManyWithoutSeriesInput
  genres: GenreUpdateManyWithoutSeriesInput
  imdbID: StringFieldUpdateOperationsInput
  imdbRating: FloatFieldUpdateOperationsInput
  languages: LanguageUpdateManyWithoutSeriesInput
  plot: StringFieldUpdateOperationsInput
  poster: StringFieldUpdateOperationsInput
  rating: StringFieldUpdateOperationsInput
  release: DateTimeFieldUpdateOperationsInput
  runtime: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  totalSeasons: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  year: IntFieldUpdateOperationsInput
}

input SerieUpsertWithWhereUniqueWithoutGenresInput {
  create: SerieCreateWithoutGenresInput!
  update: SerieUpdateWithoutGenresInput!
  where: SerieWhereUniqueInput!
}

input SerieUpsertWithWhereUniqueWithoutLanguagesInput {
  create: SerieCreateWithoutLanguagesInput!
  update: SerieUpdateWithoutLanguagesInput!
  where: SerieWhereUniqueInput!
}

input SerieUpsertWithoutActorsInput {
  create: SerieCreateWithoutActorsInput!
  update: SerieUpdateWithoutActorsInput!
}

input SerieUpsertWithoutDirectorsInput {
  create: SerieCreateWithoutDirectorsInput!
  update: SerieUpdateWithoutDirectorsInput!
}

input SerieUpsertWithoutSeasonsInput {
  create: SerieCreateWithoutSeasonsInput!
  update: SerieUpdateWithoutSeasonsInput!
}

input SerieWhereInput {
  AND: [SerieWhereInput!]
  NOT: [SerieWhereInput!]
  OR: [SerieWhereInput!]
  actors: ActorListRelationFilter
  createdAt: DateTimeFilter
  directors: DirectorListRelationFilter
  genres: GenreListRelationFilter
  id: IntFilter
  imdbID: StringFilter
  imdbRating: FloatFilter
  languages: LanguageListRelationFilter
  plot: StringFilter
  poster: StringFilter
  rating: StringFilter
  release: DateTimeFilter
  runtime: IntFilter
  seasons: SeasonListRelationFilter
  title: StringFilter
  totalSeasons: IntFilter
  updatedAt: DateTimeFilter
  year: IntFilter
}

input SerieWhereUniqueInput {
  id: Int
  imdbID: String
}

type Session {
  expires: DateTime!
  id: String!
  sessionToken: String!
  user: User!
  userId: String!
}

type SessionCountAggregate {
  _all: Int!
  expires: Int!
  id: Int!
  sessionToken: Int!
  userId: Int!
}

input SessionCountOrderByAggregateInput {
  expires: SortOrder
  id: SortOrder
  sessionToken: SortOrder
  userId: SortOrder
}

input SessionCreateInput {
  expires: DateTime!
  id: String
  sessionToken: String!
  user: UserCreateNestedOneWithoutSessionsInput!
}

input SessionCreateManyInput {
  expires: DateTime!
  id: String
  sessionToken: String!
  userId: String!
}

input SessionCreateManyUserInput {
  expires: DateTime!
  id: String
  sessionToken: String!
}

input SessionCreateManyUserInputEnvelope {
  data: [SessionCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input SessionCreateNestedManyWithoutUserInput {
  connect: [SessionWhereUniqueInput!]
  connectOrCreate: [SessionCreateOrConnectWithoutUserInput!]
  create: [SessionCreateWithoutUserInput!]
  createMany: SessionCreateManyUserInputEnvelope
}

input SessionCreateOrConnectWithoutUserInput {
  create: SessionCreateWithoutUserInput!
  where: SessionWhereUniqueInput!
}

input SessionCreateWithoutUserInput {
  expires: DateTime!
  id: String
  sessionToken: String!
}

type SessionGroupBy {
  _count: SessionCountAggregate
  _max: SessionMaxAggregate
  _min: SessionMinAggregate
  expires: DateTime!
  id: String!
  sessionToken: String!
  userId: String!
}

input SessionListRelationFilter {
  every: SessionWhereInput
  none: SessionWhereInput
  some: SessionWhereInput
}

type SessionMaxAggregate {
  expires: DateTime
  id: String
  sessionToken: String
  userId: String
}

input SessionMaxOrderByAggregateInput {
  expires: SortOrder
  id: SortOrder
  sessionToken: SortOrder
  userId: SortOrder
}

type SessionMinAggregate {
  expires: DateTime
  id: String
  sessionToken: String
  userId: String
}

input SessionMinOrderByAggregateInput {
  expires: SortOrder
  id: SortOrder
  sessionToken: SortOrder
  userId: SortOrder
}

input SessionOrderByRelationAggregateInput {
  _count: SortOrder
}

enum SessionOrderByRelevanceFieldEnum {
  id
  sessionToken
  userId
}

input SessionOrderByRelevanceInput {
  fields: [SessionOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input SessionOrderByWithAggregationInput {
  _count: SessionCountOrderByAggregateInput
  _max: SessionMaxOrderByAggregateInput
  _min: SessionMinOrderByAggregateInput
  expires: SortOrder
  id: SortOrder
  sessionToken: SortOrder
  userId: SortOrder
}

input SessionOrderByWithRelationAndSearchRelevanceInput {
  _relevance: SessionOrderByRelevanceInput
  expires: SortOrder
  id: SortOrder
  sessionToken: SortOrder
  user: UserOrderByWithRelationAndSearchRelevanceInput
  userId: SortOrder
}

enum SessionScalarFieldEnum {
  expires
  id
  sessionToken
  userId
}

input SessionScalarWhereInput {
  AND: [SessionScalarWhereInput!]
  NOT: [SessionScalarWhereInput!]
  OR: [SessionScalarWhereInput!]
  expires: DateTimeFilter
  id: StringFilter
  sessionToken: StringFilter
  userId: StringFilter
}

input SessionScalarWhereWithAggregatesInput {
  AND: [SessionScalarWhereWithAggregatesInput!]
  NOT: [SessionScalarWhereWithAggregatesInput!]
  OR: [SessionScalarWhereWithAggregatesInput!]
  expires: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  sessionToken: StringWithAggregatesFilter
  userId: StringWithAggregatesFilter
}

input SessionUpdateInput {
  expires: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  sessionToken: StringFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutSessionsInput
}

input SessionUpdateManyMutationInput {
  expires: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  sessionToken: StringFieldUpdateOperationsInput
}

input SessionUpdateManyWithWhereWithoutUserInput {
  data: SessionUpdateManyMutationInput!
  where: SessionScalarWhereInput!
}

input SessionUpdateManyWithoutUserInput {
  connect: [SessionWhereUniqueInput!]
  connectOrCreate: [SessionCreateOrConnectWithoutUserInput!]
  create: [SessionCreateWithoutUserInput!]
  createMany: SessionCreateManyUserInputEnvelope
  delete: [SessionWhereUniqueInput!]
  deleteMany: [SessionScalarWhereInput!]
  disconnect: [SessionWhereUniqueInput!]
  set: [SessionWhereUniqueInput!]
  update: [SessionUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [SessionUpdateManyWithWhereWithoutUserInput!]
  upsert: [SessionUpsertWithWhereUniqueWithoutUserInput!]
}

input SessionUpdateWithWhereUniqueWithoutUserInput {
  data: SessionUpdateWithoutUserInput!
  where: SessionWhereUniqueInput!
}

input SessionUpdateWithoutUserInput {
  expires: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  sessionToken: StringFieldUpdateOperationsInput
}

input SessionUpsertWithWhereUniqueWithoutUserInput {
  create: SessionCreateWithoutUserInput!
  update: SessionUpdateWithoutUserInput!
  where: SessionWhereUniqueInput!
}

input SessionWhereInput {
  AND: [SessionWhereInput!]
  NOT: [SessionWhereInput!]
  OR: [SessionWhereInput!]
  expires: DateTimeFilter
  id: StringFilter
  sessionToken: StringFilter
  user: UserRelationFilter
  userId: StringFilter
}

input SessionWhereUniqueInput {
  id: String
  sessionToken: String
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  search: String
  startsWith: String
}

type User {
  _count: UserCount
  accounts(cursor: AccountWhereUniqueInput, distinct: [AccountScalarFieldEnum!], orderBy: [AccountOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: AccountWhereInput): [Account!]!
  createdAt: DateTime!
  email: String!
  emailVerified: DateTime
  firstName: String
  id: String!
  image: String
  lastName: String
  role: Role!
  sessions(cursor: SessionWhereUniqueInput, distinct: [SessionScalarFieldEnum!], orderBy: [SessionOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: SessionWhereInput): [Session!]!
  updatedAt: DateTime!
  username: String
}

type UserCount {
  accounts: Int!
  sessions: Int!
}

type UserCountAggregate {
  _all: Int!
  createdAt: Int!
  email: Int!
  emailVerified: Int!
  firstName: Int!
  id: Int!
  image: Int!
  lastName: Int!
  role: Int!
  updatedAt: Int!
  username: Int!
}

input UserCountOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  emailVerified: SortOrder
  firstName: SortOrder
  id: SortOrder
  image: SortOrder
  lastName: SortOrder
  role: SortOrder
  updatedAt: SortOrder
  username: SortOrder
}

input UserCreateInput {
  accounts: AccountCreateNestedManyWithoutUserInput
  createdAt: DateTime
  email: String!
  emailVerified: DateTime
  firstName: String
  id: String
  image: String
  lastName: String
  role: Role
  sessions: SessionCreateNestedManyWithoutUserInput
  updatedAt: DateTime
  username: String
}

input UserCreateManyInput {
  createdAt: DateTime
  email: String!
  emailVerified: DateTime
  firstName: String
  id: String
  image: String
  lastName: String
  role: Role
  updatedAt: DateTime
  username: String
}

input UserCreateNestedOneWithoutAccountsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutAccountsInput
  create: UserCreateWithoutAccountsInput
}

input UserCreateNestedOneWithoutSessionsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutSessionsInput
  create: UserCreateWithoutSessionsInput
}

input UserCreateOrConnectWithoutAccountsInput {
  create: UserCreateWithoutAccountsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutSessionsInput {
  create: UserCreateWithoutSessionsInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutAccountsInput {
  createdAt: DateTime
  email: String!
  emailVerified: DateTime
  firstName: String
  id: String
  image: String
  lastName: String
  role: Role
  sessions: SessionCreateNestedManyWithoutUserInput
  updatedAt: DateTime
  username: String
}

input UserCreateWithoutSessionsInput {
  accounts: AccountCreateNestedManyWithoutUserInput
  createdAt: DateTime
  email: String!
  emailVerified: DateTime
  firstName: String
  id: String
  image: String
  lastName: String
  role: Role
  updatedAt: DateTime
  username: String
}

type UserGroupBy {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  createdAt: DateTime!
  email: String!
  emailVerified: DateTime
  firstName: String
  id: String!
  image: String
  lastName: String
  role: Role!
  updatedAt: DateTime!
  username: String
}

type UserMaxAggregate {
  createdAt: DateTime
  email: String
  emailVerified: DateTime
  firstName: String
  id: String
  image: String
  lastName: String
  role: Role
  updatedAt: DateTime
  username: String
}

input UserMaxOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  emailVerified: SortOrder
  firstName: SortOrder
  id: SortOrder
  image: SortOrder
  lastName: SortOrder
  role: SortOrder
  updatedAt: SortOrder
  username: SortOrder
}

type UserMinAggregate {
  createdAt: DateTime
  email: String
  emailVerified: DateTime
  firstName: String
  id: String
  image: String
  lastName: String
  role: Role
  updatedAt: DateTime
  username: String
}

input UserMinOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  emailVerified: SortOrder
  firstName: SortOrder
  id: SortOrder
  image: SortOrder
  lastName: SortOrder
  role: SortOrder
  updatedAt: SortOrder
  username: SortOrder
}

enum UserOrderByRelevanceFieldEnum {
  email
  firstName
  id
  image
  lastName
  username
}

input UserOrderByRelevanceInput {
  fields: [UserOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input UserOrderByWithAggregationInput {
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  createdAt: SortOrder
  email: SortOrder
  emailVerified: SortOrder
  firstName: SortOrder
  id: SortOrder
  image: SortOrder
  lastName: SortOrder
  role: SortOrder
  updatedAt: SortOrder
  username: SortOrder
}

input UserOrderByWithRelationAndSearchRelevanceInput {
  _relevance: UserOrderByRelevanceInput
  accounts: AccountOrderByRelationAggregateInput
  createdAt: SortOrder
  email: SortOrder
  emailVerified: SortOrder
  firstName: SortOrder
  id: SortOrder
  image: SortOrder
  lastName: SortOrder
  role: SortOrder
  sessions: SessionOrderByRelationAggregateInput
  updatedAt: SortOrder
  username: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  createdAt
  email
  emailVerified
  firstName
  id
  image
  lastName
  role
  updatedAt
  username
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  email: StringWithAggregatesFilter
  emailVerified: DateTimeNullableWithAggregatesFilter
  firstName: StringNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  image: StringNullableWithAggregatesFilter
  lastName: StringNullableWithAggregatesFilter
  role: EnumRoleWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  username: StringNullableWithAggregatesFilter
}

input UserUpdateInput {
  accounts: AccountUpdateManyWithoutUserInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  lastName: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  sessions: SessionUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  lastName: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutAccountsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutAccountsInput
  create: UserCreateWithoutAccountsInput
  update: UserUpdateWithoutAccountsInput
  upsert: UserUpsertWithoutAccountsInput
}

input UserUpdateOneRequiredWithoutSessionsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutSessionsInput
  create: UserCreateWithoutSessionsInput
  update: UserUpdateWithoutSessionsInput
  upsert: UserUpsertWithoutSessionsInput
}

input UserUpdateWithoutAccountsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  lastName: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  sessions: SessionUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
}

input UserUpdateWithoutSessionsInput {
  accounts: AccountUpdateManyWithoutUserInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  lastName: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
}

input UserUpsertWithoutAccountsInput {
  create: UserCreateWithoutAccountsInput!
  update: UserUpdateWithoutAccountsInput!
}

input UserUpsertWithoutSessionsInput {
  create: UserCreateWithoutSessionsInput!
  update: UserUpdateWithoutSessionsInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  accounts: AccountListRelationFilter
  createdAt: DateTimeFilter
  email: StringFilter
  emailVerified: DateTimeNullableFilter
  firstName: StringNullableFilter
  id: StringFilter
  image: StringNullableFilter
  lastName: StringNullableFilter
  role: EnumRoleFilter
  sessions: SessionListRelationFilter
  updatedAt: DateTimeFilter
  username: StringNullableFilter
}

input UserWhereUniqueInput {
  email: String
  id: String
  username: String
}

type VerificationRequest {
  expires: DateTime!
  identifier: String!
  token: String!
}

type VerificationRequestCountAggregate {
  _all: Int!
  expires: Int!
  identifier: Int!
  token: Int!
}

input VerificationRequestCountOrderByAggregateInput {
  expires: SortOrder
  identifier: SortOrder
  token: SortOrder
}

input VerificationRequestCreateInput {
  expires: DateTime!
  identifier: String!
  token: String!
}

input VerificationRequestCreateManyInput {
  expires: DateTime!
  identifier: String!
  token: String!
}

type VerificationRequestGroupBy {
  _count: VerificationRequestCountAggregate
  _max: VerificationRequestMaxAggregate
  _min: VerificationRequestMinAggregate
  expires: DateTime!
  identifier: String!
  token: String!
}

input VerificationRequestIdentifierTokenCompoundUniqueInput {
  identifier: String!
  token: String!
}

type VerificationRequestMaxAggregate {
  expires: DateTime
  identifier: String
  token: String
}

input VerificationRequestMaxOrderByAggregateInput {
  expires: SortOrder
  identifier: SortOrder
  token: SortOrder
}

type VerificationRequestMinAggregate {
  expires: DateTime
  identifier: String
  token: String
}

input VerificationRequestMinOrderByAggregateInput {
  expires: SortOrder
  identifier: SortOrder
  token: SortOrder
}

enum VerificationRequestOrderByRelevanceFieldEnum {
  identifier
  token
}

input VerificationRequestOrderByRelevanceInput {
  fields: [VerificationRequestOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input VerificationRequestOrderByWithAggregationInput {
  _count: VerificationRequestCountOrderByAggregateInput
  _max: VerificationRequestMaxOrderByAggregateInput
  _min: VerificationRequestMinOrderByAggregateInput
  expires: SortOrder
  identifier: SortOrder
  token: SortOrder
}

input VerificationRequestOrderByWithRelationAndSearchRelevanceInput {
  _relevance: VerificationRequestOrderByRelevanceInput
  expires: SortOrder
  identifier: SortOrder
  token: SortOrder
}

enum VerificationRequestScalarFieldEnum {
  expires
  identifier
  token
}

input VerificationRequestScalarWhereWithAggregatesInput {
  AND: [VerificationRequestScalarWhereWithAggregatesInput!]
  NOT: [VerificationRequestScalarWhereWithAggregatesInput!]
  OR: [VerificationRequestScalarWhereWithAggregatesInput!]
  expires: DateTimeWithAggregatesFilter
  identifier: StringWithAggregatesFilter
  token: StringWithAggregatesFilter
}

input VerificationRequestUpdateInput {
  expires: DateTimeFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  token: StringFieldUpdateOperationsInput
}

input VerificationRequestUpdateManyMutationInput {
  expires: DateTimeFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  token: StringFieldUpdateOperationsInput
}

input VerificationRequestWhereInput {
  AND: [VerificationRequestWhereInput!]
  NOT: [VerificationRequestWhereInput!]
  OR: [VerificationRequestWhereInput!]
  expires: DateTimeFilter
  identifier: StringFilter
  token: StringFilter
}

input VerificationRequestWhereUniqueInput {
  identifier_token: VerificationRequestIdentifierTokenCompoundUniqueInput
  token: String
}
